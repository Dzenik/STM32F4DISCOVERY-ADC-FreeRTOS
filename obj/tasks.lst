   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.global	pxCurrentTCB
  25              		.section	.bss.pxCurrentTCB,"aw",%nobits
  26              		.align	2
  29              	pxCurrentTCB:
  30 0000 00000000 		.space	4
  31              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  32              		.align	2
  35              	pxReadyTasksLists:
  36 0000 00000000 		.space	100
  36      00000000 
  36      00000000 
  36      00000000 
  36      00000000 
  37              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  38              		.align	2
  41              	xDelayedTaskList1:
  42 0000 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
  42      00000000 
  43              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  44              		.align	2
  47              	xDelayedTaskList2:
  48 0000 00000000 		.space	20
  48      00000000 
  48      00000000 
  48      00000000 
  48      00000000 
  49              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  50              		.align	2
  53              	pxDelayedTaskList:
  54 0000 00000000 		.space	4
  55              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  56              		.align	2
  59              	pxOverflowDelayedTaskList:
  60 0000 00000000 		.space	4
  61              		.section	.bss.xPendingReadyList,"aw",%nobits
  62              		.align	2
  65              	xPendingReadyList:
  66 0000 00000000 		.space	20
  66      00000000 
  66      00000000 
  66      00000000 
  66      00000000 
  67              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  68              		.align	2
  71              	xTasksWaitingTermination:
  72 0000 00000000 		.space	20
  72      00000000 
  72      00000000 
  72      00000000 
  72      00000000 
  73              		.section	.bss.uxTasksDeleted,"aw",%nobits
  74              		.align	2
  77              	uxTasksDeleted:
  78 0000 00000000 		.space	4
  79              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  80              		.align	2
  83              	xSuspendedTaskList:
  84 0000 00000000 		.space	20
  84      00000000 
  84      00000000 
  84      00000000 
  84      00000000 
  85              		.section	.bss.xIdleTaskHandle,"aw",%nobits
  86              		.align	2
  89              	xIdleTaskHandle:
  90 0000 00000000 		.space	4
  91              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  92              		.align	2
  95              	uxCurrentNumberOfTasks:
  96 0000 00000000 		.space	4
  97              		.section	.bss.xTickCount,"aw",%nobits
  98              		.align	2
 101              	xTickCount:
 102 0000 00000000 		.space	4
 103              		.section	.bss.uxTopUsedPriority,"aw",%nobits
 104              		.align	2
 107              	uxTopUsedPriority:
 108 0000 00000000 		.space	4
 109              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 110              		.align	2
 113              	uxTopReadyPriority:
 114 0000 00000000 		.space	4
 115              		.section	.bss.xSchedulerRunning,"aw",%nobits
 116              		.align	2
 119              	xSchedulerRunning:
 120 0000 00000000 		.space	4
 121              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 122              		.align	2
 125              	uxSchedulerSuspended:
 126 0000 00000000 		.space	4
 127              		.section	.bss.uxMissedTicks,"aw",%nobits
 128              		.align	2
 131              	uxMissedTicks:
 132 0000 00000000 		.space	4
 133              		.section	.bss.xMissedYield,"aw",%nobits
 134              		.align	2
 137              	xMissedYield:
 138 0000 00000000 		.space	4
 139              		.section	.bss.xNumOfOverflows,"aw",%nobits
 140              		.align	2
 143              	xNumOfOverflows:
 144 0000 00000000 		.space	4
 145              		.section	.bss.uxTaskNumber,"aw",%nobits
 146              		.align	2
 149              	uxTaskNumber:
 150 0000 00000000 		.space	4
 151              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 152              		.align	2
 155              	xNextTaskUnblockTime:
 156 0000 FFFFFFFF 		.word	-1
 157              		.section	.bss.pcStatsString,"aw",%nobits
 158              		.align	2
 161              	pcStatsString:
 162 0000 00000000 		.space	50
 162      00000000 
 162      00000000 
 162      00000000 
 162      00000000 
 163 0032 0000     		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 164              		.align	2
 167              	ulTaskSwitchedInTime:
 168 0000 00000000 		.space	4
 169              		.section	.text.xTaskGenericCreate,"ax",%progbits
 170              		.align	2
 171              		.global	xTaskGenericCreate
 172              		.thumb
 173              		.thumb_func
 175              	xTaskGenericCreate:
 176              	.LFB110:
 177              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c **** 	
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:FreeRTOS/Source/tasks.c **** 
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/tasks.c **** 
  27:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/tasks.c **** 
  42:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/tasks.c **** 
  44:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/tasks.c ****     contact details.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/tasks.c ****     critical systems.
  49:FreeRTOS/Source/tasks.c **** 
  50:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:FreeRTOS/Source/tasks.c **** */
  53:FreeRTOS/Source/tasks.c **** 
  54:FreeRTOS/Source/tasks.c **** 
  55:FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:FreeRTOS/Source/tasks.c **** #include <string.h>
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:FreeRTOS/Source/tasks.c **** 
  64:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:FreeRTOS/Source/tasks.c **** #include "task.h"
  66:FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:FreeRTOS/Source/tasks.c **** 
  69:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/tasks.c **** 
  71:FreeRTOS/Source/tasks.c **** /*
  72:FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:FreeRTOS/Source/tasks.c ****  */
  74:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:FreeRTOS/Source/tasks.c **** 
  76:FreeRTOS/Source/tasks.c **** /*
  77:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:FreeRTOS/Source/tasks.c ****  */
  80:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:FreeRTOS/Source/tasks.c **** {
  82:FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:FreeRTOS/Source/tasks.c **** 
  84:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:FreeRTOS/Source/tasks.c **** 	#endif	
  87:FreeRTOS/Source/tasks.c **** 	
  88:FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:FreeRTOS/Source/tasks.c **** 
  94:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:FreeRTOS/Source/tasks.c **** 	#endif
  97:FreeRTOS/Source/tasks.c **** 
  98:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:FreeRTOS/Source/tasks.c **** 	#endif
 101:FreeRTOS/Source/tasks.c **** 
 102:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:FreeRTOS/Source/tasks.c **** 	#endif
 105:FreeRTOS/Source/tasks.c **** 
 106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:FreeRTOS/Source/tasks.c **** 	#endif
 109:FreeRTOS/Source/tasks.c **** 
 110:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:FreeRTOS/Source/tasks.c **** 	#endif
 113:FreeRTOS/Source/tasks.c **** 
 114:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:FreeRTOS/Source/tasks.c **** 	#endif
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** } tskTCB;
 119:FreeRTOS/Source/tasks.c **** 
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /*
 122:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:FreeRTOS/Source/tasks.c ****  * than file scope.
 124:FreeRTOS/Source/tasks.c ****  */
 125:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:FreeRTOS/Source/tasks.c **** 	#define static
 127:FreeRTOS/Source/tasks.c **** #endif
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:FreeRTOS/Source/tasks.c **** 
 141:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:FreeRTOS/Source/tasks.c **** 
 146:FreeRTOS/Source/tasks.c **** #endif
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** #endif
 153:FreeRTOS/Source/tasks.c **** 
 154:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:FreeRTOS/Source/tasks.c **** 	
 156:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:FreeRTOS/Source/tasks.c **** 	
 158:FreeRTOS/Source/tasks.c **** #endif
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:FreeRTOS/Source/tasks.c **** 
 173:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** #endif
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:FreeRTOS/Source/tasks.c **** 
 183:FreeRTOS/Source/tasks.c **** /*
 184:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:FreeRTOS/Source/tasks.c ****  */
 187:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:FreeRTOS/Source/tasks.c **** 
 189:FreeRTOS/Source/tasks.c **** /*
 190:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:FreeRTOS/Source/tasks.c ****  */
 192:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /*
 198:FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:FreeRTOS/Source/tasks.c ****  */
 200:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:FreeRTOS/Source/tasks.c **** 
 202:FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:FreeRTOS/Source/tasks.c **** 
 210:FreeRTOS/Source/tasks.c **** #endif
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:FreeRTOS/Source/tasks.c ****  */
 220:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:FreeRTOS/Source/tasks.c **** 
 222:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:FreeRTOS/Source/tasks.c **** 	{																								\
 224:FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:FreeRTOS/Source/tasks.c **** 		{																							\
 226:FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:FreeRTOS/Source/tasks.c **** 			{																						\
 228:FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:FreeRTOS/Source/tasks.c **** 				{																					\
 230:FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:FreeRTOS/Source/tasks.c **** 				}																					\
 236:FreeRTOS/Source/tasks.c **** 				else																				\
 237:FreeRTOS/Source/tasks.c **** 				{																					\
 238:FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:FreeRTOS/Source/tasks.c **** 				}																					\
 240:FreeRTOS/Source/tasks.c **** 			}																						\
 241:FreeRTOS/Source/tasks.c **** 		}																							\
 242:FreeRTOS/Source/tasks.c **** 	}
 243:FreeRTOS/Source/tasks.c **** 
 244:FreeRTOS/Source/tasks.c **** #else
 245:FreeRTOS/Source/tasks.c **** 
 246:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:FreeRTOS/Source/tasks.c **** 
 248:FreeRTOS/Source/tasks.c **** #endif
 249:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:FreeRTOS/Source/tasks.c **** 
 251:FreeRTOS/Source/tasks.c **** /*
 252:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:FreeRTOS/Source/tasks.c ****  */
 258:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:FreeRTOS/Source/tasks.c **** 	{																													\
 261:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:FreeRTOS/Source/tasks.c **** 	}																													\
 263:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** /*
 267:FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:FreeRTOS/Source/tasks.c ****  * any require waking.
 269:FreeRTOS/Source/tasks.c ****  *
 270:FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:FreeRTOS/Source/tasks.c ****  */
 274:FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:FreeRTOS/Source/tasks.c **** {																						\
 276:FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:FreeRTOS/Source/tasks.c **** 																						\
 278:FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:FreeRTOS/Source/tasks.c **** 	{																					\
 282:FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:FreeRTOS/Source/tasks.c **** 		{																				\
 284:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:FreeRTOS/Source/tasks.c **** 			{																			\
 286:FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:FreeRTOS/Source/tasks.c **** 				break;																	\
 292:FreeRTOS/Source/tasks.c **** 			}																			\
 293:FreeRTOS/Source/tasks.c **** 			else																		\
 294:FreeRTOS/Source/tasks.c **** 			{																			\
 295:FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:FreeRTOS/Source/tasks.c **** 																						\
 302:FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:FreeRTOS/Source/tasks.c **** 				{																		\
 304:FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:FreeRTOS/Source/tasks.c **** 					break;																\
 310:FreeRTOS/Source/tasks.c **** 				}																		\
 311:FreeRTOS/Source/tasks.c **** 																						\
 312:FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:FreeRTOS/Source/tasks.c **** 																						\
 315:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:FreeRTOS/Source/tasks.c **** 				{																		\
 318:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:FreeRTOS/Source/tasks.c **** 				}																		\
 320:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:FreeRTOS/Source/tasks.c **** 			}																			\
 322:FreeRTOS/Source/tasks.c **** 		}																				\
 323:FreeRTOS/Source/tasks.c **** 	}																					\
 324:FreeRTOS/Source/tasks.c **** }
 325:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:FreeRTOS/Source/tasks.c **** 
 327:FreeRTOS/Source/tasks.c **** /*
 328:FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:FreeRTOS/Source/tasks.c ****  */
 333:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:FreeRTOS/Source/tasks.c **** 		
 339:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:FreeRTOS/Source/tasks.c **** 
 341:FreeRTOS/Source/tasks.c **** /*
 342:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:FreeRTOS/Source/tasks.c ****  */
 345:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:FreeRTOS/Source/tasks.c **** 
 347:FreeRTOS/Source/tasks.c **** /*
 348:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:FreeRTOS/Source/tasks.c ****  */
 351:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /*
 354:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:FreeRTOS/Source/tasks.c ****  *
 358:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:FreeRTOS/Source/tasks.c ****  *
 361:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:FreeRTOS/Source/tasks.c ****  *
 363:FreeRTOS/Source/tasks.c ****  */
 364:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** /*
 367:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:FreeRTOS/Source/tasks.c ****  *
 370:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:FreeRTOS/Source/tasks.c ****  */
 373:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** #endif
 378:FreeRTOS/Source/tasks.c **** 
 379:FreeRTOS/Source/tasks.c **** /*
 380:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:FreeRTOS/Source/tasks.c ****  */
 384:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:FreeRTOS/Source/tasks.c **** 
 386:FreeRTOS/Source/tasks.c **** /*
 387:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:FreeRTOS/Source/tasks.c ****  */
 390:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:FreeRTOS/Source/tasks.c **** 
 392:FreeRTOS/Source/tasks.c **** /*
 393:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:FreeRTOS/Source/tasks.c ****  */
 396:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** /*
 399:FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:FreeRTOS/Source/tasks.c ****  * within just that list.
 403:FreeRTOS/Source/tasks.c ****  *
 404:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:FreeRTOS/Source/tasks.c ****  */
 407:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #endif
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** /*
 414:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:FreeRTOS/Source/tasks.c ****  */
 418:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:FreeRTOS/Source/tasks.c **** 
 420:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** #endif
 423:FreeRTOS/Source/tasks.c **** 
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:FreeRTOS/Source/tasks.c **** {
 178              		.loc 1 434 0
 179              		.cfi_startproc
 180              		@ args = 16, pretend = 0, frame = 32
 181              		@ frame_needed = 1, uses_anonymous_args = 0
 182 0000 80B5     		push	{r7, lr}
 183              	.LCFI0:
 184              		.cfi_def_cfa_offset 8
 185 0002 8AB0     		sub	sp, sp, #40
 186              	.LCFI1:
 187              		.cfi_def_cfa_offset 48
 188 0004 02AF     		add	r7, sp, #8
 189              		.cfi_offset 14, -4
 190              		.cfi_offset 7, -8
 191              	.LCFI2:
 192              		.cfi_def_cfa 7, 40
 193 0006 F860     		str	r0, [r7, #12]
 194 0008 B960     		str	r1, [r7, #8]
 195 000a 3B60     		str	r3, [r7, #0]
 196 000c 1346     		mov	r3, r2	@ movhi
 197 000e FB80     		strh	r3, [r7, #6]	@ movhi
 435:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:FreeRTOS/Source/tasks.c **** 
 438:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:FreeRTOS/Source/tasks.c **** 
 441:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 198              		.loc 1 443 0
 199 0010 FB88     		ldrh	r3, [r7, #6]
 200 0012 1846     		mov	r0, r3
 201 0014 396B     		ldr	r1, [r7, #48]
 202 0016 FFF7FEFF 		bl	prvAllocateTCBAndStack
 203 001a B861     		str	r0, [r7, #24]
 444:FreeRTOS/Source/tasks.c **** 
 445:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 204              		.loc 1 445 0
 205 001c BB69     		ldr	r3, [r7, #24]
 206 001e 002B     		cmp	r3, #0
 207 0020 78D0     		beq	.L2
 208              	.LBB2:
 446:FreeRTOS/Source/tasks.c **** 	{
 447:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:FreeRTOS/Source/tasks.c **** 
 449:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:FreeRTOS/Source/tasks.c **** 			{
 454:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:FreeRTOS/Source/tasks.c **** 			}
 456:FreeRTOS/Source/tasks.c **** 			else
 457:FreeRTOS/Source/tasks.c **** 			{
 458:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:FreeRTOS/Source/tasks.c **** 			}
 460:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:FreeRTOS/Source/tasks.c **** 
 463:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:FreeRTOS/Source/tasks.c **** 		{
 469:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 209              		.loc 1 469 0
 210 0022 BB69     		ldr	r3, [r7, #24]
 211 0024 1A6B     		ldr	r2, [r3, #48]
 212 0026 FB88     		ldrh	r3, [r7, #6]
 213 0028 03F1FF33 		add	r3, r3, #-1
 214 002c 4FEA8303 		lsl	r3, r3, #2
 215 0030 D318     		adds	r3, r2, r3
 216 0032 7B61     		str	r3, [r7, #20]
 470:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 217              		.loc 1 470 0
 218 0034 7B69     		ldr	r3, [r7, #20]
 219 0036 23F00703 		bic	r3, r3, #7
 220 003a 7B61     		str	r3, [r7, #20]
 471:FreeRTOS/Source/tasks.c **** 
 472:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:FreeRTOS/Source/tasks.c **** 		}
 475:FreeRTOS/Source/tasks.c **** 		#else
 476:FreeRTOS/Source/tasks.c **** 		{
 477:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:FreeRTOS/Source/tasks.c **** 			
 479:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:FreeRTOS/Source/tasks.c **** 		}
 487:FreeRTOS/Source/tasks.c **** 		#endif
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 221              		.loc 1 490 0
 222 003c FB88     		ldrh	r3, [r7, #6]
 223 003e 0093     		str	r3, [sp, #0]
 224 0040 B869     		ldr	r0, [r7, #24]
 225 0042 B968     		ldr	r1, [r7, #8]
 226 0044 BA6A     		ldr	r2, [r7, #40]
 227 0046 7B6B     		ldr	r3, [r7, #52]
 228 0048 FFF7FEFF 		bl	prvInitialiseTCBVariables
 491:FreeRTOS/Source/tasks.c **** 
 492:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:FreeRTOS/Source/tasks.c **** 		{
 498:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:FreeRTOS/Source/tasks.c **** 		}
 500:FreeRTOS/Source/tasks.c **** 		#else
 501:FreeRTOS/Source/tasks.c **** 		{
 502:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 229              		.loc 1 502 0
 230 004c 7869     		ldr	r0, [r7, #20]
 231 004e F968     		ldr	r1, [r7, #12]
 232 0050 3A68     		ldr	r2, [r7, #0]
 233 0052 FFF7FEFF 		bl	pxPortInitialiseStack
 234 0056 0346     		mov	r3, r0
 235 0058 1A46     		mov	r2, r3
 236 005a BB69     		ldr	r3, [r7, #24]
 237 005c 1A60     		str	r2, [r3, #0]
 503:FreeRTOS/Source/tasks.c **** 		}
 504:FreeRTOS/Source/tasks.c **** 		#endif
 505:FreeRTOS/Source/tasks.c **** 
 506:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 238              		.loc 1 509 0
 239 005e FB6A     		ldr	r3, [r7, #44]
 240 0060 002B     		cmp	r3, #0
 241 0062 02D0     		beq	.L3
 510:FreeRTOS/Source/tasks.c **** 		{
 511:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:FreeRTOS/Source/tasks.c **** 			required.*/
 514:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 242              		.loc 1 514 0
 243 0064 FB6A     		ldr	r3, [r7, #44]
 244 0066 BA69     		ldr	r2, [r7, #24]
 245 0068 1A60     		str	r2, [r3, #0]
 246              	.L3:
 515:FreeRTOS/Source/tasks.c **** 		}
 516:FreeRTOS/Source/tasks.c **** 		
 517:FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 247              		.loc 1 519 0
 248 006a FFF7FEFF 		bl	vPortEnterCritical
 520:FreeRTOS/Source/tasks.c **** 		{
 521:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 249              		.loc 1 521 0
 250 006e 354B     		ldr	r3, .L10
 251 0070 1B68     		ldr	r3, [r3, #0]
 252 0072 03F10102 		add	r2, r3, #1
 253 0076 334B     		ldr	r3, .L10
 254 0078 1A60     		str	r2, [r3, #0]
 522:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 255              		.loc 1 522 0
 256 007a 334B     		ldr	r3, .L10+4
 257 007c 1B68     		ldr	r3, [r3, #0]
 258 007e 002B     		cmp	r3, #0
 259 0080 09D1     		bne	.L4
 523:FreeRTOS/Source/tasks.c **** 			{
 524:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 260              		.loc 1 526 0
 261 0082 314B     		ldr	r3, .L10+4
 262 0084 BA69     		ldr	r2, [r7, #24]
 263 0086 1A60     		str	r2, [r3, #0]
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 264              		.loc 1 528 0
 265 0088 2E4B     		ldr	r3, .L10
 266 008a 1B68     		ldr	r3, [r3, #0]
 267 008c 012B     		cmp	r3, #1
 268 008e 0FD1     		bne	.L5
 529:FreeRTOS/Source/tasks.c **** 				{
 530:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 269              		.loc 1 533 0
 270 0090 FFF7FEFF 		bl	prvInitialiseTaskLists
 271 0094 0CE0     		b	.L5
 272              	.L4:
 534:FreeRTOS/Source/tasks.c **** 				}
 535:FreeRTOS/Source/tasks.c **** 			}
 536:FreeRTOS/Source/tasks.c **** 			else
 537:FreeRTOS/Source/tasks.c **** 			{
 538:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:FreeRTOS/Source/tasks.c **** 				so far. */
 541:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 273              		.loc 1 541 0
 274 0096 2D4B     		ldr	r3, .L10+8
 275 0098 1B68     		ldr	r3, [r3, #0]
 276 009a 002B     		cmp	r3, #0
 277 009c 08D1     		bne	.L5
 542:FreeRTOS/Source/tasks.c **** 				{
 543:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 278              		.loc 1 543 0
 279 009e 2A4B     		ldr	r3, .L10+4
 280 00a0 1B68     		ldr	r3, [r3, #0]
 281 00a2 DA6A     		ldr	r2, [r3, #44]
 282 00a4 BB6A     		ldr	r3, [r7, #40]
 283 00a6 9A42     		cmp	r2, r3
 284 00a8 02D8     		bhi	.L5
 544:FreeRTOS/Source/tasks.c **** 					{
 545:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 285              		.loc 1 545 0
 286 00aa 274B     		ldr	r3, .L10+4
 287 00ac BA69     		ldr	r2, [r7, #24]
 288 00ae 1A60     		str	r2, [r3, #0]
 289              	.L5:
 546:FreeRTOS/Source/tasks.c **** 					}
 547:FreeRTOS/Source/tasks.c **** 				}
 548:FreeRTOS/Source/tasks.c **** 			}
 549:FreeRTOS/Source/tasks.c **** 
 550:FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 290              		.loc 1 552 0
 291 00b0 BB69     		ldr	r3, [r7, #24]
 292 00b2 DA6A     		ldr	r2, [r3, #44]
 293 00b4 264B     		ldr	r3, .L10+12
 294 00b6 1B68     		ldr	r3, [r3, #0]
 295 00b8 9A42     		cmp	r2, r3
 296 00ba 03D9     		bls	.L6
 553:FreeRTOS/Source/tasks.c **** 			{
 554:FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 297              		.loc 1 554 0
 298 00bc BB69     		ldr	r3, [r7, #24]
 299 00be DA6A     		ldr	r2, [r3, #44]
 300 00c0 234B     		ldr	r3, .L10+12
 301 00c2 1A60     		str	r2, [r3, #0]
 302              	.L6:
 555:FreeRTOS/Source/tasks.c **** 			}
 556:FreeRTOS/Source/tasks.c **** 
 557:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:FreeRTOS/Source/tasks.c **** 			{
 559:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:FreeRTOS/Source/tasks.c **** 			}
 562:FreeRTOS/Source/tasks.c **** 			#endif
 563:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 303              		.loc 1 563 0
 304 00c4 234B     		ldr	r3, .L10+16
 305 00c6 1B68     		ldr	r3, [r3, #0]
 306 00c8 03F10102 		add	r2, r3, #1
 307 00cc 214B     		ldr	r3, .L10+16
 308 00ce 1A60     		str	r2, [r3, #0]
 564:FreeRTOS/Source/tasks.c **** 
 565:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 309              		.loc 1 565 0
 310 00d0 BB69     		ldr	r3, [r7, #24]
 311 00d2 DA6A     		ldr	r2, [r3, #44]
 312 00d4 204B     		ldr	r3, .L10+20
 313 00d6 1B68     		ldr	r3, [r3, #0]
 314 00d8 9A42     		cmp	r2, r3
 315 00da 03D9     		bls	.L7
 316              		.loc 1 565 0 is_stmt 0 discriminator 1
 317 00dc BB69     		ldr	r3, [r7, #24]
 318 00de DA6A     		ldr	r2, [r3, #44]
 319 00e0 1D4B     		ldr	r3, .L10+20
 320 00e2 1A60     		str	r2, [r3, #0]
 321              	.L7:
 322              		.loc 1 565 0 discriminator 2
 323 00e4 BB69     		ldr	r3, [r7, #24]
 324 00e6 DA6A     		ldr	r2, [r3, #44]
 325 00e8 1346     		mov	r3, r2
 326 00ea 4FEA8303 		lsl	r3, r3, #2
 327 00ee 9B18     		adds	r3, r3, r2
 328 00f0 4FEA8303 		lsl	r3, r3, #2
 329 00f4 1A46     		mov	r2, r3
 330 00f6 194B     		ldr	r3, .L10+24
 331 00f8 D218     		adds	r2, r2, r3
 332 00fa BB69     		ldr	r3, [r7, #24]
 333 00fc 03F10403 		add	r3, r3, #4
 334 0100 1046     		mov	r0, r2
 335 0102 1946     		mov	r1, r3
 336 0104 FFF7FEFF 		bl	vListInsertEnd
 566:FreeRTOS/Source/tasks.c **** 
 567:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 337              		.loc 1 567 0 is_stmt 1 discriminator 2
 338 0108 4FF00103 		mov	r3, #1
 339 010c FB61     		str	r3, [r7, #28]
 568:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:FreeRTOS/Source/tasks.c **** 		}
 570:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 340              		.loc 1 570 0 discriminator 2
 341 010e FFF7FEFF 		bl	vPortExitCritical
 342 0112 02E0     		b	.L8
 343              	.L2:
 344              	.LBE2:
 571:FreeRTOS/Source/tasks.c **** 	}
 572:FreeRTOS/Source/tasks.c **** 	else
 573:FreeRTOS/Source/tasks.c **** 	{
 574:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 345              		.loc 1 574 0
 346 0114 4FF0FF33 		mov	r3, #-1
 347 0118 FB61     		str	r3, [r7, #28]
 348              	.L8:
 575:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:FreeRTOS/Source/tasks.c **** 	}
 577:FreeRTOS/Source/tasks.c **** 
 578:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 349              		.loc 1 578 0
 350 011a FB69     		ldr	r3, [r7, #28]
 351 011c 012B     		cmp	r3, #1
 352 011e 0BD1     		bne	.L9
 579:FreeRTOS/Source/tasks.c **** 	{
 580:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 353              		.loc 1 580 0
 354 0120 0A4B     		ldr	r3, .L10+8
 355 0122 1B68     		ldr	r3, [r3, #0]
 356 0124 002B     		cmp	r3, #0
 357 0126 07D0     		beq	.L9
 581:FreeRTOS/Source/tasks.c **** 		{
 582:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 358              		.loc 1 584 0
 359 0128 074B     		ldr	r3, .L10+4
 360 012a 1B68     		ldr	r3, [r3, #0]
 361 012c DA6A     		ldr	r2, [r3, #44]
 362 012e BB6A     		ldr	r3, [r7, #40]
 363 0130 9A42     		cmp	r2, r3
 364 0132 01D2     		bcs	.L9
 585:FreeRTOS/Source/tasks.c **** 			{
 586:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 365              		.loc 1 586 0
 366 0134 FFF7FEFF 		bl	vPortYieldFromISR
 367              	.L9:
 587:FreeRTOS/Source/tasks.c **** 			}
 588:FreeRTOS/Source/tasks.c **** 		}
 589:FreeRTOS/Source/tasks.c **** 	}
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** 	return xReturn;
 368              		.loc 1 591 0
 369 0138 FB69     		ldr	r3, [r7, #28]
 592:FreeRTOS/Source/tasks.c **** }
 370              		.loc 1 592 0
 371 013a 1846     		mov	r0, r3
 372 013c 07F12007 		add	r7, r7, #32
 373 0140 BD46     		mov	sp, r7
 374 0142 80BD     		pop	{r7, pc}
 375              	.L11:
 376              		.align	2
 377              	.L10:
 378 0144 00000000 		.word	uxCurrentNumberOfTasks
 379 0148 00000000 		.word	pxCurrentTCB
 380 014c 00000000 		.word	xSchedulerRunning
 381 0150 00000000 		.word	uxTopUsedPriority
 382 0154 00000000 		.word	uxTaskNumber
 383 0158 00000000 		.word	uxTopReadyPriority
 384 015c 00000000 		.word	pxReadyTasksLists
 385              		.cfi_endproc
 386              	.LFE110:
 388              		.section	.text.vTaskDelete,"ax",%progbits
 389              		.align	2
 390              		.global	vTaskDelete
 391              		.thumb
 392              		.thumb_func
 394              	vTaskDelete:
 395              	.LFB111:
 593:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:FreeRTOS/Source/tasks.c **** 
 597:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:FreeRTOS/Source/tasks.c **** 	{
 396              		.loc 1 598 0
 397              		.cfi_startproc
 398              		@ args = 0, pretend = 0, frame = 16
 399              		@ frame_needed = 1, uses_anonymous_args = 0
 400 0000 80B5     		push	{r7, lr}
 401              	.LCFI3:
 402              		.cfi_def_cfa_offset 8
 403 0002 84B0     		sub	sp, sp, #16
 404              	.LCFI4:
 405              		.cfi_def_cfa_offset 24
 406 0004 00AF     		add	r7, sp, #0
 407              		.cfi_offset 14, -4
 408              		.cfi_offset 7, -8
 409              	.LCFI5:
 410              		.cfi_def_cfa_register 7
 411 0006 7860     		str	r0, [r7, #4]
 599:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:FreeRTOS/Source/tasks.c **** 
 601:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 412              		.loc 1 601 0
 413 0008 FFF7FEFF 		bl	vPortEnterCritical
 602:FreeRTOS/Source/tasks.c **** 		{
 603:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:FreeRTOS/Source/tasks.c **** 			deleted. */
 605:FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 414              		.loc 1 605 0
 415 000c 204B     		ldr	r3, .L18
 416 000e 1B68     		ldr	r3, [r3, #0]
 417 0010 7A68     		ldr	r2, [r7, #4]
 418 0012 9A42     		cmp	r2, r3
 419 0014 02D1     		bne	.L13
 606:FreeRTOS/Source/tasks.c **** 			{
 607:FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 420              		.loc 1 607 0
 421 0016 4FF00003 		mov	r3, #0
 422 001a 7B60     		str	r3, [r7, #4]
 423              	.L13:
 608:FreeRTOS/Source/tasks.c **** 			}
 609:FreeRTOS/Source/tasks.c **** 
 610:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 424              		.loc 1 611 0
 425 001c 7B68     		ldr	r3, [r7, #4]
 426 001e 002B     		cmp	r3, #0
 427 0020 02D1     		bne	.L14
 428              		.loc 1 611 0 is_stmt 0 discriminator 1
 429 0022 1B4B     		ldr	r3, .L18
 430 0024 1B68     		ldr	r3, [r3, #0]
 431 0026 00E0     		b	.L15
 432              	.L14:
 433              		.loc 1 611 0 discriminator 2
 434 0028 7B68     		ldr	r3, [r7, #4]
 435              	.L15:
 436              		.loc 1 611 0 discriminator 3
 437 002a FB60     		str	r3, [r7, #12]
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 438              		.loc 1 617 0 is_stmt 1 discriminator 3
 439 002c FB68     		ldr	r3, [r7, #12]
 440 002e 03F10403 		add	r3, r3, #4
 441 0032 1846     		mov	r0, r3
 442 0034 FFF7FEFF 		bl	vListRemove
 618:FreeRTOS/Source/tasks.c **** 
 619:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 443              		.loc 1 620 0 discriminator 3
 444 0038 FB68     		ldr	r3, [r7, #12]
 445 003a 9B6A     		ldr	r3, [r3, #40]
 446 003c 002B     		cmp	r3, #0
 447 003e 05D0     		beq	.L16
 621:FreeRTOS/Source/tasks.c **** 			{
 622:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 448              		.loc 1 622 0
 449 0040 FB68     		ldr	r3, [r7, #12]
 450 0042 03F11803 		add	r3, r3, #24
 451 0046 1846     		mov	r0, r3
 452 0048 FFF7FEFF 		bl	vListRemove
 453              	.L16:
 623:FreeRTOS/Source/tasks.c **** 			}
 624:FreeRTOS/Source/tasks.c **** 
 625:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 454              		.loc 1 625 0
 455 004c FB68     		ldr	r3, [r7, #12]
 456 004e 03F10403 		add	r3, r3, #4
 457 0052 1048     		ldr	r0, .L18+4
 458 0054 1946     		mov	r1, r3
 459 0056 FFF7FEFF 		bl	vListInsertEnd
 626:FreeRTOS/Source/tasks.c **** 
 627:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 460              		.loc 1 630 0
 461 005a 0F4B     		ldr	r3, .L18+8
 462 005c 1B68     		ldr	r3, [r3, #0]
 463 005e 03F10102 		add	r2, r3, #1
 464 0062 0D4B     		ldr	r3, .L18+8
 465 0064 1A60     		str	r2, [r3, #0]
 631:FreeRTOS/Source/tasks.c **** 
 632:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 466              		.loc 1 634 0
 467 0066 0D4B     		ldr	r3, .L18+12
 468 0068 1B68     		ldr	r3, [r3, #0]
 469 006a 03F10102 		add	r2, r3, #1
 470 006e 0B4B     		ldr	r3, .L18+12
 471 0070 1A60     		str	r2, [r3, #0]
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:FreeRTOS/Source/tasks.c **** 		}
 638:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 472              		.loc 1 638 0
 473 0072 FFF7FEFF 		bl	vPortExitCritical
 639:FreeRTOS/Source/tasks.c **** 
 640:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 474              		.loc 1 641 0
 475 0076 0A4B     		ldr	r3, .L18+16
 476 0078 1B68     		ldr	r3, [r3, #0]
 477 007a 002B     		cmp	r3, #0
 478 007c 04D0     		beq	.L12
 642:FreeRTOS/Source/tasks.c **** 		{
 643:FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 479              		.loc 1 643 0
 480 007e 7B68     		ldr	r3, [r7, #4]
 481 0080 002B     		cmp	r3, #0
 482 0082 01D1     		bne	.L12
 644:FreeRTOS/Source/tasks.c **** 			{
 645:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 483              		.loc 1 645 0
 484 0084 FFF7FEFF 		bl	vPortYieldFromISR
 485              	.L12:
 646:FreeRTOS/Source/tasks.c **** 			}
 647:FreeRTOS/Source/tasks.c **** 		}
 648:FreeRTOS/Source/tasks.c **** 	}
 486              		.loc 1 648 0
 487 0088 07F11007 		add	r7, r7, #16
 488 008c BD46     		mov	sp, r7
 489 008e 80BD     		pop	{r7, pc}
 490              	.L19:
 491              		.align	2
 492              	.L18:
 493 0090 00000000 		.word	pxCurrentTCB
 494 0094 00000000 		.word	xTasksWaitingTermination
 495 0098 00000000 		.word	uxTasksDeleted
 496 009c 00000000 		.word	uxTaskNumber
 497 00a0 00000000 		.word	xSchedulerRunning
 498              		.cfi_endproc
 499              	.LFE111:
 501              		.section	.text.vTaskDelayUntil,"ax",%progbits
 502              		.align	2
 503              		.global	vTaskDelayUntil
 504              		.thumb
 505              		.thumb_func
 507              	vTaskDelayUntil:
 508              	.LFB112:
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #endif
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 
 654:FreeRTOS/Source/tasks.c **** 
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:FreeRTOS/Source/tasks.c **** 
 661:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:FreeRTOS/Source/tasks.c **** 
 663:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:FreeRTOS/Source/tasks.c **** 	{
 509              		.loc 1 664 0
 510              		.cfi_startproc
 511              		@ args = 0, pretend = 0, frame = 24
 512              		@ frame_needed = 1, uses_anonymous_args = 0
 513 0000 80B5     		push	{r7, lr}
 514              	.LCFI6:
 515              		.cfi_def_cfa_offset 8
 516 0002 86B0     		sub	sp, sp, #24
 517              	.LCFI7:
 518              		.cfi_def_cfa_offset 32
 519 0004 00AF     		add	r7, sp, #0
 520              		.cfi_offset 14, -4
 521              		.cfi_offset 7, -8
 522              	.LCFI8:
 523              		.cfi_def_cfa_register 7
 524 0006 7860     		str	r0, [r7, #4]
 525 0008 3960     		str	r1, [r7, #0]
 665:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 526              		.loc 1 666 0
 527 000a 4FF00003 		mov	r3, #0
 528 000e 7B61     		str	r3, [r7, #20]
 667:FreeRTOS/Source/tasks.c **** 
 668:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:FreeRTOS/Source/tasks.c **** 
 671:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 529              		.loc 1 671 0
 530 0010 FFF7FEFF 		bl	vTaskSuspendAll
 672:FreeRTOS/Source/tasks.c **** 		{
 673:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 531              		.loc 1 674 0
 532 0014 7B68     		ldr	r3, [r7, #4]
 533 0016 1A68     		ldr	r2, [r3, #0]
 534 0018 3B68     		ldr	r3, [r7, #0]
 535 001a D318     		adds	r3, r2, r3
 536 001c 3B61     		str	r3, [r7, #16]
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 537              		.loc 1 676 0
 538 001e 7B68     		ldr	r3, [r7, #4]
 539 0020 1A68     		ldr	r2, [r3, #0]
 540 0022 1D4B     		ldr	r3, .L26
 541 0024 1B68     		ldr	r3, [r3, #0]
 542 0026 9A42     		cmp	r2, r3
 543 0028 0DD9     		bls	.L21
 677:FreeRTOS/Source/tasks.c **** 			{
 678:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 544              		.loc 1 683 0
 545 002a 7B68     		ldr	r3, [r7, #4]
 546 002c 1A68     		ldr	r2, [r3, #0]
 547 002e 3B69     		ldr	r3, [r7, #16]
 548 0030 9A42     		cmp	r2, r3
 549 0032 15D9     		bls	.L22
 550              		.loc 1 683 0 is_stmt 0 discriminator 1
 551 0034 184B     		ldr	r3, .L26
 552 0036 1B68     		ldr	r3, [r3, #0]
 553 0038 3A69     		ldr	r2, [r7, #16]
 554 003a 9A42     		cmp	r2, r3
 555 003c 10D9     		bls	.L22
 684:FreeRTOS/Source/tasks.c **** 				{
 685:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 556              		.loc 1 685 0 is_stmt 1
 557 003e 4FF00103 		mov	r3, #1
 558 0042 7B61     		str	r3, [r7, #20]
 559 0044 0CE0     		b	.L22
 560              	.L21:
 686:FreeRTOS/Source/tasks.c **** 				}
 687:FreeRTOS/Source/tasks.c **** 			}
 688:FreeRTOS/Source/tasks.c **** 			else
 689:FreeRTOS/Source/tasks.c **** 			{
 690:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 561              		.loc 1 693 0
 562 0046 7B68     		ldr	r3, [r7, #4]
 563 0048 1A68     		ldr	r2, [r3, #0]
 564 004a 3B69     		ldr	r3, [r7, #16]
 565 004c 9A42     		cmp	r2, r3
 566 004e 04D8     		bhi	.L23
 567              		.loc 1 693 0 is_stmt 0 discriminator 1
 568 0050 114B     		ldr	r3, .L26
 569 0052 1B68     		ldr	r3, [r3, #0]
 570 0054 3A69     		ldr	r2, [r7, #16]
 571 0056 9A42     		cmp	r2, r3
 572 0058 02D9     		bls	.L22
 573              	.L23:
 694:FreeRTOS/Source/tasks.c **** 				{
 695:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 574              		.loc 1 695 0 is_stmt 1
 575 005a 4FF00103 		mov	r3, #1
 576 005e 7B61     		str	r3, [r7, #20]
 577              	.L22:
 696:FreeRTOS/Source/tasks.c **** 				}
 697:FreeRTOS/Source/tasks.c **** 			}
 698:FreeRTOS/Source/tasks.c **** 
 699:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 578              		.loc 1 700 0
 579 0060 7B68     		ldr	r3, [r7, #4]
 580 0062 3A69     		ldr	r2, [r7, #16]
 581 0064 1A60     		str	r2, [r3, #0]
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 582              		.loc 1 702 0
 583 0066 7B69     		ldr	r3, [r7, #20]
 584 0068 002B     		cmp	r3, #0
 585 006a 09D0     		beq	.L24
 703:FreeRTOS/Source/tasks.c **** 			{
 704:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:FreeRTOS/Source/tasks.c **** 
 706:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:FreeRTOS/Source/tasks.c **** 				both lists. */
 709:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 586              		.loc 1 709 0
 587 006c 0B4B     		ldr	r3, .L26+4
 588 006e 1B68     		ldr	r3, [r3, #0]
 589 0070 03F10403 		add	r3, r3, #4
 590 0074 1846     		mov	r0, r3
 591 0076 FFF7FEFF 		bl	vListRemove
 710:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 592              		.loc 1 710 0
 593 007a 3869     		ldr	r0, [r7, #16]
 594 007c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 595              	.L24:
 711:FreeRTOS/Source/tasks.c **** 			}
 712:FreeRTOS/Source/tasks.c **** 		}
 713:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 596              		.loc 1 713 0
 597 0080 FFF7FEFF 		bl	xTaskResumeAll
 598 0084 F860     		str	r0, [r7, #12]
 714:FreeRTOS/Source/tasks.c **** 
 715:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 599              		.loc 1 717 0
 600 0086 FB68     		ldr	r3, [r7, #12]
 601 0088 002B     		cmp	r3, #0
 602 008a 01D1     		bne	.L20
 718:FreeRTOS/Source/tasks.c **** 		{
 719:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 603              		.loc 1 719 0
 604 008c FFF7FEFF 		bl	vPortYieldFromISR
 605              	.L20:
 720:FreeRTOS/Source/tasks.c **** 		}
 721:FreeRTOS/Source/tasks.c **** 	}
 606              		.loc 1 721 0
 607 0090 07F11807 		add	r7, r7, #24
 608 0094 BD46     		mov	sp, r7
 609 0096 80BD     		pop	{r7, pc}
 610              	.L27:
 611              		.align	2
 612              	.L26:
 613 0098 00000000 		.word	xTickCount
 614 009c 00000000 		.word	pxCurrentTCB
 615              		.cfi_endproc
 616              	.LFE112:
 618              		.section	.text.vTaskDelay,"ax",%progbits
 619              		.align	2
 620              		.global	vTaskDelay
 621              		.thumb
 622              		.thumb_func
 624              	vTaskDelay:
 625              	.LFB113:
 722:FreeRTOS/Source/tasks.c **** 
 723:FreeRTOS/Source/tasks.c **** #endif
 724:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:FreeRTOS/Source/tasks.c **** 	{
 626              		.loc 1 729 0
 627              		.cfi_startproc
 628              		@ args = 0, pretend = 0, frame = 16
 629              		@ frame_needed = 1, uses_anonymous_args = 0
 630 0000 80B5     		push	{r7, lr}
 631              	.LCFI9:
 632              		.cfi_def_cfa_offset 8
 633 0002 84B0     		sub	sp, sp, #16
 634              	.LCFI10:
 635              		.cfi_def_cfa_offset 24
 636 0004 00AF     		add	r7, sp, #0
 637              		.cfi_offset 14, -4
 638              		.cfi_offset 7, -8
 639              	.LCFI11:
 640              		.cfi_def_cfa_register 7
 641 0006 7860     		str	r0, [r7, #4]
 730:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 642              		.loc 1 731 0
 643 0008 4FF00003 		mov	r3, #0
 644 000c FB60     		str	r3, [r7, #12]
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 645              		.loc 1 734 0
 646 000e 7B68     		ldr	r3, [r7, #4]
 647 0010 002B     		cmp	r3, #0
 648 0012 13D0     		beq	.L29
 735:FreeRTOS/Source/tasks.c **** 		{
 736:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 649              		.loc 1 736 0
 650 0014 FFF7FEFF 		bl	vTaskSuspendAll
 737:FreeRTOS/Source/tasks.c **** 			{
 738:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:FreeRTOS/Source/tasks.c **** 
 740:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:FreeRTOS/Source/tasks.c **** 				is resumed.
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:FreeRTOS/Source/tasks.c **** 				executing task. */
 747:FreeRTOS/Source/tasks.c **** 
 748:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 651              		.loc 1 750 0
 652 0018 0D4B     		ldr	r3, .L31
 653 001a 1A68     		ldr	r2, [r3, #0]
 654 001c 7B68     		ldr	r3, [r7, #4]
 655 001e D318     		adds	r3, r2, r3
 656 0020 BB60     		str	r3, [r7, #8]
 751:FreeRTOS/Source/tasks.c **** 
 752:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:FreeRTOS/Source/tasks.c **** 				both lists. */
 755:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 657              		.loc 1 755 0
 658 0022 0C4B     		ldr	r3, .L31+4
 659 0024 1B68     		ldr	r3, [r3, #0]
 660 0026 03F10403 		add	r3, r3, #4
 661 002a 1846     		mov	r0, r3
 662 002c FFF7FEFF 		bl	vListRemove
 756:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 663              		.loc 1 756 0
 664 0030 B868     		ldr	r0, [r7, #8]
 665 0032 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 757:FreeRTOS/Source/tasks.c **** 			}
 758:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 666              		.loc 1 758 0
 667 0036 FFF7FEFF 		bl	xTaskResumeAll
 668 003a F860     		str	r0, [r7, #12]
 669              	.L29:
 759:FreeRTOS/Source/tasks.c **** 		}
 760:FreeRTOS/Source/tasks.c **** 
 761:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 670              		.loc 1 763 0
 671 003c FB68     		ldr	r3, [r7, #12]
 672 003e 002B     		cmp	r3, #0
 673 0040 01D1     		bne	.L28
 764:FreeRTOS/Source/tasks.c **** 		{
 765:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 674              		.loc 1 765 0
 675 0042 FFF7FEFF 		bl	vPortYieldFromISR
 676              	.L28:
 766:FreeRTOS/Source/tasks.c **** 		}
 767:FreeRTOS/Source/tasks.c **** 	}
 677              		.loc 1 767 0
 678 0046 07F11007 		add	r7, r7, #16
 679 004a BD46     		mov	sp, r7
 680 004c 80BD     		pop	{r7, pc}
 681              	.L32:
 682 004e 00BF     		.align	2
 683              	.L31:
 684 0050 00000000 		.word	xTickCount
 685 0054 00000000 		.word	pxCurrentTCB
 686              		.cfi_endproc
 687              	.LFE113:
 689              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 690              		.align	2
 691              		.global	uxTaskPriorityGet
 692              		.thumb
 693              		.thumb_func
 695              	uxTaskPriorityGet:
 696              	.LFB114:
 768:FreeRTOS/Source/tasks.c **** 
 769:FreeRTOS/Source/tasks.c **** #endif
 770:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:FreeRTOS/Source/tasks.c **** 	{
 697              		.loc 1 775 0
 698              		.cfi_startproc
 699              		@ args = 0, pretend = 0, frame = 16
 700              		@ frame_needed = 1, uses_anonymous_args = 0
 701 0000 80B5     		push	{r7, lr}
 702              	.LCFI12:
 703              		.cfi_def_cfa_offset 8
 704 0002 84B0     		sub	sp, sp, #16
 705              	.LCFI13:
 706              		.cfi_def_cfa_offset 24
 707 0004 00AF     		add	r7, sp, #0
 708              		.cfi_offset 14, -4
 709              		.cfi_offset 7, -8
 710              	.LCFI14:
 711              		.cfi_def_cfa_register 7
 712 0006 7860     		str	r0, [r7, #4]
 776:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 713              		.loc 1 779 0
 714 0008 FFF7FEFF 		bl	vPortEnterCritical
 780:FreeRTOS/Source/tasks.c **** 		{
 781:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 715              		.loc 1 783 0
 716 000c 7B68     		ldr	r3, [r7, #4]
 717 000e 002B     		cmp	r3, #0
 718 0010 02D1     		bne	.L34
 719              		.loc 1 783 0 is_stmt 0 discriminator 1
 720 0012 084B     		ldr	r3, .L36
 721 0014 1B68     		ldr	r3, [r3, #0]
 722 0016 00E0     		b	.L35
 723              	.L34:
 724              		.loc 1 783 0 discriminator 2
 725 0018 7B68     		ldr	r3, [r7, #4]
 726              	.L35:
 727              		.loc 1 783 0 discriminator 3
 728 001a FB60     		str	r3, [r7, #12]
 784:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 729              		.loc 1 784 0 is_stmt 1 discriminator 3
 730 001c FB68     		ldr	r3, [r7, #12]
 731 001e DB6A     		ldr	r3, [r3, #44]
 732 0020 BB60     		str	r3, [r7, #8]
 785:FreeRTOS/Source/tasks.c **** 		}
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 733              		.loc 1 786 0 discriminator 3
 734 0022 FFF7FEFF 		bl	vPortExitCritical
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 735              		.loc 1 788 0 discriminator 3
 736 0026 BB68     		ldr	r3, [r7, #8]
 789:FreeRTOS/Source/tasks.c **** 	}
 737              		.loc 1 789 0 discriminator 3
 738 0028 1846     		mov	r0, r3
 739 002a 07F11007 		add	r7, r7, #16
 740 002e BD46     		mov	sp, r7
 741 0030 80BD     		pop	{r7, pc}
 742              	.L37:
 743 0032 00BF     		.align	2
 744              	.L36:
 745 0034 00000000 		.word	pxCurrentTCB
 746              		.cfi_endproc
 747              	.LFE114:
 749              		.section	.text.vTaskPrioritySet,"ax",%progbits
 750              		.align	2
 751              		.global	vTaskPrioritySet
 752              		.thumb
 753              		.thumb_func
 755              	vTaskPrioritySet:
 756              	.LFB115:
 790:FreeRTOS/Source/tasks.c **** 
 791:FreeRTOS/Source/tasks.c **** #endif
 792:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:FreeRTOS/Source/tasks.c **** 
 796:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:FreeRTOS/Source/tasks.c **** 	{
 757              		.loc 1 797 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 24
 760              		@ frame_needed = 1, uses_anonymous_args = 0
 761 0000 80B5     		push	{r7, lr}
 762              	.LCFI15:
 763              		.cfi_def_cfa_offset 8
 764 0002 86B0     		sub	sp, sp, #24
 765              	.LCFI16:
 766              		.cfi_def_cfa_offset 32
 767 0004 00AF     		add	r7, sp, #0
 768              		.cfi_offset 14, -4
 769              		.cfi_offset 7, -8
 770              	.LCFI17:
 771              		.cfi_def_cfa_register 7
 772 0006 7860     		str	r0, [r7, #4]
 773 0008 3960     		str	r1, [r7, #0]
 798:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 774              		.loc 1 800 0
 775 000a 4FF00003 		mov	r3, #0
 776 000e 7B61     		str	r3, [r7, #20]
 801:FreeRTOS/Source/tasks.c **** 
 802:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:FreeRTOS/Source/tasks.c **** 
 804:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 777              		.loc 1 805 0
 778 0010 3B68     		ldr	r3, [r7, #0]
 779 0012 042B     		cmp	r3, #4
 780 0014 02D9     		bls	.L39
 806:FreeRTOS/Source/tasks.c **** 		{
 807:FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 781              		.loc 1 807 0
 782 0016 4FF00403 		mov	r3, #4
 783 001a 3B60     		str	r3, [r7, #0]
 784              	.L39:
 808:FreeRTOS/Source/tasks.c **** 		}
 809:FreeRTOS/Source/tasks.c **** 
 810:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 785              		.loc 1 810 0
 786 001c FFF7FEFF 		bl	vPortEnterCritical
 811:FreeRTOS/Source/tasks.c **** 		{
 812:FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 787              		.loc 1 812 0
 788 0020 394B     		ldr	r3, .L49
 789 0022 1B68     		ldr	r3, [r3, #0]
 790 0024 7A68     		ldr	r2, [r7, #4]
 791 0026 9A42     		cmp	r2, r3
 792 0028 02D1     		bne	.L40
 813:FreeRTOS/Source/tasks.c **** 			{
 814:FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 793              		.loc 1 814 0
 794 002a 4FF00003 		mov	r3, #0
 795 002e 7B60     		str	r3, [r7, #4]
 796              	.L40:
 815:FreeRTOS/Source/tasks.c **** 			}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 797              		.loc 1 819 0
 798 0030 7B68     		ldr	r3, [r7, #4]
 799 0032 002B     		cmp	r3, #0
 800 0034 02D1     		bne	.L41
 801              		.loc 1 819 0 is_stmt 0 discriminator 1
 802 0036 344B     		ldr	r3, .L49
 803 0038 1B68     		ldr	r3, [r3, #0]
 804 003a 00E0     		b	.L42
 805              	.L41:
 806              		.loc 1 819 0 discriminator 2
 807 003c 7B68     		ldr	r3, [r7, #4]
 808              	.L42:
 809              		.loc 1 819 0 discriminator 3
 810 003e 3B61     		str	r3, [r7, #16]
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:FreeRTOS/Source/tasks.c **** 			{
 825:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 811              		.loc 1 825 0 is_stmt 1 discriminator 3
 812 0040 3B69     		ldr	r3, [r7, #16]
 813 0042 5B6C     		ldr	r3, [r3, #68]
 814 0044 FB60     		str	r3, [r7, #12]
 826:FreeRTOS/Source/tasks.c **** 			}
 827:FreeRTOS/Source/tasks.c **** 			#else
 828:FreeRTOS/Source/tasks.c **** 			{
 829:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:FreeRTOS/Source/tasks.c **** 			}
 831:FreeRTOS/Source/tasks.c **** 			#endif
 832:FreeRTOS/Source/tasks.c **** 
 833:FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 815              		.loc 1 833 0 discriminator 3
 816 0046 FA68     		ldr	r2, [r7, #12]
 817 0048 3B68     		ldr	r3, [r7, #0]
 818 004a 9A42     		cmp	r2, r3
 819 004c 56D0     		beq	.L43
 834:FreeRTOS/Source/tasks.c **** 			{
 835:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 820              		.loc 1 837 0
 821 004e 3A68     		ldr	r2, [r7, #0]
 822 0050 FB68     		ldr	r3, [r7, #12]
 823 0052 9A42     		cmp	r2, r3
 824 0054 06D9     		bls	.L44
 838:FreeRTOS/Source/tasks.c **** 				{
 839:FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 825              		.loc 1 839 0
 826 0056 7B68     		ldr	r3, [r7, #4]
 827 0058 002B     		cmp	r3, #0
 828 005a 09D0     		beq	.L45
 840:FreeRTOS/Source/tasks.c **** 					{
 841:FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 829              		.loc 1 845 0
 830 005c 4FF00103 		mov	r3, #1
 831 0060 7B61     		str	r3, [r7, #20]
 832 0062 05E0     		b	.L45
 833              	.L44:
 846:FreeRTOS/Source/tasks.c **** 					}
 847:FreeRTOS/Source/tasks.c **** 				}
 848:FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 834              		.loc 1 848 0
 835 0064 7B68     		ldr	r3, [r7, #4]
 836 0066 002B     		cmp	r3, #0
 837 0068 02D1     		bne	.L45
 849:FreeRTOS/Source/tasks.c **** 				{
 850:FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 838              		.loc 1 852 0
 839 006a 4FF00103 		mov	r3, #1
 840 006e 7B61     		str	r3, [r7, #20]
 841              	.L45:
 853:FreeRTOS/Source/tasks.c **** 				}
 854:FreeRTOS/Source/tasks.c **** 
 855:FreeRTOS/Source/tasks.c **** 
 856:FreeRTOS/Source/tasks.c **** 
 857:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:FreeRTOS/Source/tasks.c **** 				{
 859:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 842              		.loc 1 861 0
 843 0070 3B69     		ldr	r3, [r7, #16]
 844 0072 5A6C     		ldr	r2, [r3, #68]
 845 0074 3B69     		ldr	r3, [r7, #16]
 846 0076 DB6A     		ldr	r3, [r3, #44]
 847 0078 9A42     		cmp	r2, r3
 848 007a 02D1     		bne	.L46
 862:FreeRTOS/Source/tasks.c **** 					{
 863:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 849              		.loc 1 863 0
 850 007c 3B69     		ldr	r3, [r7, #16]
 851 007e 3A68     		ldr	r2, [r7, #0]
 852 0080 DA62     		str	r2, [r3, #44]
 853              	.L46:
 864:FreeRTOS/Source/tasks.c **** 					}
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 854              		.loc 1 867 0
 855 0082 3B69     		ldr	r3, [r7, #16]
 856 0084 3A68     		ldr	r2, [r7, #0]
 857 0086 5A64     		str	r2, [r3, #68]
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 				#else
 870:FreeRTOS/Source/tasks.c **** 				{
 871:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:FreeRTOS/Source/tasks.c **** 				}
 873:FreeRTOS/Source/tasks.c **** 				#endif
 874:FreeRTOS/Source/tasks.c **** 
 875:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 858              		.loc 1 875 0
 859 0088 3B68     		ldr	r3, [r7, #0]
 860 008a C3F10502 		rsb	r2, r3, #5
 861 008e 3B69     		ldr	r3, [r7, #16]
 862 0090 9A61     		str	r2, [r3, #24]
 876:FreeRTOS/Source/tasks.c **** 
 877:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 863              		.loc 1 881 0
 864 0092 3B69     		ldr	r3, [r7, #16]
 865 0094 5969     		ldr	r1, [r3, #20]
 866 0096 FA68     		ldr	r2, [r7, #12]
 867 0098 1346     		mov	r3, r2
 868 009a 4FEA8303 		lsl	r3, r3, #2
 869 009e 9B18     		adds	r3, r3, r2
 870 00a0 4FEA8303 		lsl	r3, r3, #2
 871 00a4 1A46     		mov	r2, r3
 872 00a6 194B     		ldr	r3, .L49+4
 873 00a8 D318     		adds	r3, r2, r3
 874 00aa 9942     		cmp	r1, r3
 875 00ac 21D1     		bne	.L47
 882:FreeRTOS/Source/tasks.c **** 				{
 883:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 876              		.loc 1 886 0
 877 00ae 3B69     		ldr	r3, [r7, #16]
 878 00b0 03F10403 		add	r3, r3, #4
 879 00b4 1846     		mov	r0, r3
 880 00b6 FFF7FEFF 		bl	vListRemove
 887:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 881              		.loc 1 887 0
 882 00ba 3B69     		ldr	r3, [r7, #16]
 883 00bc DA6A     		ldr	r2, [r3, #44]
 884 00be 144B     		ldr	r3, .L49+8
 885 00c0 1B68     		ldr	r3, [r3, #0]
 886 00c2 9A42     		cmp	r2, r3
 887 00c4 03D9     		bls	.L48
 888              		.loc 1 887 0 is_stmt 0 discriminator 1
 889 00c6 3B69     		ldr	r3, [r7, #16]
 890 00c8 DA6A     		ldr	r2, [r3, #44]
 891 00ca 114B     		ldr	r3, .L49+8
 892 00cc 1A60     		str	r2, [r3, #0]
 893              	.L48:
 894              		.loc 1 887 0 discriminator 2
 895 00ce 3B69     		ldr	r3, [r7, #16]
 896 00d0 DA6A     		ldr	r2, [r3, #44]
 897 00d2 1346     		mov	r3, r2
 898 00d4 4FEA8303 		lsl	r3, r3, #2
 899 00d8 9B18     		adds	r3, r3, r2
 900 00da 4FEA8303 		lsl	r3, r3, #2
 901 00de 1A46     		mov	r2, r3
 902 00e0 0A4B     		ldr	r3, .L49+4
 903 00e2 D218     		adds	r2, r2, r3
 904 00e4 3B69     		ldr	r3, [r7, #16]
 905 00e6 03F10403 		add	r3, r3, #4
 906 00ea 1046     		mov	r0, r2
 907 00ec 1946     		mov	r1, r3
 908 00ee FFF7FEFF 		bl	vListInsertEnd
 909              	.L47:
 888:FreeRTOS/Source/tasks.c **** 				}
 889:FreeRTOS/Source/tasks.c **** 
 890:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 910              		.loc 1 890 0 is_stmt 1
 911 00f2 7B69     		ldr	r3, [r7, #20]
 912 00f4 012B     		cmp	r3, #1
 913 00f6 01D1     		bne	.L43
 891:FreeRTOS/Source/tasks.c **** 				{
 892:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 914              		.loc 1 892 0
 915 00f8 FFF7FEFF 		bl	vPortYieldFromISR
 916              	.L43:
 893:FreeRTOS/Source/tasks.c **** 				}
 894:FreeRTOS/Source/tasks.c **** 			}
 895:FreeRTOS/Source/tasks.c **** 		}
 896:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 917              		.loc 1 896 0
 918 00fc FFF7FEFF 		bl	vPortExitCritical
 897:FreeRTOS/Source/tasks.c **** 	}
 919              		.loc 1 897 0
 920 0100 07F11807 		add	r7, r7, #24
 921 0104 BD46     		mov	sp, r7
 922 0106 80BD     		pop	{r7, pc}
 923              	.L50:
 924              		.align	2
 925              	.L49:
 926 0108 00000000 		.word	pxCurrentTCB
 927 010c 00000000 		.word	pxReadyTasksLists
 928 0110 00000000 		.word	uxTopReadyPriority
 929              		.cfi_endproc
 930              	.LFE115:
 932              		.section	.text.vTaskSuspend,"ax",%progbits
 933              		.align	2
 934              		.global	vTaskSuspend
 935              		.thumb
 936              		.thumb_func
 938              	vTaskSuspend:
 939              	.LFB116:
 898:FreeRTOS/Source/tasks.c **** 
 899:FreeRTOS/Source/tasks.c **** #endif
 900:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:FreeRTOS/Source/tasks.c **** 
 902:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:FreeRTOS/Source/tasks.c **** 
 904:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:FreeRTOS/Source/tasks.c **** 	{
 940              		.loc 1 905 0
 941              		.cfi_startproc
 942              		@ args = 0, pretend = 0, frame = 16
 943              		@ frame_needed = 1, uses_anonymous_args = 0
 944 0000 80B5     		push	{r7, lr}
 945              	.LCFI18:
 946              		.cfi_def_cfa_offset 8
 947 0002 84B0     		sub	sp, sp, #16
 948              	.LCFI19:
 949              		.cfi_def_cfa_offset 24
 950 0004 00AF     		add	r7, sp, #0
 951              		.cfi_offset 14, -4
 952              		.cfi_offset 7, -8
 953              	.LCFI20:
 954              		.cfi_def_cfa_register 7
 955 0006 7860     		str	r0, [r7, #4]
 906:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:FreeRTOS/Source/tasks.c **** 
 908:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 956              		.loc 1 908 0
 957 0008 FFF7FEFF 		bl	vPortEnterCritical
 909:FreeRTOS/Source/tasks.c **** 		{
 910:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:FreeRTOS/Source/tasks.c **** 			suspended. */
 912:FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 958              		.loc 1 912 0
 959 000c 214B     		ldr	r3, .L59
 960 000e 1B68     		ldr	r3, [r3, #0]
 961 0010 7A68     		ldr	r2, [r7, #4]
 962 0012 9A42     		cmp	r2, r3
 963 0014 02D1     		bne	.L52
 913:FreeRTOS/Source/tasks.c **** 			{
 914:FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 964              		.loc 1 914 0
 965 0016 4FF00003 		mov	r3, #0
 966 001a 7B60     		str	r3, [r7, #4]
 967              	.L52:
 915:FreeRTOS/Source/tasks.c **** 			}
 916:FreeRTOS/Source/tasks.c **** 
 917:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 968              		.loc 1 918 0
 969 001c 7B68     		ldr	r3, [r7, #4]
 970 001e 002B     		cmp	r3, #0
 971 0020 02D1     		bne	.L53
 972              		.loc 1 918 0 is_stmt 0 discriminator 1
 973 0022 1C4B     		ldr	r3, .L59
 974 0024 1B68     		ldr	r3, [r3, #0]
 975 0026 00E0     		b	.L54
 976              	.L53:
 977              		.loc 1 918 0 discriminator 2
 978 0028 7B68     		ldr	r3, [r7, #4]
 979              	.L54:
 980              		.loc 1 918 0 discriminator 3
 981 002a FB60     		str	r3, [r7, #12]
 919:FreeRTOS/Source/tasks.c **** 
 920:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 982              		.loc 1 923 0 is_stmt 1 discriminator 3
 983 002c FB68     		ldr	r3, [r7, #12]
 984 002e 03F10403 		add	r3, r3, #4
 985 0032 1846     		mov	r0, r3
 986 0034 FFF7FEFF 		bl	vListRemove
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 987              		.loc 1 926 0 discriminator 3
 988 0038 FB68     		ldr	r3, [r7, #12]
 989 003a 9B6A     		ldr	r3, [r3, #40]
 990 003c 002B     		cmp	r3, #0
 991 003e 05D0     		beq	.L55
 927:FreeRTOS/Source/tasks.c **** 			{
 928:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 992              		.loc 1 928 0
 993 0040 FB68     		ldr	r3, [r7, #12]
 994 0042 03F11803 		add	r3, r3, #24
 995 0046 1846     		mov	r0, r3
 996 0048 FFF7FEFF 		bl	vListRemove
 997              	.L55:
 929:FreeRTOS/Source/tasks.c **** 			}
 930:FreeRTOS/Source/tasks.c **** 
 931:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 998              		.loc 1 931 0
 999 004c FB68     		ldr	r3, [r7, #12]
 1000 004e 03F10403 		add	r3, r3, #4
 1001 0052 1148     		ldr	r0, .L59+4
 1002 0054 1946     		mov	r1, r3
 1003 0056 FFF7FEFF 		bl	vListInsertEnd
 932:FreeRTOS/Source/tasks.c **** 		}
 933:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 1004              		.loc 1 933 0
 1005 005a FFF7FEFF 		bl	vPortExitCritical
 934:FreeRTOS/Source/tasks.c **** 
 935:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1006              		.loc 1 935 0
 1007 005e 7B68     		ldr	r3, [r7, #4]
 1008 0060 002B     		cmp	r3, #0
 1009 0062 13D1     		bne	.L51
 936:FreeRTOS/Source/tasks.c **** 		{
 937:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1010              		.loc 1 937 0
 1011 0064 0D4B     		ldr	r3, .L59+8
 1012 0066 1B68     		ldr	r3, [r3, #0]
 1013 0068 002B     		cmp	r3, #0
 1014 006a 02D0     		beq	.L57
 938:FreeRTOS/Source/tasks.c **** 			{
 939:FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 1015              		.loc 1 940 0
 1016 006c FFF7FEFF 		bl	vPortYieldFromISR
 1017 0070 0CE0     		b	.L51
 1018              	.L57:
 941:FreeRTOS/Source/tasks.c **** 			}
 942:FreeRTOS/Source/tasks.c **** 			else
 943:FreeRTOS/Source/tasks.c **** 			{
 944:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1019              		.loc 1 947 0
 1020 0072 094B     		ldr	r3, .L59+4
 1021 0074 1A68     		ldr	r2, [r3, #0]
 1022 0076 0A4B     		ldr	r3, .L59+12
 1023 0078 1B68     		ldr	r3, [r3, #0]
 1024 007a 9A42     		cmp	r2, r3
 1025 007c 04D1     		bne	.L58
 948:FreeRTOS/Source/tasks.c **** 				{
 949:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:FreeRTOS/Source/tasks.c **** 					is. */
 953:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 1026              		.loc 1 953 0
 1027 007e 054B     		ldr	r3, .L59
 1028 0080 4FF00002 		mov	r2, #0
 1029 0084 1A60     		str	r2, [r3, #0]
 1030 0086 01E0     		b	.L51
 1031              	.L58:
 954:FreeRTOS/Source/tasks.c **** 				}
 955:FreeRTOS/Source/tasks.c **** 				else
 956:FreeRTOS/Source/tasks.c **** 				{
 957:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 1032              		.loc 1 957 0
 1033 0088 FFF7FEFF 		bl	vTaskSwitchContext
 1034              	.L51:
 958:FreeRTOS/Source/tasks.c **** 				}
 959:FreeRTOS/Source/tasks.c **** 			}
 960:FreeRTOS/Source/tasks.c **** 		}
 961:FreeRTOS/Source/tasks.c **** 	}
 1035              		.loc 1 961 0
 1036 008c 07F11007 		add	r7, r7, #16
 1037 0090 BD46     		mov	sp, r7
 1038 0092 80BD     		pop	{r7, pc}
 1039              	.L60:
 1040              		.align	2
 1041              	.L59:
 1042 0094 00000000 		.word	pxCurrentTCB
 1043 0098 00000000 		.word	xSuspendedTaskList
 1044 009c 00000000 		.word	xSchedulerRunning
 1045 00a0 00000000 		.word	uxCurrentNumberOfTasks
 1046              		.cfi_endproc
 1047              	.LFE116:
 1049              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1050              		.align	2
 1051              		.global	xTaskIsTaskSuspended
 1052              		.thumb
 1053              		.thumb_func
 1055              	xTaskIsTaskSuspended:
 1056              	.LFB117:
 962:FreeRTOS/Source/tasks.c **** 
 963:FreeRTOS/Source/tasks.c **** #endif
 964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:FreeRTOS/Source/tasks.c **** 
 966:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:FreeRTOS/Source/tasks.c **** 
 968:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:FreeRTOS/Source/tasks.c **** 	{
 1057              		.loc 1 969 0
 1058              		.cfi_startproc
 1059              		@ args = 0, pretend = 0, frame = 16
 1060              		@ frame_needed = 1, uses_anonymous_args = 0
 1061              		@ link register save eliminated.
 1062 0000 80B4     		push	{r7}
 1063              	.LCFI21:
 1064              		.cfi_def_cfa_offset 4
 1065 0002 85B0     		sub	sp, sp, #20
 1066              	.LCFI22:
 1067              		.cfi_def_cfa_offset 24
 1068 0004 00AF     		add	r7, sp, #0
 1069              		.cfi_offset 7, -4
 1070              	.LCFI23:
 1071              		.cfi_def_cfa_register 7
 1072 0006 7860     		str	r0, [r7, #4]
 970:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1073              		.loc 1 970 0
 1074 0008 4FF00003 		mov	r3, #0
 1075 000c FB60     		str	r3, [r7, #12]
 971:FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1076              		.loc 1 971 0
 1077 000e 7B68     		ldr	r3, [r7, #4]
 1078 0010 BB60     		str	r3, [r7, #8]
 972:FreeRTOS/Source/tasks.c **** 
 973:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:FreeRTOS/Source/tasks.c **** 
 976:FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1079              		.loc 1 978 0
 1080 0012 BB68     		ldr	r3, [r7, #8]
 1081 0014 5A69     		ldr	r2, [r3, #20]
 1082 0016 0B4B     		ldr	r3, .L63
 1083 0018 9A42     		cmp	r2, r3
 1084 001a 0BD1     		bne	.L62
 979:FreeRTOS/Source/tasks.c **** 		{
 980:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1085              		.loc 1 981 0
 1086 001c BB68     		ldr	r3, [r7, #8]
 1087 001e 9A6A     		ldr	r2, [r3, #40]
 1088 0020 094B     		ldr	r3, .L63+4
 1089 0022 9A42     		cmp	r2, r3
 1090 0024 06D0     		beq	.L62
 982:FreeRTOS/Source/tasks.c **** 			{
 983:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:FreeRTOS/Source/tasks.c **** 				specified. */
 987:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1091              		.loc 1 987 0
 1092 0026 BB68     		ldr	r3, [r7, #8]
 1093 0028 9B6A     		ldr	r3, [r3, #40]
 1094 002a 002B     		cmp	r3, #0
 1095 002c 02D1     		bne	.L62
 988:FreeRTOS/Source/tasks.c **** 				{
 989:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 1096              		.loc 1 989 0
 1097 002e 4FF00103 		mov	r3, #1
 1098 0032 FB60     		str	r3, [r7, #12]
 1099              	.L62:
 990:FreeRTOS/Source/tasks.c **** 				}
 991:FreeRTOS/Source/tasks.c **** 			}
 992:FreeRTOS/Source/tasks.c **** 		}
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 		return xReturn;
 1100              		.loc 1 994 0
 1101 0034 FB68     		ldr	r3, [r7, #12]
 995:FreeRTOS/Source/tasks.c **** 	}
 1102              		.loc 1 995 0
 1103 0036 1846     		mov	r0, r3
 1104 0038 07F11407 		add	r7, r7, #20
 1105 003c BD46     		mov	sp, r7
 1106 003e 80BC     		pop	{r7}
 1107 0040 7047     		bx	lr
 1108              	.L64:
 1109 0042 00BF     		.align	2
 1110              	.L63:
 1111 0044 00000000 		.word	xSuspendedTaskList
 1112 0048 00000000 		.word	xPendingReadyList
 1113              		.cfi_endproc
 1114              	.LFE117:
 1116              		.section	.text.vTaskResume,"ax",%progbits
 1117              		.align	2
 1118              		.global	vTaskResume
 1119              		.thumb
 1120              		.thumb_func
 1122              	vTaskResume:
 1123              	.LFB118:
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** #endif
 998:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:FreeRTOS/Source/tasks.c **** 
1000:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:FreeRTOS/Source/tasks.c **** 
1002:FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:FreeRTOS/Source/tasks.c **** 	{
 1124              		.loc 1 1003 0
 1125              		.cfi_startproc
 1126              		@ args = 0, pretend = 0, frame = 16
 1127              		@ frame_needed = 1, uses_anonymous_args = 0
 1128 0000 80B5     		push	{r7, lr}
 1129              	.LCFI24:
 1130              		.cfi_def_cfa_offset 8
 1131 0002 84B0     		sub	sp, sp, #16
 1132              	.LCFI25:
 1133              		.cfi_def_cfa_offset 24
 1134 0004 00AF     		add	r7, sp, #0
 1135              		.cfi_offset 14, -4
 1136              		.cfi_offset 7, -8
 1137              	.LCFI26:
 1138              		.cfi_def_cfa_register 7
 1139 0006 7860     		str	r0, [r7, #4]
1004:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:FreeRTOS/Source/tasks.c **** 
1009:FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1140              		.loc 1 1011 0
 1141 0008 7B68     		ldr	r3, [r7, #4]
 1142 000a FB60     		str	r3, [r7, #12]
1012:FreeRTOS/Source/tasks.c **** 
1013:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1143              		.loc 1 1015 0
 1144 000c FB68     		ldr	r3, [r7, #12]
 1145 000e 002B     		cmp	r3, #0
 1146 0010 39D0     		beq	.L65
 1147              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1148 0012 1F4B     		ldr	r3, .L69
 1149 0014 1B68     		ldr	r3, [r3, #0]
 1150 0016 FA68     		ldr	r2, [r7, #12]
 1151 0018 9A42     		cmp	r2, r3
 1152 001a 34D0     		beq	.L65
1016:FreeRTOS/Source/tasks.c **** 		{
1017:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
 1153              		.loc 1 1017 0 is_stmt 1
 1154 001c FFF7FEFF 		bl	vPortEnterCritical
1018:FreeRTOS/Source/tasks.c **** 			{
1019:FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1155              		.loc 1 1019 0
 1156 0020 F868     		ldr	r0, [r7, #12]
 1157 0022 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1158 0026 0346     		mov	r3, r0
 1159 0028 012B     		cmp	r3, #1
 1160 002a 2AD1     		bne	.L67
1020:FreeRTOS/Source/tasks.c **** 				{
1021:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:FreeRTOS/Source/tasks.c **** 
1023:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1161              		.loc 1 1025 0
 1162 002c FB68     		ldr	r3, [r7, #12]
 1163 002e 03F10403 		add	r3, r3, #4
 1164 0032 1846     		mov	r0, r3
 1165 0034 FFF7FEFF 		bl	vListRemove
1026:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1166              		.loc 1 1026 0
 1167 0038 FB68     		ldr	r3, [r7, #12]
 1168 003a DA6A     		ldr	r2, [r3, #44]
 1169 003c 154B     		ldr	r3, .L69+4
 1170 003e 1B68     		ldr	r3, [r3, #0]
 1171 0040 9A42     		cmp	r2, r3
 1172 0042 03D9     		bls	.L68
 1173              		.loc 1 1026 0 is_stmt 0 discriminator 1
 1174 0044 FB68     		ldr	r3, [r7, #12]
 1175 0046 DA6A     		ldr	r2, [r3, #44]
 1176 0048 124B     		ldr	r3, .L69+4
 1177 004a 1A60     		str	r2, [r3, #0]
 1178              	.L68:
 1179              		.loc 1 1026 0 discriminator 2
 1180 004c FB68     		ldr	r3, [r7, #12]
 1181 004e DA6A     		ldr	r2, [r3, #44]
 1182 0050 1346     		mov	r3, r2
 1183 0052 4FEA8303 		lsl	r3, r3, #2
 1184 0056 9B18     		adds	r3, r3, r2
 1185 0058 4FEA8303 		lsl	r3, r3, #2
 1186 005c 1A46     		mov	r2, r3
 1187 005e 0E4B     		ldr	r3, .L69+8
 1188 0060 D218     		adds	r2, r2, r3
 1189 0062 FB68     		ldr	r3, [r7, #12]
 1190 0064 03F10403 		add	r3, r3, #4
 1191 0068 1046     		mov	r0, r2
 1192 006a 1946     		mov	r1, r3
 1193 006c FFF7FEFF 		bl	vListInsertEnd
1027:FreeRTOS/Source/tasks.c **** 
1028:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1194              		.loc 1 1029 0 is_stmt 1 discriminator 2
 1195 0070 FB68     		ldr	r3, [r7, #12]
 1196 0072 DA6A     		ldr	r2, [r3, #44]
 1197 0074 064B     		ldr	r3, .L69
 1198 0076 1B68     		ldr	r3, [r3, #0]
 1199 0078 DB6A     		ldr	r3, [r3, #44]
 1200 007a 9A42     		cmp	r2, r3
 1201 007c 01D3     		bcc	.L67
1030:FreeRTOS/Source/tasks.c **** 					{
1031:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
 1202              		.loc 1 1033 0
 1203 007e FFF7FEFF 		bl	vPortYieldFromISR
 1204              	.L67:
1034:FreeRTOS/Source/tasks.c **** 					}
1035:FreeRTOS/Source/tasks.c **** 				}
1036:FreeRTOS/Source/tasks.c **** 			}
1037:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
 1205              		.loc 1 1037 0
 1206 0082 FFF7FEFF 		bl	vPortExitCritical
 1207              	.L65:
1038:FreeRTOS/Source/tasks.c **** 		}
1039:FreeRTOS/Source/tasks.c **** 	}
 1208              		.loc 1 1039 0
 1209 0086 07F11007 		add	r7, r7, #16
 1210 008a BD46     		mov	sp, r7
 1211 008c 80BD     		pop	{r7, pc}
 1212              	.L70:
 1213 008e 00BF     		.align	2
 1214              	.L69:
 1215 0090 00000000 		.word	pxCurrentTCB
 1216 0094 00000000 		.word	uxTopReadyPriority
 1217 0098 00000000 		.word	pxReadyTasksLists
 1218              		.cfi_endproc
 1219              	.LFE118:
 1221              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1222              		.align	2
 1223              		.global	xTaskResumeFromISR
 1224              		.thumb
 1225              		.thumb_func
 1227              	xTaskResumeFromISR:
 1228              	.LFB119:
1040:FreeRTOS/Source/tasks.c **** 
1041:FreeRTOS/Source/tasks.c **** #endif
1042:FreeRTOS/Source/tasks.c **** 
1043:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:FreeRTOS/Source/tasks.c **** 
1045:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:FreeRTOS/Source/tasks.c **** 
1047:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:FreeRTOS/Source/tasks.c **** 	{
 1229              		.loc 1 1048 0
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 16
 1232              		@ frame_needed = 1, uses_anonymous_args = 0
 1233 0000 80B5     		push	{r7, lr}
 1234              	.LCFI27:
 1235              		.cfi_def_cfa_offset 8
 1236 0002 84B0     		sub	sp, sp, #16
 1237              	.LCFI28:
 1238              		.cfi_def_cfa_offset 24
 1239 0004 00AF     		add	r7, sp, #0
 1240              		.cfi_offset 14, -4
 1241              		.cfi_offset 7, -8
 1242              	.LCFI29:
 1243              		.cfi_def_cfa_register 7
 1244 0006 7860     		str	r0, [r7, #4]
1049:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1245              		.loc 1 1049 0
 1246 0008 4FF00003 		mov	r3, #0
 1247 000c FB60     		str	r3, [r7, #12]
1050:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:FreeRTOS/Source/tasks.c **** 
1052:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:FreeRTOS/Source/tasks.c **** 
1054:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1248              		.loc 1 1054 0
 1249 000e 7B68     		ldr	r3, [r7, #4]
 1250 0010 BB60     		str	r3, [r7, #8]
1055:FreeRTOS/Source/tasks.c **** 
1056:FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1251              		.loc 1 1056 0
 1252 0012 B868     		ldr	r0, [r7, #8]
 1253 0014 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1254 0018 0346     		mov	r3, r0
 1255 001a 012B     		cmp	r3, #1
 1256 001c 37D1     		bne	.L72
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:FreeRTOS/Source/tasks.c **** 
1060:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1257              		.loc 1 1060 0
 1258 001e 1F4B     		ldr	r3, .L75
 1259 0020 1B68     		ldr	r3, [r3, #0]
 1260 0022 002B     		cmp	r3, #0
 1261 0024 2CD1     		bne	.L73
1061:FreeRTOS/Source/tasks.c **** 			{
1062:FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1262              		.loc 1 1062 0
 1263 0026 BB68     		ldr	r3, [r7, #8]
 1264 0028 DA6A     		ldr	r2, [r3, #44]
 1265 002a 1D4B     		ldr	r3, .L75+4
 1266 002c 1B68     		ldr	r3, [r3, #0]
 1267 002e DB6A     		ldr	r3, [r3, #44]
 1268 0030 9A42     		cmp	r2, r3
 1269 0032 34BF     		ite	cc
 1270 0034 0023     		movcc	r3, #0
 1271 0036 0123     		movcs	r3, #1
 1272 0038 FB60     		str	r3, [r7, #12]
1063:FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1273              		.loc 1 1063 0
 1274 003a BB68     		ldr	r3, [r7, #8]
 1275 003c 03F10403 		add	r3, r3, #4
 1276 0040 1846     		mov	r0, r3
 1277 0042 FFF7FEFF 		bl	vListRemove
1064:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1278              		.loc 1 1064 0
 1279 0046 BB68     		ldr	r3, [r7, #8]
 1280 0048 DA6A     		ldr	r2, [r3, #44]
 1281 004a 164B     		ldr	r3, .L75+8
 1282 004c 1B68     		ldr	r3, [r3, #0]
 1283 004e 9A42     		cmp	r2, r3
 1284 0050 03D9     		bls	.L74
 1285              		.loc 1 1064 0 is_stmt 0 discriminator 1
 1286 0052 BB68     		ldr	r3, [r7, #8]
 1287 0054 DA6A     		ldr	r2, [r3, #44]
 1288 0056 134B     		ldr	r3, .L75+8
 1289 0058 1A60     		str	r2, [r3, #0]
 1290              	.L74:
 1291              		.loc 1 1064 0 discriminator 2
 1292 005a BB68     		ldr	r3, [r7, #8]
 1293 005c DA6A     		ldr	r2, [r3, #44]
 1294 005e 1346     		mov	r3, r2
 1295 0060 4FEA8303 		lsl	r3, r3, #2
 1296 0064 9B18     		adds	r3, r3, r2
 1297 0066 4FEA8303 		lsl	r3, r3, #2
 1298 006a 1A46     		mov	r2, r3
 1299 006c 0E4B     		ldr	r3, .L75+12
 1300 006e D218     		adds	r2, r2, r3
 1301 0070 BB68     		ldr	r3, [r7, #8]
 1302 0072 03F10403 		add	r3, r3, #4
 1303 0076 1046     		mov	r0, r2
 1304 0078 1946     		mov	r1, r3
 1305 007a FFF7FEFF 		bl	vListInsertEnd
 1306 007e 06E0     		b	.L72
 1307              	.L73:
1065:FreeRTOS/Source/tasks.c **** 			}
1066:FreeRTOS/Source/tasks.c **** 			else
1067:FreeRTOS/Source/tasks.c **** 			{
1068:FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1308              		.loc 1 1071 0 is_stmt 1
 1309 0080 BB68     		ldr	r3, [r7, #8]
 1310 0082 03F11803 		add	r3, r3, #24
 1311 0086 0948     		ldr	r0, .L75+16
 1312 0088 1946     		mov	r1, r3
 1313 008a FFF7FEFF 		bl	vListInsertEnd
 1314              	.L72:
1072:FreeRTOS/Source/tasks.c **** 			}
1073:FreeRTOS/Source/tasks.c **** 		}
1074:FreeRTOS/Source/tasks.c **** 
1075:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
 1315              		.loc 1 1075 0
 1316 008e FB68     		ldr	r3, [r7, #12]
1076:FreeRTOS/Source/tasks.c **** 	}
 1317              		.loc 1 1076 0
 1318 0090 1846     		mov	r0, r3
 1319 0092 07F11007 		add	r7, r7, #16
 1320 0096 BD46     		mov	sp, r7
 1321 0098 80BD     		pop	{r7, pc}
 1322              	.L76:
 1323 009a 00BF     		.align	2
 1324              	.L75:
 1325 009c 00000000 		.word	uxSchedulerSuspended
 1326 00a0 00000000 		.word	pxCurrentTCB
 1327 00a4 00000000 		.word	uxTopReadyPriority
 1328 00a8 00000000 		.word	pxReadyTasksLists
 1329 00ac 00000000 		.word	xPendingReadyList
 1330              		.cfi_endproc
 1331              	.LFE119:
 1333              		.section	.rodata
 1334              		.align	2
 1335              	.LC0:
 1336 0000 49444C45 		.ascii	"IDLE\000"
 1336      00
 1337              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1338              		.align	2
 1339              		.global	vTaskStartScheduler
 1340              		.thumb
 1341              		.thumb_func
 1343              	vTaskStartScheduler:
 1344              	.LFB120:
1077:FreeRTOS/Source/tasks.c **** 
1078:FreeRTOS/Source/tasks.c **** #endif
1079:FreeRTOS/Source/tasks.c **** 
1080:FreeRTOS/Source/tasks.c **** 
1081:FreeRTOS/Source/tasks.c **** 
1082:FreeRTOS/Source/tasks.c **** 
1083:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:FreeRTOS/Source/tasks.c **** 
1087:FreeRTOS/Source/tasks.c **** 
1088:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:FreeRTOS/Source/tasks.c **** {
 1345              		.loc 1 1089 0
 1346              		.cfi_startproc
 1347              		@ args = 0, pretend = 0, frame = 8
 1348              		@ frame_needed = 1, uses_anonymous_args = 0
 1349 0000 80B5     		push	{r7, lr}
 1350              	.LCFI30:
 1351              		.cfi_def_cfa_offset 8
 1352 0002 86B0     		sub	sp, sp, #24
 1353              	.LCFI31:
 1354              		.cfi_def_cfa_offset 32
 1355 0004 04AF     		add	r7, sp, #16
 1356              		.cfi_offset 14, -4
 1357              		.cfi_offset 7, -8
 1358              	.LCFI32:
 1359              		.cfi_def_cfa 7, 16
1090:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:FreeRTOS/Source/tasks.c **** 
1092:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:FreeRTOS/Source/tasks.c **** 	{
1095:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 1360              		.loc 1 1097 0
 1361 0006 164B     		ldr	r3, .L79
 1362 0008 4FF00002 		mov	r2, #0
 1363 000c 0092     		str	r2, [sp, #0]
 1364 000e 154A     		ldr	r2, .L79+4
 1365 0010 0192     		str	r2, [sp, #4]
 1366 0012 4FF00002 		mov	r2, #0
 1367 0016 0292     		str	r2, [sp, #8]
 1368 0018 4FF00002 		mov	r2, #0
 1369 001c 0392     		str	r2, [sp, #12]
 1370 001e 1248     		ldr	r0, .L79+8
 1371 0020 1946     		mov	r1, r3
 1372 0022 4FF48072 		mov	r2, #256
 1373 0026 4FF00003 		mov	r3, #0
 1374 002a FFF7FEFF 		bl	xTaskGenericCreate
 1375 002e 7860     		str	r0, [r7, #4]
1098:FreeRTOS/Source/tasks.c **** 	}
1099:FreeRTOS/Source/tasks.c **** 	#else
1100:FreeRTOS/Source/tasks.c **** 	{
1101:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:FreeRTOS/Source/tasks.c **** 	}
1104:FreeRTOS/Source/tasks.c **** 	#endif
1105:FreeRTOS/Source/tasks.c **** 
1106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:FreeRTOS/Source/tasks.c **** 	{
1108:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:FreeRTOS/Source/tasks.c **** 		{
1110:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:FreeRTOS/Source/tasks.c **** 		}
1112:FreeRTOS/Source/tasks.c **** 	}
1113:FreeRTOS/Source/tasks.c **** 	#endif
1114:FreeRTOS/Source/tasks.c **** 
1115:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 1376              		.loc 1 1115 0
 1377 0030 7B68     		ldr	r3, [r7, #4]
 1378 0032 012B     		cmp	r3, #1
 1379 0034 0FD1     		bne	.L77
1116:FreeRTOS/Source/tasks.c **** 	{
1117:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:FreeRTOS/Source/tasks.c **** 		starts to run.
1122:FreeRTOS/Source/tasks.c **** 
1123:FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
 1380              		.loc 1 1125 0
 1381              	@ 1125 "FreeRTOS/Source/tasks.c" 1
 1382 0036 4FF0BF00 			mov r0, #191								
 1383 003a 80F31188 		msr basepri, r0							
 1384              	
 1385              	@ 0 "" 2
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1386              		.loc 1 1127 0
 1387              		.thumb
 1388 003e 0B4B     		ldr	r3, .L79+12
 1389 0040 4FF00102 		mov	r2, #1
 1390 0044 1A60     		str	r2, [r3, #0]
1128:FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1391              		.loc 1 1128 0
 1392 0046 0A4B     		ldr	r3, .L79+16
 1393 0048 4FF00002 		mov	r2, #0
 1394 004c 1A60     		str	r2, [r3, #0]
1129:FreeRTOS/Source/tasks.c **** 
1130:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 1395              		.loc 1 1133 0
 1396 004e FFF7FEFF 		bl	init_us_timer
1134:FreeRTOS/Source/tasks.c **** 		
1135:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1397              		.loc 1 1137 0
 1398 0052 FFF7FEFF 		bl	xPortStartScheduler
 1399              	.L77:
1138:FreeRTOS/Source/tasks.c **** 		{
1139:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:FreeRTOS/Source/tasks.c **** 		}
1142:FreeRTOS/Source/tasks.c **** 		else
1143:FreeRTOS/Source/tasks.c **** 		{
1144:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:FreeRTOS/Source/tasks.c **** 		}
1146:FreeRTOS/Source/tasks.c **** 	}
1147:FreeRTOS/Source/tasks.c **** 
1148:FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:FreeRTOS/Source/tasks.c **** }
 1400              		.loc 1 1150 0
 1401 0056 07F10807 		add	r7, r7, #8
 1402 005a BD46     		mov	sp, r7
 1403 005c 80BD     		pop	{r7, pc}
 1404              	.L80:
 1405 005e 00BF     		.align	2
 1406              	.L79:
 1407 0060 00000000 		.word	.LC0
 1408 0064 00000000 		.word	xIdleTaskHandle
 1409 0068 00000000 		.word	prvIdleTask
 1410 006c 00000000 		.word	xSchedulerRunning
 1411 0070 00000000 		.word	xTickCount
 1412              		.cfi_endproc
 1413              	.LFE120:
 1415              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1416              		.align	2
 1417              		.global	vTaskEndScheduler
 1418              		.thumb
 1419              		.thumb_func
 1421              	vTaskEndScheduler:
 1422              	.LFB121:
1151:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:FreeRTOS/Source/tasks.c **** 
1153:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:FreeRTOS/Source/tasks.c **** {
 1423              		.loc 1 1154 0
 1424              		.cfi_startproc
 1425              		@ args = 0, pretend = 0, frame = 0
 1426              		@ frame_needed = 1, uses_anonymous_args = 0
 1427 0000 80B5     		push	{r7, lr}
 1428              	.LCFI33:
 1429              		.cfi_def_cfa_offset 8
 1430 0002 00AF     		add	r7, sp, #0
 1431              		.cfi_offset 14, -4
 1432              		.cfi_offset 7, -8
 1433              	.LCFI34:
 1434              		.cfi_def_cfa_register 7
1155:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
 1435              		.loc 1 1158 0
 1436              	@ 1158 "FreeRTOS/Source/tasks.c" 1
 1437 0004 4FF0BF00 			mov r0, #191								
 1438 0008 80F31188 		msr basepri, r0							
 1439              	
 1440              	@ 0 "" 2
1159:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1441              		.loc 1 1159 0
 1442              		.thumb
 1443 000c 034B     		ldr	r3, .L82
 1444 000e 4FF00002 		mov	r2, #0
 1445 0012 1A60     		str	r2, [r3, #0]
1160:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1446              		.loc 1 1160 0
 1447 0014 FFF7FEFF 		bl	vPortEndScheduler
1161:FreeRTOS/Source/tasks.c **** }
 1448              		.loc 1 1161 0
 1449 0018 80BD     		pop	{r7, pc}
 1450              	.L83:
 1451 001a 00BF     		.align	2
 1452              	.L82:
 1453 001c 00000000 		.word	xSchedulerRunning
 1454              		.cfi_endproc
 1455              	.LFE121:
 1457              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1458              		.align	2
 1459              		.global	vTaskSuspendAll
 1460              		.thumb
 1461              		.thumb_func
 1463              	vTaskSuspendAll:
 1464              	.LFB122:
1162:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:FreeRTOS/Source/tasks.c **** 
1164:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:FreeRTOS/Source/tasks.c **** {
 1465              		.loc 1 1165 0
 1466              		.cfi_startproc
 1467              		@ args = 0, pretend = 0, frame = 0
 1468              		@ frame_needed = 1, uses_anonymous_args = 0
 1469              		@ link register save eliminated.
 1470 0000 80B4     		push	{r7}
 1471              	.LCFI35:
 1472              		.cfi_def_cfa_offset 4
 1473 0002 00AF     		add	r7, sp, #0
 1474              		.cfi_offset 7, -4
 1475              	.LCFI36:
 1476              		.cfi_def_cfa_register 7
1166:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
 1477              		.loc 1 1168 0
 1478 0004 044B     		ldr	r3, .L85
 1479 0006 1B68     		ldr	r3, [r3, #0]
 1480 0008 03F10102 		add	r2, r3, #1
 1481 000c 024B     		ldr	r3, .L85
 1482 000e 1A60     		str	r2, [r3, #0]
1169:FreeRTOS/Source/tasks.c **** }
 1483              		.loc 1 1169 0
 1484 0010 BD46     		mov	sp, r7
 1485 0012 80BC     		pop	{r7}
 1486 0014 7047     		bx	lr
 1487              	.L86:
 1488 0016 00BF     		.align	2
 1489              	.L85:
 1490 0018 00000000 		.word	uxSchedulerSuspended
 1491              		.cfi_endproc
 1492              	.LFE122:
 1494              		.section	.text.xTaskResumeAll,"ax",%progbits
 1495              		.align	2
 1496              		.global	xTaskResumeAll
 1497              		.thumb
 1498              		.thumb_func
 1500              	xTaskResumeAll:
 1501              	.LFB123:
1170:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:FreeRTOS/Source/tasks.c **** {
 1502              		.loc 1 1173 0
 1503              		.cfi_startproc
 1504              		@ args = 0, pretend = 0, frame = 8
 1505              		@ frame_needed = 1, uses_anonymous_args = 0
 1506 0000 90B5     		push	{r4, r7, lr}
 1507              	.LCFI37:
 1508              		.cfi_def_cfa_offset 12
 1509 0002 83B0     		sub	sp, sp, #12
 1510              	.LCFI38:
 1511              		.cfi_def_cfa_offset 24
 1512 0004 00AF     		add	r7, sp, #0
 1513              		.cfi_offset 14, -4
 1514              		.cfi_offset 7, -8
 1515              		.cfi_offset 4, -12
 1516              	.LCFI39:
 1517              		.cfi_def_cfa_register 7
1174:FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1518              		.loc 1 1175 0
 1519 0006 4FF00003 		mov	r3, #0
 1520 000a 7B60     		str	r3, [r7, #4]
1176:FreeRTOS/Source/tasks.c **** 
1177:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:FreeRTOS/Source/tasks.c **** 
1181:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1521              		.loc 1 1186 0
 1522 000c FFF7FEFF 		bl	vPortEnterCritical
1187:FreeRTOS/Source/tasks.c **** 	{
1188:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
 1523              		.loc 1 1188 0
 1524 0010 384B     		ldr	r3, .L96
 1525 0012 1B68     		ldr	r3, [r3, #0]
 1526 0014 03F1FF32 		add	r2, r3, #-1
 1527 0018 364B     		ldr	r3, .L96
 1528 001a 1A60     		str	r2, [r3, #0]
1189:FreeRTOS/Source/tasks.c **** 
1190:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1529              		.loc 1 1190 0
 1530 001c 354B     		ldr	r3, .L96
 1531 001e 1B68     		ldr	r3, [r3, #0]
 1532 0020 002B     		cmp	r3, #0
 1533 0022 5ED1     		bne	.L88
1191:FreeRTOS/Source/tasks.c **** 		{
1192:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1534              		.loc 1 1192 0
 1535 0024 344B     		ldr	r3, .L96+4
 1536 0026 1B68     		ldr	r3, [r3, #0]
 1537 0028 002B     		cmp	r3, #0
 1538 002a 5AD0     		beq	.L88
 1539              	.LBB3:
1193:FreeRTOS/Source/tasks.c **** 			{
1194:FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1540              		.loc 1 1194 0
 1541 002c 4FF00003 		mov	r3, #0
 1542 0030 3B60     		str	r3, [r7, #0]
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1543              		.loc 1 1198 0
 1544 0032 2EE0     		b	.L89
 1545              	.L91:
1199:FreeRTOS/Source/tasks.c **** 				{
1200:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1546              		.loc 1 1200 0
 1547 0034 314B     		ldr	r3, .L96+8
 1548 0036 DB68     		ldr	r3, [r3, #12]
 1549 0038 DB68     		ldr	r3, [r3, #12]
 1550 003a 1C46     		mov	r4, r3
1201:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1551              		.loc 1 1201 0
 1552 003c 04F11803 		add	r3, r4, #24
 1553 0040 1846     		mov	r0, r3
 1554 0042 FFF7FEFF 		bl	vListRemove
1202:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1555              		.loc 1 1202 0
 1556 0046 04F10403 		add	r3, r4, #4
 1557 004a 1846     		mov	r0, r3
 1558 004c FFF7FEFF 		bl	vListRemove
1203:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1559              		.loc 1 1203 0
 1560 0050 E26A     		ldr	r2, [r4, #44]
 1561 0052 2B4B     		ldr	r3, .L96+12
 1562 0054 1B68     		ldr	r3, [r3, #0]
 1563 0056 9A42     		cmp	r2, r3
 1564 0058 02D9     		bls	.L90
 1565              		.loc 1 1203 0 is_stmt 0 discriminator 1
 1566 005a E26A     		ldr	r2, [r4, #44]
 1567 005c 284B     		ldr	r3, .L96+12
 1568 005e 1A60     		str	r2, [r3, #0]
 1569              	.L90:
 1570              		.loc 1 1203 0 discriminator 2
 1571 0060 E26A     		ldr	r2, [r4, #44]
 1572 0062 1346     		mov	r3, r2
 1573 0064 4FEA8303 		lsl	r3, r3, #2
 1574 0068 9B18     		adds	r3, r3, r2
 1575 006a 4FEA8303 		lsl	r3, r3, #2
 1576 006e 1A46     		mov	r2, r3
 1577 0070 244B     		ldr	r3, .L96+16
 1578 0072 D218     		adds	r2, r2, r3
 1579 0074 04F10403 		add	r3, r4, #4
 1580 0078 1046     		mov	r0, r2
 1581 007a 1946     		mov	r1, r3
 1582 007c FFF7FEFF 		bl	vListInsertEnd
1204:FreeRTOS/Source/tasks.c **** 
1205:FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1583              		.loc 1 1207 0 is_stmt 1 discriminator 2
 1584 0080 E26A     		ldr	r2, [r4, #44]
 1585 0082 214B     		ldr	r3, .L96+20
 1586 0084 1B68     		ldr	r3, [r3, #0]
 1587 0086 DB6A     		ldr	r3, [r3, #44]
 1588 0088 9A42     		cmp	r2, r3
 1589 008a 02D3     		bcc	.L89
1208:FreeRTOS/Source/tasks.c **** 					{
1209:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1590              		.loc 1 1209 0
 1591 008c 4FF00103 		mov	r3, #1
 1592 0090 3B60     		str	r3, [r7, #0]
 1593              	.L89:
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1594              		.loc 1 1198 0 discriminator 1
 1595 0092 1A4B     		ldr	r3, .L96+8
 1596 0094 1B68     		ldr	r3, [r3, #0]
 1597 0096 002B     		cmp	r3, #0
 1598 0098 CCD1     		bne	.L91
1210:FreeRTOS/Source/tasks.c **** 					}
1211:FreeRTOS/Source/tasks.c **** 				}
1212:FreeRTOS/Source/tasks.c **** 
1213:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1599              		.loc 1 1216 0
 1600 009a 1C4B     		ldr	r3, .L96+24
 1601 009c 1B68     		ldr	r3, [r3, #0]
 1602 009e 002B     		cmp	r3, #0
 1603 00a0 0FD0     		beq	.L92
1217:FreeRTOS/Source/tasks.c **** 				{
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1604              		.loc 1 1218 0
 1605 00a2 07E0     		b	.L93
 1606              	.L94:
1219:FreeRTOS/Source/tasks.c **** 					{
1220:FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
 1607              		.loc 1 1220 0
 1608 00a4 FFF7FEFF 		bl	vTaskIncrementTick
1221:FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1609              		.loc 1 1221 0
 1610 00a8 184B     		ldr	r3, .L96+24
 1611 00aa 1B68     		ldr	r3, [r3, #0]
 1612 00ac 03F1FF32 		add	r2, r3, #-1
 1613 00b0 164B     		ldr	r3, .L96+24
 1614 00b2 1A60     		str	r2, [r3, #0]
 1615              	.L93:
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1616              		.loc 1 1218 0 discriminator 1
 1617 00b4 154B     		ldr	r3, .L96+24
 1618 00b6 1B68     		ldr	r3, [r3, #0]
 1619 00b8 002B     		cmp	r3, #0
 1620 00ba F3D1     		bne	.L94
1222:FreeRTOS/Source/tasks.c **** 					}
1223:FreeRTOS/Source/tasks.c **** 
1224:FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:FreeRTOS/Source/tasks.c **** 					{
1229:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1621              		.loc 1 1229 0
 1622 00bc 4FF00103 		mov	r3, #1
 1623 00c0 3B60     		str	r3, [r7, #0]
 1624              	.L92:
1230:FreeRTOS/Source/tasks.c **** 					}
1231:FreeRTOS/Source/tasks.c **** 					#endif
1232:FreeRTOS/Source/tasks.c **** 				}
1233:FreeRTOS/Source/tasks.c **** 
1234:FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1625              		.loc 1 1234 0
 1626 00c2 3B68     		ldr	r3, [r7, #0]
 1627 00c4 012B     		cmp	r3, #1
 1628 00c6 03D0     		beq	.L95
 1629              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1630 00c8 114B     		ldr	r3, .L96+28
 1631 00ca 1B68     		ldr	r3, [r3, #0]
 1632 00cc 012B     		cmp	r3, #1
 1633 00ce 08D1     		bne	.L88
 1634              	.L95:
1235:FreeRTOS/Source/tasks.c **** 				{
1236:FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1635              		.loc 1 1236 0 is_stmt 1
 1636 00d0 4FF00103 		mov	r3, #1
 1637 00d4 7B60     		str	r3, [r7, #4]
1237:FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1638              		.loc 1 1237 0
 1639 00d6 0E4B     		ldr	r3, .L96+28
 1640 00d8 4FF00002 		mov	r2, #0
 1641 00dc 1A60     		str	r2, [r3, #0]
1238:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1642              		.loc 1 1238 0
 1643 00de FFF7FEFF 		bl	vPortYieldFromISR
 1644              	.L88:
 1645              	.LBE3:
1239:FreeRTOS/Source/tasks.c **** 				}
1240:FreeRTOS/Source/tasks.c **** 			}
1241:FreeRTOS/Source/tasks.c **** 		}
1242:FreeRTOS/Source/tasks.c **** 	}
1243:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1646              		.loc 1 1243 0
 1647 00e2 FFF7FEFF 		bl	vPortExitCritical
1244:FreeRTOS/Source/tasks.c **** 
1245:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
 1648              		.loc 1 1245 0
 1649 00e6 7B68     		ldr	r3, [r7, #4]
1246:FreeRTOS/Source/tasks.c **** }
 1650              		.loc 1 1246 0
 1651 00e8 1846     		mov	r0, r3
 1652 00ea 07F10C07 		add	r7, r7, #12
 1653 00ee BD46     		mov	sp, r7
 1654 00f0 90BD     		pop	{r4, r7, pc}
 1655              	.L97:
 1656 00f2 00BF     		.align	2
 1657              	.L96:
 1658 00f4 00000000 		.word	uxSchedulerSuspended
 1659 00f8 00000000 		.word	uxCurrentNumberOfTasks
 1660 00fc 00000000 		.word	xPendingReadyList
 1661 0100 00000000 		.word	uxTopReadyPriority
 1662 0104 00000000 		.word	pxReadyTasksLists
 1663 0108 00000000 		.word	pxCurrentTCB
 1664 010c 00000000 		.word	uxMissedTicks
 1665 0110 00000000 		.word	xMissedYield
 1666              		.cfi_endproc
 1667              	.LFE123:
 1669              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1670              		.align	2
 1671              		.global	xTaskGetTickCount
 1672              		.thumb
 1673              		.thumb_func
 1675              	xTaskGetTickCount:
 1676              	.LFB124:
1247:FreeRTOS/Source/tasks.c **** 
1248:FreeRTOS/Source/tasks.c **** 
1249:FreeRTOS/Source/tasks.c **** 
1250:FreeRTOS/Source/tasks.c **** 
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** 
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 
1258:FreeRTOS/Source/tasks.c **** 
1259:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:FreeRTOS/Source/tasks.c **** {
 1677              		.loc 1 1260 0
 1678              		.cfi_startproc
 1679              		@ args = 0, pretend = 0, frame = 8
 1680              		@ frame_needed = 1, uses_anonymous_args = 0
 1681 0000 80B5     		push	{r7, lr}
 1682              	.LCFI40:
 1683              		.cfi_def_cfa_offset 8
 1684 0002 82B0     		sub	sp, sp, #8
 1685              	.LCFI41:
 1686              		.cfi_def_cfa_offset 16
 1687 0004 00AF     		add	r7, sp, #0
 1688              		.cfi_offset 14, -4
 1689              		.cfi_offset 7, -8
 1690              	.LCFI42:
 1691              		.cfi_def_cfa_register 7
1261:FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:FreeRTOS/Source/tasks.c **** 
1263:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 1692              		.loc 1 1264 0
 1693 0006 FFF7FEFF 		bl	vPortEnterCritical
1265:FreeRTOS/Source/tasks.c **** 	{
1266:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
 1694              		.loc 1 1266 0
 1695 000a 054B     		ldr	r3, .L99
 1696 000c 1B68     		ldr	r3, [r3, #0]
 1697 000e 7B60     		str	r3, [r7, #4]
1267:FreeRTOS/Source/tasks.c **** 	}
1268:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 1698              		.loc 1 1268 0
 1699 0010 FFF7FEFF 		bl	vPortExitCritical
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 	return xTicks;
 1700              		.loc 1 1270 0
 1701 0014 7B68     		ldr	r3, [r7, #4]
1271:FreeRTOS/Source/tasks.c **** }
 1702              		.loc 1 1271 0
 1703 0016 1846     		mov	r0, r3
 1704 0018 07F10807 		add	r7, r7, #8
 1705 001c BD46     		mov	sp, r7
 1706 001e 80BD     		pop	{r7, pc}
 1707              	.L100:
 1708              		.align	2
 1709              	.L99:
 1710 0020 00000000 		.word	xTickCount
 1711              		.cfi_endproc
 1712              	.LFE124:
 1714              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1715              		.align	2
 1716              		.global	xTaskGetTickCountFromISR
 1717              		.thumb
 1718              		.thumb_func
 1720              	xTaskGetTickCountFromISR:
 1721              	.LFB125:
1272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:FreeRTOS/Source/tasks.c **** 
1274:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:FreeRTOS/Source/tasks.c **** {
 1722              		.loc 1 1275 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 8
 1725              		@ frame_needed = 1, uses_anonymous_args = 0
 1726              		@ link register save eliminated.
 1727 0000 80B4     		push	{r7}
 1728              	.LCFI43:
 1729              		.cfi_def_cfa_offset 4
 1730 0002 83B0     		sub	sp, sp, #12
 1731              	.LCFI44:
 1732              		.cfi_def_cfa_offset 16
 1733 0004 00AF     		add	r7, sp, #0
 1734              		.cfi_offset 7, -4
 1735              	.LCFI45:
 1736              		.cfi_def_cfa_register 7
1276:FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:FreeRTOS/Source/tasks.c **** 
1279:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1737              		.loc 1 1279 0
 1738 0006 4FF00003 		mov	r3, #0
 1739 000a 7B60     		str	r3, [r7, #4]
 1740              	@ 1279 "FreeRTOS/Source/tasks.c" 1
 1741 000c 4FF0BF00 			mov r0, #191								
 1742 0010 80F31188 		msr basepri, r0							
 1743              	
 1744              	@ 0 "" 2
1280:FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1745              		.loc 1 1280 0
 1746              		.thumb
 1747 0014 064B     		ldr	r3, .L102
 1748 0016 1B68     		ldr	r3, [r3, #0]
 1749 0018 3B60     		str	r3, [r7, #0]
1281:FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1750              		.loc 1 1281 0
 1751              	@ 1281 "FreeRTOS/Source/tasks.c" 1
 1752 001a 4FF00000 			mov r0, #0					
 1753 001e 80F31188 		msr basepri, r0				
 1754              	
 1755              	@ 0 "" 2
1282:FreeRTOS/Source/tasks.c **** 
1283:FreeRTOS/Source/tasks.c **** 	return xReturn;
 1756              		.loc 1 1283 0
 1757              		.thumb
 1758 0022 3B68     		ldr	r3, [r7, #0]
1284:FreeRTOS/Source/tasks.c **** }
 1759              		.loc 1 1284 0
 1760 0024 1846     		mov	r0, r3
 1761 0026 07F10C07 		add	r7, r7, #12
 1762 002a BD46     		mov	sp, r7
 1763 002c 80BC     		pop	{r7}
 1764 002e 7047     		bx	lr
 1765              	.L103:
 1766              		.align	2
 1767              	.L102:
 1768 0030 00000000 		.word	xTickCount
 1769              		.cfi_endproc
 1770              	.LFE125:
 1772              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1773              		.align	2
 1774              		.global	uxTaskGetNumberOfTasks
 1775              		.thumb
 1776              		.thumb_func
 1778              	uxTaskGetNumberOfTasks:
 1779              	.LFB126:
1285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:FreeRTOS/Source/tasks.c **** 
1287:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:FreeRTOS/Source/tasks.c **** {
 1780              		.loc 1 1288 0
 1781              		.cfi_startproc
 1782              		@ args = 0, pretend = 0, frame = 0
 1783              		@ frame_needed = 1, uses_anonymous_args = 0
 1784              		@ link register save eliminated.
 1785 0000 80B4     		push	{r7}
 1786              	.LCFI46:
 1787              		.cfi_def_cfa_offset 4
 1788 0002 00AF     		add	r7, sp, #0
 1789              		.cfi_offset 7, -4
 1790              	.LCFI47:
 1791              		.cfi_def_cfa_register 7
1289:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 1792              		.loc 1 1291 0
 1793 0004 024B     		ldr	r3, .L105
 1794 0006 1B68     		ldr	r3, [r3, #0]
1292:FreeRTOS/Source/tasks.c **** }
 1795              		.loc 1 1292 0
 1796 0008 1846     		mov	r0, r3
 1797 000a BD46     		mov	sp, r7
 1798 000c 80BC     		pop	{r7}
 1799 000e 7047     		bx	lr
 1800              	.L106:
 1801              		.align	2
 1802              	.L105:
 1803 0010 00000000 		.word	uxCurrentNumberOfTasks
 1804              		.cfi_endproc
 1805              	.LFE126:
 1807              		.section	.rodata
 1808 0005 000000   		.align	2
 1809              	.LC1:
 1810 0008 0D0A00   		.ascii	"\015\012\000"
 1811              		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 1812              		.align	2
 1813              		.global	vTaskGetRunTimeStats
 1814              		.thumb
 1815              		.thumb_func
 1817              	vTaskGetRunTimeStats:
 1818              	.LFB127:
1293:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:FreeRTOS/Source/tasks.c **** 
1295:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:FreeRTOS/Source/tasks.c **** 
1297:FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:FreeRTOS/Source/tasks.c **** 	{
1299:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:FreeRTOS/Source/tasks.c **** 
1301:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:FreeRTOS/Source/tasks.c **** 	}
1306:FreeRTOS/Source/tasks.c **** 
1307:FreeRTOS/Source/tasks.c **** #endif
1308:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:FreeRTOS/Source/tasks.c **** 
1310:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:FreeRTOS/Source/tasks.c **** 
1312:FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:FreeRTOS/Source/tasks.c **** 	{
1314:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:FreeRTOS/Source/tasks.c **** 
1316:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:FreeRTOS/Source/tasks.c **** 
1319:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:FreeRTOS/Source/tasks.c **** 		{
1321:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:FreeRTOS/Source/tasks.c **** 
1327:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:FreeRTOS/Source/tasks.c **** 
1329:FreeRTOS/Source/tasks.c **** 			do
1330:FreeRTOS/Source/tasks.c **** 			{
1331:FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:FreeRTOS/Source/tasks.c **** 				{
1335:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:FreeRTOS/Source/tasks.c **** 				}
1337:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:FreeRTOS/Source/tasks.c **** 			{
1341:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:FreeRTOS/Source/tasks.c **** 			}
1343:FreeRTOS/Source/tasks.c **** 
1344:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:FreeRTOS/Source/tasks.c **** 			{
1346:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:FreeRTOS/Source/tasks.c **** 			}
1348:FreeRTOS/Source/tasks.c **** 
1349:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:FreeRTOS/Source/tasks.c **** 				{
1353:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:FreeRTOS/Source/tasks.c **** 				}
1355:FreeRTOS/Source/tasks.c **** 			}
1356:FreeRTOS/Source/tasks.c **** 			#endif
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:FreeRTOS/Source/tasks.c **** 			{
1360:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:FreeRTOS/Source/tasks.c **** 				{
1362:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:FreeRTOS/Source/tasks.c **** 				}
1364:FreeRTOS/Source/tasks.c **** 			}
1365:FreeRTOS/Source/tasks.c **** 			#endif
1366:FreeRTOS/Source/tasks.c **** 		}
1367:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:FreeRTOS/Source/tasks.c **** 	}
1369:FreeRTOS/Source/tasks.c **** 
1370:FreeRTOS/Source/tasks.c **** #endif
1371:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:FreeRTOS/Source/tasks.c **** 
1375:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:FreeRTOS/Source/tasks.c **** 	{
 1819              		.loc 1 1376 0
 1820              		.cfi_startproc
 1821              		@ args = 0, pretend = 0, frame = 16
 1822              		@ frame_needed = 1, uses_anonymous_args = 0
 1823 0000 90B5     		push	{r4, r7, lr}
 1824              	.LCFI48:
 1825              		.cfi_def_cfa_offset 12
 1826 0002 85B0     		sub	sp, sp, #20
 1827              	.LCFI49:
 1828              		.cfi_def_cfa_offset 32
 1829 0004 00AF     		add	r7, sp, #0
 1830              		.cfi_offset 14, -4
 1831              		.cfi_offset 7, -8
 1832              		.cfi_offset 4, -12
 1833              	.LCFI50:
 1834              		.cfi_def_cfa_register 7
 1835 0006 7860     		str	r0, [r7, #4]
1377:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:FreeRTOS/Source/tasks.c **** 
1383:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 1836              		.loc 1 1383 0
 1837 0008 FFF7FEFF 		bl	vTaskSuspendAll
1384:FreeRTOS/Source/tasks.c **** 		{
1385:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:FreeRTOS/Source/tasks.c **** 			#else
1388:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 1838              		.loc 1 1388 0
 1839 000c FFF7FEFF 		bl	get_us_time
 1840 0010 0246     		mov	r2, r0
 1841 0012 0B46     		mov	r3, r1
 1842 0014 1346     		mov	r3, r2
 1843 0016 BB60     		str	r3, [r7, #8]
1389:FreeRTOS/Source/tasks.c **** 			#endif
1390:FreeRTOS/Source/tasks.c **** 
1391:FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
 1844              		.loc 1 1393 0
 1845 0018 BA68     		ldr	r2, [r7, #8]
 1846 001a 3C4B     		ldr	r3, .L114
 1847 001c A3FB0213 		umull	r1, r3, r3, r2
 1848 0020 4FEA5313 		lsr	r3, r3, #5
 1849 0024 BB60     		str	r3, [r7, #8]
1394:FreeRTOS/Source/tasks.c **** 			
1395:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:FreeRTOS/Source/tasks.c **** 			buffer. */
1398:FreeRTOS/Source/tasks.c **** 
1399:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 1850              		.loc 1 1399 0
 1851 0026 7B68     		ldr	r3, [r7, #4]
 1852 0028 4FF00002 		mov	r2, #0
 1853 002c 1A70     		strb	r2, [r3, #0]
1400:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 1854              		.loc 1 1400 0
 1855 002e 7C68     		ldr	r4, [r7, #4]
 1856 0030 2046     		mov	r0, r4
 1857 0032 FFF7FEFF 		bl	strlen
 1858 0036 0346     		mov	r3, r0
 1859 0038 E318     		adds	r3, r4, r3
 1860 003a 1846     		mov	r0, r3
 1861 003c 3449     		ldr	r1, .L114+4
 1862 003e 4FF00302 		mov	r2, #3
 1863 0042 FFF7FEFF 		bl	memcpy
1401:FreeRTOS/Source/tasks.c **** 
1402:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 1864              		.loc 1 1402 0
 1865 0046 334B     		ldr	r3, .L114+8
 1866 0048 1B68     		ldr	r3, [r3, #0]
 1867 004a 03F10103 		add	r3, r3, #1
 1868 004e FB60     		str	r3, [r7, #12]
 1869              	.L109:
1403:FreeRTOS/Source/tasks.c **** 
1404:FreeRTOS/Source/tasks.c **** 			do
1405:FreeRTOS/Source/tasks.c **** 			{
1406:FreeRTOS/Source/tasks.c **** 				uxQueue--;
 1870              		.loc 1 1406 0
 1871 0050 FB68     		ldr	r3, [r7, #12]
 1872 0052 03F1FF33 		add	r3, r3, #-1
 1873 0056 FB60     		str	r3, [r7, #12]
1407:FreeRTOS/Source/tasks.c **** 
1408:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 1874              		.loc 1 1408 0
 1875 0058 FA68     		ldr	r2, [r7, #12]
 1876 005a 1346     		mov	r3, r2
 1877 005c 4FEA8303 		lsl	r3, r3, #2
 1878 0060 9B18     		adds	r3, r3, r2
 1879 0062 4FEA8303 		lsl	r3, r3, #2
 1880 0066 1A46     		mov	r2, r3
 1881 0068 2B4B     		ldr	r3, .L114+12
 1882 006a D318     		adds	r3, r2, r3
 1883 006c 1B68     		ldr	r3, [r3, #0]
 1884 006e 002B     		cmp	r3, #0
 1885 0070 10D0     		beq	.L108
1409:FreeRTOS/Source/tasks.c **** 				{
1410:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 1886              		.loc 1 1410 0
 1887 0072 FA68     		ldr	r2, [r7, #12]
 1888 0074 1346     		mov	r3, r2
 1889 0076 4FEA8303 		lsl	r3, r3, #2
 1890 007a 9B18     		adds	r3, r3, r2
 1891 007c 4FEA8303 		lsl	r3, r3, #2
 1892 0080 1A46     		mov	r2, r3
 1893 0082 254B     		ldr	r3, .L114+12
 1894 0084 D318     		adds	r3, r2, r3
 1895 0086 7868     		ldr	r0, [r7, #4]
 1896 0088 1946     		mov	r1, r3
 1897 008a BA68     		ldr	r2, [r7, #8]
 1898 008c 4FF05203 		mov	r3, #82
 1899 0090 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1900              	.L108:
1411:FreeRTOS/Source/tasks.c **** 				}
1412:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 1901              		.loc 1 1412 0
 1902 0094 FB68     		ldr	r3, [r7, #12]
 1903 0096 002B     		cmp	r3, #0
 1904 0098 DAD1     		bne	.L109
1413:FreeRTOS/Source/tasks.c **** 
1414:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 1905              		.loc 1 1414 0
 1906 009a 204B     		ldr	r3, .L114+16
 1907 009c 1B68     		ldr	r3, [r3, #0]
 1908 009e 1B68     		ldr	r3, [r3, #0]
 1909 00a0 002B     		cmp	r3, #0
 1910 00a2 08D0     		beq	.L110
1415:FreeRTOS/Source/tasks.c **** 			{
1416:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 1911              		.loc 1 1416 0
 1912 00a4 1D4B     		ldr	r3, .L114+16
 1913 00a6 1B68     		ldr	r3, [r3, #0]
 1914 00a8 7868     		ldr	r0, [r7, #4]
 1915 00aa 1946     		mov	r1, r3
 1916 00ac BA68     		ldr	r2, [r7, #8]
 1917 00ae 4FF04203 		mov	r3, #66
 1918 00b2 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1919              	.L110:
1417:FreeRTOS/Source/tasks.c **** 			}
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 1920              		.loc 1 1419 0
 1921 00b6 1A4B     		ldr	r3, .L114+20
 1922 00b8 1B68     		ldr	r3, [r3, #0]
 1923 00ba 1B68     		ldr	r3, [r3, #0]
 1924 00bc 002B     		cmp	r3, #0
 1925 00be 08D0     		beq	.L111
1420:FreeRTOS/Source/tasks.c **** 			{
1421:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 1926              		.loc 1 1421 0
 1927 00c0 174B     		ldr	r3, .L114+20
 1928 00c2 1B68     		ldr	r3, [r3, #0]
 1929 00c4 7868     		ldr	r0, [r7, #4]
 1930 00c6 1946     		mov	r1, r3
 1931 00c8 BA68     		ldr	r2, [r7, #8]
 1932 00ca 4FF04203 		mov	r3, #66
 1933 00ce FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1934              	.L111:
1422:FreeRTOS/Source/tasks.c **** 			}
1423:FreeRTOS/Source/tasks.c **** 
1424:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:FreeRTOS/Source/tasks.c **** 			{
1426:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 1935              		.loc 1 1426 0
 1936 00d2 144B     		ldr	r3, .L114+24
 1937 00d4 1B68     		ldr	r3, [r3, #0]
 1938 00d6 002B     		cmp	r3, #0
 1939 00d8 06D0     		beq	.L112
1427:FreeRTOS/Source/tasks.c **** 				{
1428:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 1940              		.loc 1 1428 0
 1941 00da 7868     		ldr	r0, [r7, #4]
 1942 00dc 1149     		ldr	r1, .L114+24
 1943 00de BA68     		ldr	r2, [r7, #8]
 1944 00e0 4FF04403 		mov	r3, #68
 1945 00e4 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1946              	.L112:
1429:FreeRTOS/Source/tasks.c **** 				}
1430:FreeRTOS/Source/tasks.c **** 			}
1431:FreeRTOS/Source/tasks.c **** 			#endif
1432:FreeRTOS/Source/tasks.c **** 
1433:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:FreeRTOS/Source/tasks.c **** 			{
1435:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 1947              		.loc 1 1435 0
 1948 00e8 0F4B     		ldr	r3, .L114+28
 1949 00ea 1B68     		ldr	r3, [r3, #0]
 1950 00ec 002B     		cmp	r3, #0
 1951 00ee 06D0     		beq	.L113
1436:FreeRTOS/Source/tasks.c **** 				{
1437:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
 1952              		.loc 1 1437 0
 1953 00f0 7868     		ldr	r0, [r7, #4]
 1954 00f2 0D49     		ldr	r1, .L114+28
 1955 00f4 BA68     		ldr	r2, [r7, #8]
 1956 00f6 4FF05303 		mov	r3, #83
 1957 00fa FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 1958              	.L113:
1438:FreeRTOS/Source/tasks.c **** 				}
1439:FreeRTOS/Source/tasks.c **** 			}
1440:FreeRTOS/Source/tasks.c **** 			#endif
1441:FreeRTOS/Source/tasks.c **** 		}
1442:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
 1959              		.loc 1 1442 0
 1960 00fe FFF7FEFF 		bl	xTaskResumeAll
1443:FreeRTOS/Source/tasks.c **** 	}
 1961              		.loc 1 1443 0
 1962 0102 07F11407 		add	r7, r7, #20
 1963 0106 BD46     		mov	sp, r7
 1964 0108 90BD     		pop	{r4, r7, pc}
 1965              	.L115:
 1966 010a 00BF     		.align	2
 1967              	.L114:
 1968 010c 1F85EB51 		.word	1374389535
 1969 0110 08000000 		.word	.LC1
 1970 0114 00000000 		.word	uxTopUsedPriority
 1971 0118 00000000 		.word	pxReadyTasksLists
 1972 011c 00000000 		.word	pxDelayedTaskList
 1973 0120 00000000 		.word	pxOverflowDelayedTaskList
 1974 0124 00000000 		.word	xTasksWaitingTermination
 1975 0128 00000000 		.word	xSuspendedTaskList
 1976              		.cfi_endproc
 1977              	.LFE127:
 1979              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1980              		.align	2
 1981              		.global	xTaskGetIdleTaskHandle
 1982              		.thumb
 1983              		.thumb_func
 1985              	xTaskGetIdleTaskHandle:
 1986              	.LFB128:
1444:FreeRTOS/Source/tasks.c **** 
1445:FreeRTOS/Source/tasks.c **** #endif
1446:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:FreeRTOS/Source/tasks.c **** 
1448:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:FreeRTOS/Source/tasks.c **** 
1450:FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:FreeRTOS/Source/tasks.c **** 	{
1452:FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:FreeRTOS/Source/tasks.c **** 
1455:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:FreeRTOS/Source/tasks.c **** 		{
1457:FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:FreeRTOS/Source/tasks.c **** 		}
1462:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:FreeRTOS/Source/tasks.c **** 	}
1464:FreeRTOS/Source/tasks.c **** 
1465:FreeRTOS/Source/tasks.c **** #endif
1466:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:FreeRTOS/Source/tasks.c **** 
1468:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:FreeRTOS/Source/tasks.c **** 	{
1472:FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:FreeRTOS/Source/tasks.c **** 
1474:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:FreeRTOS/Source/tasks.c **** 
1480:FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:FreeRTOS/Source/tasks.c **** 	}
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** #endif
1484:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:FreeRTOS/Source/tasks.c **** 
1486:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:FreeRTOS/Source/tasks.c **** 
1488:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:FreeRTOS/Source/tasks.c **** 	{
 1987              		.loc 1 1489 0
 1988              		.cfi_startproc
 1989              		@ args = 0, pretend = 0, frame = 0
 1990              		@ frame_needed = 1, uses_anonymous_args = 0
 1991              		@ link register save eliminated.
 1992 0000 80B4     		push	{r7}
 1993              	.LCFI51:
 1994              		.cfi_def_cfa_offset 4
 1995 0002 00AF     		add	r7, sp, #0
 1996              		.cfi_offset 7, -4
 1997              	.LCFI52:
 1998              		.cfi_def_cfa_register 7
1490:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
 1999              		.loc 1 1493 0
 2000 0004 024B     		ldr	r3, .L117
 2001 0006 1B68     		ldr	r3, [r3, #0]
1494:FreeRTOS/Source/tasks.c **** 	}
 2002              		.loc 1 1494 0
 2003 0008 1846     		mov	r0, r3
 2004 000a BD46     		mov	sp, r7
 2005 000c 80BC     		pop	{r7}
 2006 000e 7047     		bx	lr
 2007              	.L118:
 2008              		.align	2
 2009              	.L117:
 2010 0010 00000000 		.word	xIdleTaskHandle
 2011              		.cfi_endproc
 2012              	.LFE128:
 2014              		.section	.text.vTaskIncrementTick,"ax",%progbits
 2015              		.align	2
 2016              		.global	vTaskIncrementTick
 2017              		.thumb
 2018              		.thumb_func
 2020              	vTaskIncrementTick:
 2021              	.LFB129:
1495:FreeRTOS/Source/tasks.c **** 	
1496:FreeRTOS/Source/tasks.c **** #endif
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:FreeRTOS/Source/tasks.c **** 
1503:FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:FreeRTOS/Source/tasks.c **** {
 2022              		.loc 1 1504 0
 2023              		.cfi_startproc
 2024              		@ args = 0, pretend = 0, frame = 16
 2025              		@ frame_needed = 1, uses_anonymous_args = 0
 2026 0000 80B5     		push	{r7, lr}
 2027              	.LCFI53:
 2028              		.cfi_def_cfa_offset 8
 2029 0002 84B0     		sub	sp, sp, #16
 2030              	.LCFI54:
 2031              		.cfi_def_cfa_offset 24
 2032 0004 00AF     		add	r7, sp, #0
 2033              		.cfi_offset 14, -4
 2034              		.cfi_offset 7, -8
 2035              	.LCFI55:
 2036              		.cfi_def_cfa_register 7
1505:FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:FreeRTOS/Source/tasks.c **** 
1507:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2037              		.loc 1 1510 0
 2038 0006 444B     		ldr	r3, .L130
 2039 0008 1B68     		ldr	r3, [r3, #0]
 2040 000a 002B     		cmp	r3, #0
 2041 000c 7AD1     		bne	.L120
1511:FreeRTOS/Source/tasks.c **** 	{
1512:FreeRTOS/Source/tasks.c **** 		++xTickCount;
 2042              		.loc 1 1512 0
 2043 000e 434B     		ldr	r3, .L130+4
 2044 0010 1B68     		ldr	r3, [r3, #0]
 2045 0012 03F10102 		add	r2, r3, #1
 2046 0016 414B     		ldr	r3, .L130+4
 2047 0018 1A60     		str	r2, [r3, #0]
1513:FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 2048              		.loc 1 1513 0
 2049 001a 404B     		ldr	r3, .L130+4
 2050 001c 1B68     		ldr	r3, [r3, #0]
 2051 001e 002B     		cmp	r3, #0
 2052 0020 22D1     		bne	.L121
 2053              	.LBB4:
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:FreeRTOS/Source/tasks.c **** 
1517:FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:FreeRTOS/Source/tasks.c **** 			an error! */
1520:FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:FreeRTOS/Source/tasks.c **** 			
1522:FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2054              		.loc 1 1522 0
 2055 0022 3F4B     		ldr	r3, .L130+8
 2056 0024 1B68     		ldr	r3, [r3, #0]
 2057 0026 FB60     		str	r3, [r7, #12]
1523:FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2058              		.loc 1 1523 0
 2059 0028 3E4B     		ldr	r3, .L130+12
 2060 002a 1A68     		ldr	r2, [r3, #0]
 2061 002c 3C4B     		ldr	r3, .L130+8
 2062 002e 1A60     		str	r2, [r3, #0]
1524:FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2063              		.loc 1 1524 0
 2064 0030 3C4B     		ldr	r3, .L130+12
 2065 0032 FA68     		ldr	r2, [r7, #12]
 2066 0034 1A60     		str	r2, [r3, #0]
1525:FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 2067              		.loc 1 1525 0
 2068 0036 3C4B     		ldr	r3, .L130+16
 2069 0038 1B68     		ldr	r3, [r3, #0]
 2070 003a 03F10102 		add	r2, r3, #1
 2071 003e 3A4B     		ldr	r3, .L130+16
 2072 0040 1A60     		str	r2, [r3, #0]
1526:FreeRTOS/Source/tasks.c **** 	
1527:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2073              		.loc 1 1527 0
 2074 0042 374B     		ldr	r3, .L130+8
 2075 0044 1B68     		ldr	r3, [r3, #0]
 2076 0046 1B68     		ldr	r3, [r3, #0]
 2077 0048 002B     		cmp	r3, #0
 2078 004a 04D1     		bne	.L122
1528:FreeRTOS/Source/tasks.c **** 			{
1529:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 2079              		.loc 1 1534 0
 2080 004c 374B     		ldr	r3, .L130+20
 2081 004e 4FF0FF32 		mov	r2, #-1
 2082 0052 1A60     		str	r2, [r3, #0]
 2083 0054 08E0     		b	.L121
 2084              	.L122:
1535:FreeRTOS/Source/tasks.c **** 			}
1536:FreeRTOS/Source/tasks.c **** 			else
1537:FreeRTOS/Source/tasks.c **** 			{
1538:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2085              		.loc 1 1542 0
 2086 0056 324B     		ldr	r3, .L130+8
 2087 0058 1B68     		ldr	r3, [r3, #0]
 2088 005a DB68     		ldr	r3, [r3, #12]
 2089 005c DB68     		ldr	r3, [r3, #12]
 2090 005e BB60     		str	r3, [r7, #8]
1543:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 2091              		.loc 1 1543 0
 2092 0060 BB68     		ldr	r3, [r7, #8]
 2093 0062 5A68     		ldr	r2, [r3, #4]
 2094 0064 314B     		ldr	r3, .L130+20
 2095 0066 1A60     		str	r2, [r3, #0]
 2096              	.L121:
 2097              	.LBE4:
 2098              	.LBB5:
1544:FreeRTOS/Source/tasks.c **** 			}
1545:FreeRTOS/Source/tasks.c **** 		}
1546:FreeRTOS/Source/tasks.c **** 
1547:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
 2099              		.loc 1 1548 0
 2100 0068 2C4B     		ldr	r3, .L130+4
 2101 006a 1A68     		ldr	r2, [r3, #0]
 2102 006c 2F4B     		ldr	r3, .L130+20
 2103 006e 1B68     		ldr	r3, [r3, #0]
 2104 0070 9A42     		cmp	r2, r3
 2105 0072 4DD3     		bcc	.L119
 2106              	.L128:
 2107              		.loc 1 1548 0 is_stmt 0 discriminator 1
 2108 0074 2A4B     		ldr	r3, .L130+8
 2109 0076 1B68     		ldr	r3, [r3, #0]
 2110 0078 1B68     		ldr	r3, [r3, #0]
 2111 007a 002B     		cmp	r3, #0
 2112 007c 04D1     		bne	.L124
 2113              		.loc 1 1548 0 discriminator 2
 2114 007e 2B4B     		ldr	r3, .L130+20
 2115 0080 4FF0FF32 		mov	r2, #-1
 2116 0084 1A60     		str	r2, [r3, #0]
 2117 0086 43E0     		b	.L119
 2118              	.L124:
 2119              		.loc 1 1548 0 discriminator 3
 2120 0088 254B     		ldr	r3, .L130+8
 2121 008a 1B68     		ldr	r3, [r3, #0]
 2122 008c DB68     		ldr	r3, [r3, #12]
 2123 008e DB68     		ldr	r3, [r3, #12]
 2124 0090 BB60     		str	r3, [r7, #8]
 2125 0092 BB68     		ldr	r3, [r7, #8]
 2126 0094 5B68     		ldr	r3, [r3, #4]
 2127 0096 7B60     		str	r3, [r7, #4]
 2128 0098 204B     		ldr	r3, .L130+4
 2129 009a 1A68     		ldr	r2, [r3, #0]
 2130 009c 7B68     		ldr	r3, [r7, #4]
 2131 009e 9A42     		cmp	r2, r3
 2132 00a0 03D2     		bcs	.L125
 2133              		.loc 1 1548 0 discriminator 4
 2134 00a2 224B     		ldr	r3, .L130+20
 2135 00a4 7A68     		ldr	r2, [r7, #4]
 2136 00a6 1A60     		str	r2, [r3, #0]
 2137 00a8 32E0     		b	.L119
 2138              	.L125:
 2139              		.loc 1 1548 0 discriminator 5
 2140 00aa BB68     		ldr	r3, [r7, #8]
 2141 00ac 03F10403 		add	r3, r3, #4
 2142 00b0 1846     		mov	r0, r3
 2143 00b2 FFF7FEFF 		bl	vListRemove
 2144 00b6 BB68     		ldr	r3, [r7, #8]
 2145 00b8 9B6A     		ldr	r3, [r3, #40]
 2146 00ba 002B     		cmp	r3, #0
 2147 00bc 05D0     		beq	.L126
 2148              		.loc 1 1548 0 discriminator 6
 2149 00be BB68     		ldr	r3, [r7, #8]
 2150 00c0 03F11803 		add	r3, r3, #24
 2151 00c4 1846     		mov	r0, r3
 2152 00c6 FFF7FEFF 		bl	vListRemove
 2153              	.L126:
 2154              		.loc 1 1548 0 discriminator 7
 2155 00ca BB68     		ldr	r3, [r7, #8]
 2156 00cc DA6A     		ldr	r2, [r3, #44]
 2157 00ce 184B     		ldr	r3, .L130+24
 2158 00d0 1B68     		ldr	r3, [r3, #0]
 2159 00d2 9A42     		cmp	r2, r3
 2160 00d4 03D9     		bls	.L127
 2161              		.loc 1 1548 0 discriminator 8
 2162 00d6 BB68     		ldr	r3, [r7, #8]
 2163 00d8 DA6A     		ldr	r2, [r3, #44]
 2164 00da 154B     		ldr	r3, .L130+24
 2165 00dc 1A60     		str	r2, [r3, #0]
 2166              	.L127:
 2167              		.loc 1 1548 0 discriminator 9
 2168 00de BB68     		ldr	r3, [r7, #8]
 2169 00e0 DA6A     		ldr	r2, [r3, #44]
 2170 00e2 1346     		mov	r3, r2
 2171 00e4 4FEA8303 		lsl	r3, r3, #2
 2172 00e8 9B18     		adds	r3, r3, r2
 2173 00ea 4FEA8303 		lsl	r3, r3, #2
 2174 00ee 1A46     		mov	r2, r3
 2175 00f0 104B     		ldr	r3, .L130+28
 2176 00f2 D218     		adds	r2, r2, r3
 2177 00f4 BB68     		ldr	r3, [r7, #8]
 2178 00f6 03F10403 		add	r3, r3, #4
 2179 00fa 1046     		mov	r0, r2
 2180 00fc 1946     		mov	r1, r3
 2181 00fe FFF7FEFF 		bl	vListInsertEnd
 2182 0102 B7E7     		b	.L128
 2183              	.L120:
 2184              	.LBE5:
1549:FreeRTOS/Source/tasks.c **** 	}
1550:FreeRTOS/Source/tasks.c **** 	else
1551:FreeRTOS/Source/tasks.c **** 	{
1552:FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
 2185              		.loc 1 1552 0 is_stmt 1
 2186 0104 0C4B     		ldr	r3, .L130+32
 2187 0106 1B68     		ldr	r3, [r3, #0]
 2188 0108 03F10102 		add	r2, r3, #1
 2189 010c 0A4B     		ldr	r3, .L130+32
 2190 010e 1A60     		str	r2, [r3, #0]
 2191              	.L119:
1553:FreeRTOS/Source/tasks.c **** 
1554:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:FreeRTOS/Source/tasks.c **** 		{
1558:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:FreeRTOS/Source/tasks.c **** 		}
1560:FreeRTOS/Source/tasks.c **** 		#endif
1561:FreeRTOS/Source/tasks.c **** 	}
1562:FreeRTOS/Source/tasks.c **** 
1563:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:FreeRTOS/Source/tasks.c **** 	{
1565:FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:FreeRTOS/Source/tasks.c **** 		{
1569:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:FreeRTOS/Source/tasks.c **** 		}
1571:FreeRTOS/Source/tasks.c **** 	}
1572:FreeRTOS/Source/tasks.c **** 	#endif
1573:FreeRTOS/Source/tasks.c **** 
1574:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:FreeRTOS/Source/tasks.c **** }
 2192              		.loc 1 1575 0
 2193 0110 07F11007 		add	r7, r7, #16
 2194 0114 BD46     		mov	sp, r7
 2195 0116 80BD     		pop	{r7, pc}
 2196              	.L131:
 2197              		.align	2
 2198              	.L130:
 2199 0118 00000000 		.word	uxSchedulerSuspended
 2200 011c 00000000 		.word	xTickCount
 2201 0120 00000000 		.word	pxDelayedTaskList
 2202 0124 00000000 		.word	pxOverflowDelayedTaskList
 2203 0128 00000000 		.word	xNumOfOverflows
 2204 012c 00000000 		.word	xNextTaskUnblockTime
 2205 0130 00000000 		.word	uxTopReadyPriority
 2206 0134 00000000 		.word	pxReadyTasksLists
 2207 0138 00000000 		.word	uxMissedTicks
 2208              		.cfi_endproc
 2209              	.LFE129:
 2211              		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 2212              		.align	2
 2213              		.global	vTaskSetApplicationTaskTag
 2214              		.thumb
 2215              		.thumb_func
 2217              	vTaskSetApplicationTaskTag:
 2218              	.LFB130:
1576:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:FreeRTOS/Source/tasks.c **** 
1578:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:FreeRTOS/Source/tasks.c **** 
1580:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:FreeRTOS/Source/tasks.c **** 	{
 2219              		.loc 1 1581 0
 2220              		.cfi_startproc
 2221              		@ args = 0, pretend = 0, frame = 16
 2222              		@ frame_needed = 1, uses_anonymous_args = 0
 2223 0000 80B5     		push	{r7, lr}
 2224              	.LCFI56:
 2225              		.cfi_def_cfa_offset 8
 2226 0002 84B0     		sub	sp, sp, #16
 2227              	.LCFI57:
 2228              		.cfi_def_cfa_offset 24
 2229 0004 00AF     		add	r7, sp, #0
 2230              		.cfi_offset 14, -4
 2231              		.cfi_offset 7, -8
 2232              	.LCFI58:
 2233              		.cfi_def_cfa_register 7
 2234 0006 7860     		str	r0, [r7, #4]
 2235 0008 3960     		str	r1, [r7, #0]
1582:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:FreeRTOS/Source/tasks.c **** 
1584:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2236              		.loc 1 1585 0
 2237 000a 7B68     		ldr	r3, [r7, #4]
 2238 000c 002B     		cmp	r3, #0
 2239 000e 03D1     		bne	.L133
1586:FreeRTOS/Source/tasks.c **** 		{
1587:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2240              		.loc 1 1587 0
 2241 0010 084B     		ldr	r3, .L135
 2242 0012 1B68     		ldr	r3, [r3, #0]
 2243 0014 FB60     		str	r3, [r7, #12]
 2244 0016 01E0     		b	.L134
 2245              	.L133:
1588:FreeRTOS/Source/tasks.c **** 		}
1589:FreeRTOS/Source/tasks.c **** 		else
1590:FreeRTOS/Source/tasks.c **** 		{
1591:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2246              		.loc 1 1591 0
 2247 0018 7B68     		ldr	r3, [r7, #4]
 2248 001a FB60     		str	r3, [r7, #12]
 2249              	.L134:
1592:FreeRTOS/Source/tasks.c **** 		}
1593:FreeRTOS/Source/tasks.c **** 
1594:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2250              		.loc 1 1596 0
 2251 001c FFF7FEFF 		bl	vPortEnterCritical
1597:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2252              		.loc 1 1597 0
 2253 0020 FB68     		ldr	r3, [r7, #12]
 2254 0022 3A68     		ldr	r2, [r7, #0]
 2255 0024 9A64     		str	r2, [r3, #72]
1598:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2256              		.loc 1 1598 0
 2257 0026 FFF7FEFF 		bl	vPortExitCritical
1599:FreeRTOS/Source/tasks.c **** 	}
 2258              		.loc 1 1599 0
 2259 002a 07F11007 		add	r7, r7, #16
 2260 002e BD46     		mov	sp, r7
 2261 0030 80BD     		pop	{r7, pc}
 2262              	.L136:
 2263 0032 00BF     		.align	2
 2264              	.L135:
 2265 0034 00000000 		.word	pxCurrentTCB
 2266              		.cfi_endproc
 2267              	.LFE130:
 2269              		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2270              		.align	2
 2271              		.global	xTaskGetApplicationTaskTag
 2272              		.thumb
 2273              		.thumb_func
 2275              	xTaskGetApplicationTaskTag:
 2276              	.LFB131:
1600:FreeRTOS/Source/tasks.c **** 
1601:FreeRTOS/Source/tasks.c **** #endif
1602:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:FreeRTOS/Source/tasks.c **** 
1604:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:FreeRTOS/Source/tasks.c **** 
1606:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:FreeRTOS/Source/tasks.c **** 	{
 2277              		.loc 1 1607 0
 2278              		.cfi_startproc
 2279              		@ args = 0, pretend = 0, frame = 16
 2280              		@ frame_needed = 1, uses_anonymous_args = 0
 2281 0000 80B5     		push	{r7, lr}
 2282              	.LCFI59:
 2283              		.cfi_def_cfa_offset 8
 2284 0002 84B0     		sub	sp, sp, #16
 2285              	.LCFI60:
 2286              		.cfi_def_cfa_offset 24
 2287 0004 00AF     		add	r7, sp, #0
 2288              		.cfi_offset 14, -4
 2289              		.cfi_offset 7, -8
 2290              	.LCFI61:
 2291              		.cfi_def_cfa_register 7
 2292 0006 7860     		str	r0, [r7, #4]
1608:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:FreeRTOS/Source/tasks.c **** 
1611:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2293              		.loc 1 1612 0
 2294 0008 7B68     		ldr	r3, [r7, #4]
 2295 000a 002B     		cmp	r3, #0
 2296 000c 03D1     		bne	.L138
1613:FreeRTOS/Source/tasks.c **** 		{
1614:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2297              		.loc 1 1614 0
 2298 000e 094B     		ldr	r3, .L140
 2299 0010 1B68     		ldr	r3, [r3, #0]
 2300 0012 FB60     		str	r3, [r7, #12]
 2301 0014 01E0     		b	.L139
 2302              	.L138:
1615:FreeRTOS/Source/tasks.c **** 		}
1616:FreeRTOS/Source/tasks.c **** 		else
1617:FreeRTOS/Source/tasks.c **** 		{
1618:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2303              		.loc 1 1618 0
 2304 0016 7B68     		ldr	r3, [r7, #4]
 2305 0018 FB60     		str	r3, [r7, #12]
 2306              	.L139:
1619:FreeRTOS/Source/tasks.c **** 		}
1620:FreeRTOS/Source/tasks.c **** 
1621:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 2307              		.loc 1 1623 0
 2308 001a FFF7FEFF 		bl	vPortEnterCritical
1624:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2309              		.loc 1 1624 0
 2310 001e FB68     		ldr	r3, [r7, #12]
 2311 0020 9B6C     		ldr	r3, [r3, #72]
 2312 0022 BB60     		str	r3, [r7, #8]
1625:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2313              		.loc 1 1625 0
 2314 0024 FFF7FEFF 		bl	vPortExitCritical
1626:FreeRTOS/Source/tasks.c **** 
1627:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2315              		.loc 1 1627 0
 2316 0028 BB68     		ldr	r3, [r7, #8]
1628:FreeRTOS/Source/tasks.c **** 	}
 2317              		.loc 1 1628 0
 2318 002a 1846     		mov	r0, r3
 2319 002c 07F11007 		add	r7, r7, #16
 2320 0030 BD46     		mov	sp, r7
 2321 0032 80BD     		pop	{r7, pc}
 2322              	.L141:
 2323              		.align	2
 2324              	.L140:
 2325 0034 00000000 		.word	pxCurrentTCB
 2326              		.cfi_endproc
 2327              	.LFE131:
 2329              		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2330              		.align	2
 2331              		.global	xTaskCallApplicationTaskHook
 2332              		.thumb
 2333              		.thumb_func
 2335              	xTaskCallApplicationTaskHook:
 2336              	.LFB132:
1629:FreeRTOS/Source/tasks.c **** 
1630:FreeRTOS/Source/tasks.c **** #endif
1631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:FreeRTOS/Source/tasks.c **** 
1633:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:FreeRTOS/Source/tasks.c **** 	{
 2337              		.loc 1 1636 0
 2338              		.cfi_startproc
 2339              		@ args = 0, pretend = 0, frame = 16
 2340              		@ frame_needed = 1, uses_anonymous_args = 0
 2341 0000 80B5     		push	{r7, lr}
 2342              	.LCFI62:
 2343              		.cfi_def_cfa_offset 8
 2344 0002 84B0     		sub	sp, sp, #16
 2345              	.LCFI63:
 2346              		.cfi_def_cfa_offset 24
 2347 0004 00AF     		add	r7, sp, #0
 2348              		.cfi_offset 14, -4
 2349              		.cfi_offset 7, -8
 2350              	.LCFI64:
 2351              		.cfi_def_cfa_register 7
 2352 0006 7860     		str	r0, [r7, #4]
 2353 0008 3960     		str	r1, [r7, #0]
1637:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
 2354              		.loc 1 1641 0
 2355 000a 7B68     		ldr	r3, [r7, #4]
 2356 000c 002B     		cmp	r3, #0
 2357 000e 03D1     		bne	.L143
1642:FreeRTOS/Source/tasks.c **** 		{
1643:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
 2358              		.loc 1 1643 0
 2359 0010 0C4B     		ldr	r3, .L147
 2360 0012 1B68     		ldr	r3, [r3, #0]
 2361 0014 FB60     		str	r3, [r7, #12]
 2362 0016 01E0     		b	.L144
 2363              	.L143:
1644:FreeRTOS/Source/tasks.c **** 		}
1645:FreeRTOS/Source/tasks.c **** 		else
1646:FreeRTOS/Source/tasks.c **** 		{
1647:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
 2364              		.loc 1 1647 0
 2365 0018 7B68     		ldr	r3, [r7, #4]
 2366 001a FB60     		str	r3, [r7, #12]
 2367              	.L144:
1648:FreeRTOS/Source/tasks.c **** 		}
1649:FreeRTOS/Source/tasks.c **** 
1650:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
 2368              		.loc 1 1650 0
 2369 001c FB68     		ldr	r3, [r7, #12]
 2370 001e 9B6C     		ldr	r3, [r3, #72]
 2371 0020 002B     		cmp	r3, #0
 2372 0022 05D0     		beq	.L145
1651:FreeRTOS/Source/tasks.c **** 		{
1652:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
 2373              		.loc 1 1652 0
 2374 0024 FB68     		ldr	r3, [r7, #12]
 2375 0026 9B6C     		ldr	r3, [r3, #72]
 2376 0028 3868     		ldr	r0, [r7, #0]
 2377 002a 9847     		blx	r3
 2378 002c B860     		str	r0, [r7, #8]
 2379 002e 02E0     		b	.L146
 2380              	.L145:
1653:FreeRTOS/Source/tasks.c **** 		}
1654:FreeRTOS/Source/tasks.c **** 		else
1655:FreeRTOS/Source/tasks.c **** 		{
1656:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
 2381              		.loc 1 1656 0
 2382 0030 4FF00003 		mov	r3, #0
 2383 0034 BB60     		str	r3, [r7, #8]
 2384              	.L146:
1657:FreeRTOS/Source/tasks.c **** 		}
1658:FreeRTOS/Source/tasks.c **** 
1659:FreeRTOS/Source/tasks.c **** 		return xReturn;
 2385              		.loc 1 1659 0
 2386 0036 BB68     		ldr	r3, [r7, #8]
1660:FreeRTOS/Source/tasks.c **** 	}
 2387              		.loc 1 1660 0
 2388 0038 1846     		mov	r0, r3
 2389 003a 07F11007 		add	r7, r7, #16
 2390 003e BD46     		mov	sp, r7
 2391 0040 80BD     		pop	{r7, pc}
 2392              	.L148:
 2393 0042 00BF     		.align	2
 2394              	.L147:
 2395 0044 00000000 		.word	pxCurrentTCB
 2396              		.cfi_endproc
 2397              	.LFE132:
 2399              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2400              		.align	2
 2401              		.global	vTaskSwitchContext
 2402              		.thumb
 2403              		.thumb_func
 2405              	vTaskSwitchContext:
 2406              	.LFB133:
1661:FreeRTOS/Source/tasks.c **** 
1662:FreeRTOS/Source/tasks.c **** #endif
1663:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:FreeRTOS/Source/tasks.c **** {
 2407              		.loc 1 1666 0
 2408              		.cfi_startproc
 2409              		@ args = 0, pretend = 0, frame = 8
 2410              		@ frame_needed = 1, uses_anonymous_args = 0
 2411 0000 80B5     		push	{r7, lr}
 2412              	.LCFI65:
 2413              		.cfi_def_cfa_offset 8
 2414 0002 82B0     		sub	sp, sp, #8
 2415              	.LCFI66:
 2416              		.cfi_def_cfa_offset 16
 2417 0004 00AF     		add	r7, sp, #0
 2418              		.cfi_offset 14, -4
 2419              		.cfi_offset 7, -8
 2420              	.LCFI67:
 2421              		.cfi_def_cfa_register 7
1667:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2422              		.loc 1 1667 0
 2423 0006 2E4B     		ldr	r3, .L155
 2424 0008 1B68     		ldr	r3, [r3, #0]
 2425 000a 002B     		cmp	r3, #0
 2426 000c 04D0     		beq	.L150
1668:FreeRTOS/Source/tasks.c **** 	{
1669:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:FreeRTOS/Source/tasks.c **** 		switch. */
1671:FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
 2427              		.loc 1 1671 0
 2428 000e 2D4B     		ldr	r3, .L155+4
 2429 0010 4FF00102 		mov	r2, #1
 2430 0014 1A60     		str	r2, [r3, #0]
 2431 0016 4EE0     		b	.L149
 2432              	.L150:
 2433              	.LBB6:
1672:FreeRTOS/Source/tasks.c **** 	}
1673:FreeRTOS/Source/tasks.c **** 	else
1674:FreeRTOS/Source/tasks.c **** 	{
1675:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:FreeRTOS/Source/tasks.c **** 	
1677:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:FreeRTOS/Source/tasks.c **** 		{
1679:FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:FreeRTOS/Source/tasks.c **** 			
1681:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:FreeRTOS/Source/tasks.c **** 				#else
1684:FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 2434              		.loc 1 1684 0
 2435 0018 FFF7FEFF 		bl	get_us_time
 2436 001c 0246     		mov	r2, r0
 2437 001e 0B46     		mov	r3, r1
 2438 0020 1346     		mov	r3, r2
 2439 0022 7B60     		str	r3, [r7, #4]
1685:FreeRTOS/Source/tasks.c **** 				#endif
1686:FreeRTOS/Source/tasks.c **** 	
1687:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 2440              		.loc 1 1692 0
 2441 0024 284B     		ldr	r3, .L155+8
 2442 0026 1B68     		ldr	r3, [r3, #0]
 2443 0028 D96C     		ldr	r1, [r3, #76]
 2444 002a 284A     		ldr	r2, .L155+12
 2445 002c 1268     		ldr	r2, [r2, #0]
 2446 002e 7868     		ldr	r0, [r7, #4]
 2447 0030 821A     		subs	r2, r0, r2
 2448 0032 8A18     		adds	r2, r1, r2
 2449 0034 DA64     		str	r2, [r3, #76]
1693:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2450              		.loc 1 1693 0
 2451 0036 254B     		ldr	r3, .L155+12
 2452 0038 7A68     		ldr	r2, [r7, #4]
 2453 003a 1A60     		str	r2, [r3, #0]
 2454              	.LBE6:
1694:FreeRTOS/Source/tasks.c **** 		}
1695:FreeRTOS/Source/tasks.c **** 		#endif
1696:FreeRTOS/Source/tasks.c **** 	
1697:FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1698:FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:FreeRTOS/Source/tasks.c **** 	
1700:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2455              		.loc 1 1701 0
 2456 003c 05E0     		b	.L152
 2457              	.L153:
1702:FreeRTOS/Source/tasks.c **** 		{
1703:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
 2458              		.loc 1 1704 0
 2459 003e 244B     		ldr	r3, .L155+16
 2460 0040 1B68     		ldr	r3, [r3, #0]
 2461 0042 03F1FF32 		add	r2, r3, #-1
 2462 0046 224B     		ldr	r3, .L155+16
 2463 0048 1A60     		str	r2, [r3, #0]
 2464              	.L152:
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 2465              		.loc 1 1701 0 discriminator 1
 2466 004a 214B     		ldr	r3, .L155+16
 2467 004c 1A68     		ldr	r2, [r3, #0]
 2468 004e 1346     		mov	r3, r2
 2469 0050 4FEA8303 		lsl	r3, r3, #2
 2470 0054 9B18     		adds	r3, r3, r2
 2471 0056 4FEA8303 		lsl	r3, r3, #2
 2472 005a 1A46     		mov	r2, r3
 2473 005c 1D4B     		ldr	r3, .L155+20
 2474 005e D318     		adds	r3, r2, r3
 2475 0060 1B68     		ldr	r3, [r3, #0]
 2476 0062 002B     		cmp	r3, #0
 2477 0064 EBD0     		beq	.L153
 2478              	.LBB7:
1705:FreeRTOS/Source/tasks.c **** 		}
1706:FreeRTOS/Source/tasks.c **** 	
1707:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2479              		.loc 1 1709 0
 2480 0066 1A4B     		ldr	r3, .L155+16
 2481 0068 1A68     		ldr	r2, [r3, #0]
 2482 006a 1346     		mov	r3, r2
 2483 006c 4FEA8303 		lsl	r3, r3, #2
 2484 0070 9B18     		adds	r3, r3, r2
 2485 0072 4FEA8303 		lsl	r3, r3, #2
 2486 0076 1A46     		mov	r2, r3
 2487 0078 164B     		ldr	r3, .L155+20
 2488 007a D318     		adds	r3, r2, r3
 2489 007c 3B60     		str	r3, [r7, #0]
 2490 007e 3B68     		ldr	r3, [r7, #0]
 2491 0080 5B68     		ldr	r3, [r3, #4]
 2492 0082 5A68     		ldr	r2, [r3, #4]
 2493 0084 3B68     		ldr	r3, [r7, #0]
 2494 0086 5A60     		str	r2, [r3, #4]
 2495 0088 3B68     		ldr	r3, [r7, #0]
 2496 008a 5A68     		ldr	r2, [r3, #4]
 2497 008c 3B68     		ldr	r3, [r7, #0]
 2498 008e 03F10803 		add	r3, r3, #8
 2499 0092 9A42     		cmp	r2, r3
 2500 0094 04D1     		bne	.L154
 2501              		.loc 1 1709 0 is_stmt 0 discriminator 1
 2502 0096 3B68     		ldr	r3, [r7, #0]
 2503 0098 5B68     		ldr	r3, [r3, #4]
 2504 009a 5A68     		ldr	r2, [r3, #4]
 2505 009c 3B68     		ldr	r3, [r7, #0]
 2506 009e 5A60     		str	r2, [r3, #4]
 2507              	.L154:
 2508              		.loc 1 1709 0 discriminator 2
 2509 00a0 3B68     		ldr	r3, [r7, #0]
 2510 00a2 5B68     		ldr	r3, [r3, #4]
 2511 00a4 DB68     		ldr	r3, [r3, #12]
 2512 00a6 1A46     		mov	r2, r3
 2513 00a8 074B     		ldr	r3, .L155+8
 2514 00aa 1A60     		str	r2, [r3, #0]
 2515              	.LBE7:
1710:FreeRTOS/Source/tasks.c **** 	
1711:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
 2516              		.loc 1 1711 0 is_stmt 1 discriminator 2
 2517 00ac 0A4B     		ldr	r3, .L155+24
 2518 00ae 064A     		ldr	r2, .L155+8
 2519 00b0 1268     		ldr	r2, [r2, #0]
 2520 00b2 926C     		ldr	r2, [r2, #72]
 2521 00b4 DA60     		str	r2, [r3, #12]
 2522              	.L149:
1712:FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:FreeRTOS/Source/tasks.c **** 	}
1714:FreeRTOS/Source/tasks.c **** }
 2523              		.loc 1 1714 0
 2524 00b6 07F10807 		add	r7, r7, #8
 2525 00ba BD46     		mov	sp, r7
 2526 00bc 80BD     		pop	{r7, pc}
 2527              	.L156:
 2528 00be 00BF     		.align	2
 2529              	.L155:
 2530 00c0 00000000 		.word	uxSchedulerSuspended
 2531 00c4 00000000 		.word	xMissedYield
 2532 00c8 00000000 		.word	pxCurrentTCB
 2533 00cc 00000000 		.word	ulTaskSwitchedInTime
 2534 00d0 00000000 		.word	uxTopReadyPriority
 2535 00d4 00000000 		.word	pxReadyTasksLists
 2536 00d8 00740040 		.word	1073771520
 2537              		.cfi_endproc
 2538              	.LFE133:
 2540              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2541              		.align	2
 2542              		.global	vTaskPlaceOnEventList
 2543              		.thumb
 2544              		.thumb_func
 2546              	vTaskPlaceOnEventList:
 2547              	.LFB134:
1715:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:FreeRTOS/Source/tasks.c **** 
1717:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:FreeRTOS/Source/tasks.c **** {
 2548              		.loc 1 1718 0
 2549              		.cfi_startproc
 2550              		@ args = 0, pretend = 0, frame = 16
 2551              		@ frame_needed = 1, uses_anonymous_args = 0
 2552 0000 80B5     		push	{r7, lr}
 2553              	.LCFI68:
 2554              		.cfi_def_cfa_offset 8
 2555 0002 84B0     		sub	sp, sp, #16
 2556              	.LCFI69:
 2557              		.cfi_def_cfa_offset 24
 2558 0004 00AF     		add	r7, sp, #0
 2559              		.cfi_offset 14, -4
 2560              		.cfi_offset 7, -8
 2561              	.LCFI70:
 2562              		.cfi_def_cfa_register 7
 2563 0006 7860     		str	r0, [r7, #4]
 2564 0008 3960     		str	r1, [r7, #0]
1719:FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:FreeRTOS/Source/tasks.c **** 
1721:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:FreeRTOS/Source/tasks.c **** 
1723:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:FreeRTOS/Source/tasks.c **** 
1726:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2565              		.loc 1 1729 0
 2566 000a 144B     		ldr	r3, .L160
 2567 000c 1B68     		ldr	r3, [r3, #0]
 2568 000e 03F11803 		add	r3, r3, #24
 2569 0012 7868     		ldr	r0, [r7, #4]
 2570 0014 1946     		mov	r1, r3
 2571 0016 FFF7FEFF 		bl	vListInsert
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2572              		.loc 1 1734 0
 2573 001a 104B     		ldr	r3, .L160
 2574 001c 1B68     		ldr	r3, [r3, #0]
 2575 001e 03F10403 		add	r3, r3, #4
 2576 0022 1846     		mov	r0, r3
 2577 0024 FFF7FEFF 		bl	vListRemove
1735:FreeRTOS/Source/tasks.c **** 
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:FreeRTOS/Source/tasks.c **** 	{
1739:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2578              		.loc 1 1739 0
 2579 0028 3B68     		ldr	r3, [r7, #0]
 2580 002a B3F1FF3F 		cmp	r3, #-1
 2581 002e 08D1     		bne	.L158
1740:FreeRTOS/Source/tasks.c **** 		{
1741:FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2582              		.loc 1 1744 0
 2583 0030 0A4B     		ldr	r3, .L160
 2584 0032 1B68     		ldr	r3, [r3, #0]
 2585 0034 03F10403 		add	r3, r3, #4
 2586 0038 0948     		ldr	r0, .L160+4
 2587 003a 1946     		mov	r1, r3
 2588 003c FFF7FEFF 		bl	vListInsertEnd
 2589 0040 07E0     		b	.L157
 2590              	.L158:
1745:FreeRTOS/Source/tasks.c **** 		}
1746:FreeRTOS/Source/tasks.c **** 		else
1747:FreeRTOS/Source/tasks.c **** 		{
1748:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 2591              		.loc 1 1750 0
 2592 0042 084B     		ldr	r3, .L160+8
 2593 0044 1A68     		ldr	r2, [r3, #0]
 2594 0046 3B68     		ldr	r3, [r7, #0]
 2595 0048 D318     		adds	r3, r2, r3
 2596 004a FB60     		str	r3, [r7, #12]
1751:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2597              		.loc 1 1751 0
 2598 004c F868     		ldr	r0, [r7, #12]
 2599 004e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2600              	.L157:
1752:FreeRTOS/Source/tasks.c **** 		}
1753:FreeRTOS/Source/tasks.c **** 	}
1754:FreeRTOS/Source/tasks.c **** 	#else
1755:FreeRTOS/Source/tasks.c **** 	{
1756:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:FreeRTOS/Source/tasks.c **** 	}
1761:FreeRTOS/Source/tasks.c **** 	#endif
1762:FreeRTOS/Source/tasks.c **** }
 2601              		.loc 1 1762 0
 2602 0052 07F11007 		add	r7, r7, #16
 2603 0056 BD46     		mov	sp, r7
 2604 0058 80BD     		pop	{r7, pc}
 2605              	.L161:
 2606 005a 00BF     		.align	2
 2607              	.L160:
 2608 005c 00000000 		.word	pxCurrentTCB
 2609 0060 00000000 		.word	xSuspendedTaskList
 2610 0064 00000000 		.word	xTickCount
 2611              		.cfi_endproc
 2612              	.LFE134:
 2614              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2615              		.align	2
 2616              		.global	xTaskRemoveFromEventList
 2617              		.thumb
 2618              		.thumb_func
 2620              	xTaskRemoveFromEventList:
 2621              	.LFB135:
1763:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:FreeRTOS/Source/tasks.c **** 
1765:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:FreeRTOS/Source/tasks.c **** 	{
1769:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:FreeRTOS/Source/tasks.c **** 
1771:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:FreeRTOS/Source/tasks.c **** 
1773:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:FreeRTOS/Source/tasks.c **** 
1778:FreeRTOS/Source/tasks.c **** 	
1779:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:FreeRTOS/Source/tasks.c **** 
1785:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:FreeRTOS/Source/tasks.c **** 
1790:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:FreeRTOS/Source/tasks.c **** 	}
1795:FreeRTOS/Source/tasks.c **** 	
1796:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:FreeRTOS/Source/tasks.c **** 
1799:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:FreeRTOS/Source/tasks.c **** {
 2622              		.loc 1 1800 0
 2623              		.cfi_startproc
 2624              		@ args = 0, pretend = 0, frame = 16
 2625              		@ frame_needed = 1, uses_anonymous_args = 0
 2626 0000 80B5     		push	{r7, lr}
 2627              	.LCFI71:
 2628              		.cfi_def_cfa_offset 8
 2629 0002 84B0     		sub	sp, sp, #16
 2630              	.LCFI72:
 2631              		.cfi_def_cfa_offset 24
 2632 0004 00AF     		add	r7, sp, #0
 2633              		.cfi_offset 14, -4
 2634              		.cfi_offset 7, -8
 2635              	.LCFI73:
 2636              		.cfi_def_cfa_register 7
 2637 0006 7860     		str	r0, [r7, #4]
1801:FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:FreeRTOS/Source/tasks.c **** 
1804:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:FreeRTOS/Source/tasks.c **** 
1811:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:FreeRTOS/Source/tasks.c **** 	
1815:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2638              		.loc 1 1817 0
 2639 0008 7B68     		ldr	r3, [r7, #4]
 2640 000a DB68     		ldr	r3, [r3, #12]
 2641 000c DB68     		ldr	r3, [r3, #12]
 2642 000e BB60     		str	r3, [r7, #8]
1818:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2643              		.loc 1 1819 0
 2644 0010 BB68     		ldr	r3, [r7, #8]
 2645 0012 03F11803 		add	r3, r3, #24
 2646 0016 1846     		mov	r0, r3
 2647 0018 FFF7FEFF 		bl	vListRemove
1820:FreeRTOS/Source/tasks.c **** 
1821:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2648              		.loc 1 1821 0
 2649 001c 204B     		ldr	r3, .L168
 2650 001e 1B68     		ldr	r3, [r3, #0]
 2651 0020 002B     		cmp	r3, #0
 2652 0022 22D1     		bne	.L163
1822:FreeRTOS/Source/tasks.c **** 	{
1823:FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2653              		.loc 1 1823 0
 2654 0024 BB68     		ldr	r3, [r7, #8]
 2655 0026 03F10403 		add	r3, r3, #4
 2656 002a 1846     		mov	r0, r3
 2657 002c FFF7FEFF 		bl	vListRemove
1824:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2658              		.loc 1 1824 0
 2659 0030 BB68     		ldr	r3, [r7, #8]
 2660 0032 DA6A     		ldr	r2, [r3, #44]
 2661 0034 1B4B     		ldr	r3, .L168+4
 2662 0036 1B68     		ldr	r3, [r3, #0]
 2663 0038 9A42     		cmp	r2, r3
 2664 003a 03D9     		bls	.L164
 2665              		.loc 1 1824 0 is_stmt 0 discriminator 1
 2666 003c BB68     		ldr	r3, [r7, #8]
 2667 003e DA6A     		ldr	r2, [r3, #44]
 2668 0040 184B     		ldr	r3, .L168+4
 2669 0042 1A60     		str	r2, [r3, #0]
 2670              	.L164:
 2671              		.loc 1 1824 0 discriminator 2
 2672 0044 BB68     		ldr	r3, [r7, #8]
 2673 0046 DA6A     		ldr	r2, [r3, #44]
 2674 0048 1346     		mov	r3, r2
 2675 004a 4FEA8303 		lsl	r3, r3, #2
 2676 004e 9B18     		adds	r3, r3, r2
 2677 0050 4FEA8303 		lsl	r3, r3, #2
 2678 0054 1A46     		mov	r2, r3
 2679 0056 144B     		ldr	r3, .L168+8
 2680 0058 D218     		adds	r2, r2, r3
 2681 005a BB68     		ldr	r3, [r7, #8]
 2682 005c 03F10403 		add	r3, r3, #4
 2683 0060 1046     		mov	r0, r2
 2684 0062 1946     		mov	r1, r3
 2685 0064 FFF7FEFF 		bl	vListInsertEnd
 2686 0068 06E0     		b	.L165
 2687              	.L163:
1825:FreeRTOS/Source/tasks.c **** 	}
1826:FreeRTOS/Source/tasks.c **** 	else
1827:FreeRTOS/Source/tasks.c **** 	{
1828:FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2688              		.loc 1 1830 0 is_stmt 1
 2689 006a BB68     		ldr	r3, [r7, #8]
 2690 006c 03F11803 		add	r3, r3, #24
 2691 0070 0E48     		ldr	r0, .L168+12
 2692 0072 1946     		mov	r1, r3
 2693 0074 FFF7FEFF 		bl	vListInsertEnd
 2694              	.L165:
1831:FreeRTOS/Source/tasks.c **** 	}
1832:FreeRTOS/Source/tasks.c **** 
1833:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2695              		.loc 1 1833 0
 2696 0078 BB68     		ldr	r3, [r7, #8]
 2697 007a DA6A     		ldr	r2, [r3, #44]
 2698 007c 0C4B     		ldr	r3, .L168+16
 2699 007e 1B68     		ldr	r3, [r3, #0]
 2700 0080 DB6A     		ldr	r3, [r3, #44]
 2701 0082 9A42     		cmp	r2, r3
 2702 0084 03D3     		bcc	.L166
1834:FreeRTOS/Source/tasks.c **** 	{
1835:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:FreeRTOS/Source/tasks.c **** 		switch now. */
1839:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
 2703              		.loc 1 1839 0
 2704 0086 4FF00103 		mov	r3, #1
 2705 008a FB60     		str	r3, [r7, #12]
 2706 008c 02E0     		b	.L167
 2707              	.L166:
1840:FreeRTOS/Source/tasks.c **** 	}
1841:FreeRTOS/Source/tasks.c **** 	else
1842:FreeRTOS/Source/tasks.c **** 	{
1843:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
 2708              		.loc 1 1843 0
 2709 008e 4FF00003 		mov	r3, #0
 2710 0092 FB60     		str	r3, [r7, #12]
 2711              	.L167:
1844:FreeRTOS/Source/tasks.c **** 	}
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2712              		.loc 1 1846 0
 2713 0094 FB68     		ldr	r3, [r7, #12]
1847:FreeRTOS/Source/tasks.c **** }
 2714              		.loc 1 1847 0
 2715 0096 1846     		mov	r0, r3
 2716 0098 07F11007 		add	r7, r7, #16
 2717 009c BD46     		mov	sp, r7
 2718 009e 80BD     		pop	{r7, pc}
 2719              	.L169:
 2720              		.align	2
 2721              	.L168:
 2722 00a0 00000000 		.word	uxSchedulerSuspended
 2723 00a4 00000000 		.word	uxTopReadyPriority
 2724 00a8 00000000 		.word	pxReadyTasksLists
 2725 00ac 00000000 		.word	xPendingReadyList
 2726 00b0 00000000 		.word	pxCurrentTCB
 2727              		.cfi_endproc
 2728              	.LFE135:
 2730              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2731              		.align	2
 2732              		.global	vTaskSetTimeOutState
 2733              		.thumb
 2734              		.thumb_func
 2736              	vTaskSetTimeOutState:
 2737              	.LFB136:
1848:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:FreeRTOS/Source/tasks.c **** 
1850:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:FreeRTOS/Source/tasks.c **** {
 2738              		.loc 1 1851 0
 2739              		.cfi_startproc
 2740              		@ args = 0, pretend = 0, frame = 8
 2741              		@ frame_needed = 1, uses_anonymous_args = 0
 2742              		@ link register save eliminated.
 2743 0000 80B4     		push	{r7}
 2744              	.LCFI74:
 2745              		.cfi_def_cfa_offset 4
 2746 0002 83B0     		sub	sp, sp, #12
 2747              	.LCFI75:
 2748              		.cfi_def_cfa_offset 16
 2749 0004 00AF     		add	r7, sp, #0
 2750              		.cfi_offset 7, -4
 2751              	.LCFI76:
 2752              		.cfi_def_cfa_register 7
 2753 0006 7860     		str	r0, [r7, #4]
1852:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2754              		.loc 1 1853 0
 2755 0008 064B     		ldr	r3, .L171
 2756 000a 1A68     		ldr	r2, [r3, #0]
 2757 000c 7B68     		ldr	r3, [r7, #4]
 2758 000e 1A60     		str	r2, [r3, #0]
1854:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2759              		.loc 1 1854 0
 2760 0010 054B     		ldr	r3, .L171+4
 2761 0012 1A68     		ldr	r2, [r3, #0]
 2762 0014 7B68     		ldr	r3, [r7, #4]
 2763 0016 5A60     		str	r2, [r3, #4]
1855:FreeRTOS/Source/tasks.c **** }
 2764              		.loc 1 1855 0
 2765 0018 07F10C07 		add	r7, r7, #12
 2766 001c BD46     		mov	sp, r7
 2767 001e 80BC     		pop	{r7}
 2768 0020 7047     		bx	lr
 2769              	.L172:
 2770 0022 00BF     		.align	2
 2771              	.L171:
 2772 0024 00000000 		.word	xNumOfOverflows
 2773 0028 00000000 		.word	xTickCount
 2774              		.cfi_endproc
 2775              	.LFE136:
 2777              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2778              		.align	2
 2779              		.global	xTaskCheckForTimeOut
 2780              		.thumb
 2781              		.thumb_func
 2783              	xTaskCheckForTimeOut:
 2784              	.LFB137:
1856:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:FreeRTOS/Source/tasks.c **** {
 2785              		.loc 1 1859 0
 2786              		.cfi_startproc
 2787              		@ args = 0, pretend = 0, frame = 16
 2788              		@ frame_needed = 1, uses_anonymous_args = 0
 2789 0000 80B5     		push	{r7, lr}
 2790              	.LCFI77:
 2791              		.cfi_def_cfa_offset 8
 2792 0002 84B0     		sub	sp, sp, #16
 2793              	.LCFI78:
 2794              		.cfi_def_cfa_offset 24
 2795 0004 00AF     		add	r7, sp, #0
 2796              		.cfi_offset 14, -4
 2797              		.cfi_offset 7, -8
 2798              	.LCFI79:
 2799              		.cfi_def_cfa_register 7
 2800 0006 7860     		str	r0, [r7, #4]
 2801 0008 3960     		str	r1, [r7, #0]
1860:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:FreeRTOS/Source/tasks.c **** 
1862:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
 2802              		.loc 1 1865 0
 2803 000a FFF7FEFF 		bl	vPortEnterCritical
1866:FreeRTOS/Source/tasks.c **** 	{
1867:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2804              		.loc 1 1871 0
 2805 000e 3B68     		ldr	r3, [r7, #0]
 2806 0010 1B68     		ldr	r3, [r3, #0]
 2807 0012 B3F1FF3F 		cmp	r3, #-1
 2808 0016 03D1     		bne	.L174
1872:FreeRTOS/Source/tasks.c **** 			{
1873:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
 2809              		.loc 1 1873 0
 2810 0018 4FF00003 		mov	r3, #0
 2811 001c FB60     		str	r3, [r7, #12]
 2812 001e 2CE0     		b	.L175
 2813              	.L174:
1874:FreeRTOS/Source/tasks.c **** 			}
1875:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:FreeRTOS/Source/tasks.c **** 		#endif
1877:FreeRTOS/Source/tasks.c **** 
1878:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2814              		.loc 1 1878 0
 2815 0020 7B68     		ldr	r3, [r7, #4]
 2816 0022 1A68     		ldr	r2, [r3, #0]
 2817 0024 194B     		ldr	r3, .L178
 2818 0026 1B68     		ldr	r3, [r3, #0]
 2819 0028 9A42     		cmp	r2, r3
 2820 002a 09D0     		beq	.L176
 2821              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2822 002c 7B68     		ldr	r3, [r7, #4]
 2823 002e 5A68     		ldr	r2, [r3, #4]
 2824 0030 174B     		ldr	r3, .L178+4
 2825 0032 1B68     		ldr	r3, [r3, #0]
 2826 0034 9A42     		cmp	r2, r3
 2827 0036 03D8     		bhi	.L176
1879:FreeRTOS/Source/tasks.c **** 		{
1880:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2828              		.loc 1 1884 0 is_stmt 1
 2829 0038 4FF00103 		mov	r3, #1
 2830 003c FB60     		str	r3, [r7, #12]
 2831 003e 1CE0     		b	.L175
 2832              	.L176:
1885:FreeRTOS/Source/tasks.c **** 		}
1886:FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2833              		.loc 1 1886 0
 2834 0040 134B     		ldr	r3, .L178+4
 2835 0042 1A68     		ldr	r2, [r3, #0]
 2836 0044 7B68     		ldr	r3, [r7, #4]
 2837 0046 5B68     		ldr	r3, [r3, #4]
 2838 0048 D21A     		subs	r2, r2, r3
 2839 004a 3B68     		ldr	r3, [r7, #0]
 2840 004c 1B68     		ldr	r3, [r3, #0]
 2841 004e 9A42     		cmp	r2, r3
 2842 0050 10D2     		bcs	.L177
1887:FreeRTOS/Source/tasks.c **** 		{
1888:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2843              		.loc 1 1889 0
 2844 0052 3B68     		ldr	r3, [r7, #0]
 2845 0054 1A68     		ldr	r2, [r3, #0]
 2846 0056 7B68     		ldr	r3, [r7, #4]
 2847 0058 5968     		ldr	r1, [r3, #4]
 2848 005a 0D4B     		ldr	r3, .L178+4
 2849 005c 1B68     		ldr	r3, [r3, #0]
 2850 005e CB1A     		subs	r3, r1, r3
 2851 0060 D218     		adds	r2, r2, r3
 2852 0062 3B68     		ldr	r3, [r7, #0]
 2853 0064 1A60     		str	r2, [r3, #0]
1890:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2854              		.loc 1 1890 0
 2855 0066 7868     		ldr	r0, [r7, #4]
 2856 0068 FFF7FEFF 		bl	vTaskSetTimeOutState
1891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2857              		.loc 1 1891 0
 2858 006c 4FF00003 		mov	r3, #0
 2859 0070 FB60     		str	r3, [r7, #12]
 2860 0072 02E0     		b	.L175
 2861              	.L177:
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
 2862              		.loc 1 1895 0
 2863 0074 4FF00103 		mov	r3, #1
 2864 0078 FB60     		str	r3, [r7, #12]
 2865              	.L175:
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
 2866              		.loc 1 1898 0
 2867 007a FFF7FEFF 		bl	vPortExitCritical
1899:FreeRTOS/Source/tasks.c **** 
1900:FreeRTOS/Source/tasks.c **** 	return xReturn;
 2868              		.loc 1 1900 0
 2869 007e FB68     		ldr	r3, [r7, #12]
1901:FreeRTOS/Source/tasks.c **** }
 2870              		.loc 1 1901 0
 2871 0080 1846     		mov	r0, r3
 2872 0082 07F11007 		add	r7, r7, #16
 2873 0086 BD46     		mov	sp, r7
 2874 0088 80BD     		pop	{r7, pc}
 2875              	.L179:
 2876 008a 00BF     		.align	2
 2877              	.L178:
 2878 008c 00000000 		.word	xNumOfOverflows
 2879 0090 00000000 		.word	xTickCount
 2880              		.cfi_endproc
 2881              	.LFE137:
 2883              		.section	.text.vTaskMissedYield,"ax",%progbits
 2884              		.align	2
 2885              		.global	vTaskMissedYield
 2886              		.thumb
 2887              		.thumb_func
 2889              	vTaskMissedYield:
 2890              	.LFB138:
1902:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:FreeRTOS/Source/tasks.c **** {
 2891              		.loc 1 1905 0
 2892              		.cfi_startproc
 2893              		@ args = 0, pretend = 0, frame = 0
 2894              		@ frame_needed = 1, uses_anonymous_args = 0
 2895              		@ link register save eliminated.
 2896 0000 80B4     		push	{r7}
 2897              	.LCFI80:
 2898              		.cfi_def_cfa_offset 4
 2899 0002 00AF     		add	r7, sp, #0
 2900              		.cfi_offset 7, -4
 2901              	.LCFI81:
 2902              		.cfi_def_cfa_register 7
1906:FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2903              		.loc 1 1906 0
 2904 0004 034B     		ldr	r3, .L181
 2905 0006 4FF00102 		mov	r2, #1
 2906 000a 1A60     		str	r2, [r3, #0]
1907:FreeRTOS/Source/tasks.c **** }
 2907              		.loc 1 1907 0
 2908 000c BD46     		mov	sp, r7
 2909 000e 80BC     		pop	{r7}
 2910 0010 7047     		bx	lr
 2911              	.L182:
 2912 0012 00BF     		.align	2
 2913              	.L181:
 2914 0014 00000000 		.word	xMissedYield
 2915              		.cfi_endproc
 2916              	.LFE138:
 2918              		.section	.text.prvIdleTask,"ax",%progbits
 2919              		.align	2
 2920              		.thumb
 2921              		.thumb_func
 2923              	prvIdleTask:
 2924              	.LFB139:
1908:FreeRTOS/Source/tasks.c **** 
1909:FreeRTOS/Source/tasks.c **** /*
1910:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:FreeRTOS/Source/tasks.c ****  *
1914:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:FreeRTOS/Source/tasks.c ****  *
1917:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:FreeRTOS/Source/tasks.c ****  *
1919:FreeRTOS/Source/tasks.c ****  */
1920:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:FreeRTOS/Source/tasks.c **** {
 2925              		.loc 1 1921 0
 2926              		.cfi_startproc
 2927              		@ args = 0, pretend = 0, frame = 8
 2928              		@ frame_needed = 1, uses_anonymous_args = 0
 2929 0000 80B5     		push	{r7, lr}
 2930              	.LCFI82:
 2931              		.cfi_def_cfa_offset 8
 2932 0002 82B0     		sub	sp, sp, #8
 2933              	.LCFI83:
 2934              		.cfi_def_cfa_offset 16
 2935 0004 00AF     		add	r7, sp, #0
 2936              		.cfi_offset 14, -4
 2937              		.cfi_offset 7, -8
 2938              	.LCFI84:
 2939              		.cfi_def_cfa_register 7
 2940 0006 7860     		str	r0, [r7, #4]
 2941 0008 00E0     		b	.L185
 2942              	.L186:
1922:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:FreeRTOS/Source/tasks.c **** 
1925:FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:FreeRTOS/Source/tasks.c **** 	{
1927:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1929:FreeRTOS/Source/tasks.c **** 
1930:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:FreeRTOS/Source/tasks.c **** 		{
1932:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:FreeRTOS/Source/tasks.c **** 		}
1938:FreeRTOS/Source/tasks.c **** 		#endif
1939:FreeRTOS/Source/tasks.c **** 
1940:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:FreeRTOS/Source/tasks.c **** 		{
1942:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:FreeRTOS/Source/tasks.c **** 			timeslice.
1946:FreeRTOS/Source/tasks.c **** 
1947:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1952:FreeRTOS/Source/tasks.c **** 			{
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
1954:FreeRTOS/Source/tasks.c **** 			}
1955:FreeRTOS/Source/tasks.c **** 		}
1956:FreeRTOS/Source/tasks.c **** 		#endif
1957:FreeRTOS/Source/tasks.c **** 
1958:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:FreeRTOS/Source/tasks.c **** 		{
1960:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:FreeRTOS/Source/tasks.c **** 
1962:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 		#endif
1970:FreeRTOS/Source/tasks.c **** 	}
 2943              		.loc 1 1970 0
 2944 000a 00BF     		nop
 2945              	.L185:
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 2946              		.loc 1 1928 0
 2947 000c FFF7FEFF 		bl	prvCheckTasksWaitingTermination
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2948              		.loc 1 1951 0
 2949 0010 034B     		ldr	r3, .L187
 2950 0012 1B68     		ldr	r3, [r3, #0]
 2951 0014 012B     		cmp	r3, #1
 2952 0016 F8D9     		bls	.L186
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
 2953              		.loc 1 1953 0
 2954 0018 FFF7FEFF 		bl	vPortYieldFromISR
 2955              		.loc 1 1970 0
 2956 001c F6E7     		b	.L185
 2957              	.L188:
 2958 001e 00BF     		.align	2
 2959              	.L187:
 2960 0020 00000000 		.word	pxReadyTasksLists
 2961              		.cfi_endproc
 2962              	.LFE139:
 2964              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2965              		.align	2
 2966              		.thumb
 2967              		.thumb_func
 2969              	prvInitialiseTCBVariables:
 2970              	.LFB140:
1971:FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:FreeRTOS/Source/tasks.c **** 
1973:FreeRTOS/Source/tasks.c **** 
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** 
1976:FreeRTOS/Source/tasks.c **** 
1977:FreeRTOS/Source/tasks.c **** 
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:FreeRTOS/Source/tasks.c **** 
1983:FreeRTOS/Source/tasks.c **** 
1984:FreeRTOS/Source/tasks.c **** 
1985:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:FreeRTOS/Source/tasks.c **** {
 2971              		.loc 1 1986 0
 2972              		.cfi_startproc
 2973              		@ args = 4, pretend = 0, frame = 16
 2974              		@ frame_needed = 1, uses_anonymous_args = 0
 2975 0000 80B5     		push	{r7, lr}
 2976              	.LCFI85:
 2977              		.cfi_def_cfa_offset 8
 2978 0002 84B0     		sub	sp, sp, #16
 2979              	.LCFI86:
 2980              		.cfi_def_cfa_offset 24
 2981 0004 00AF     		add	r7, sp, #0
 2982              		.cfi_offset 14, -4
 2983              		.cfi_offset 7, -8
 2984              	.LCFI87:
 2985              		.cfi_def_cfa_register 7
 2986 0006 F860     		str	r0, [r7, #12]
 2987 0008 B960     		str	r1, [r7, #8]
 2988 000a 7A60     		str	r2, [r7, #4]
 2989 000c 3B60     		str	r3, [r7, #0]
1987:FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:FreeRTOS/Source/tasks.c **** 	{
1990:FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 2990              		.loc 1 1991 0
 2991 000e FB68     		ldr	r3, [r7, #12]
 2992 0010 03F13403 		add	r3, r3, #52
 2993 0014 1A46     		mov	r2, r3
 2994 0016 BB68     		ldr	r3, [r7, #8]
 2995 0018 1046     		mov	r0, r2
 2996 001a 1946     		mov	r1, r3
 2997 001c 4FF01002 		mov	r2, #16
 2998 0020 FFF7FEFF 		bl	strncpy
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif
1994:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 2999              		.loc 1 1994 0
 3000 0024 FB68     		ldr	r3, [r7, #12]
 3001 0026 4FF00002 		mov	r2, #0
 3002 002a 83F84320 		strb	r2, [r3, #67]
1995:FreeRTOS/Source/tasks.c **** 
1996:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 3003              		.loc 1 1998 0
 3004 002e 7B68     		ldr	r3, [r7, #4]
 3005 0030 042B     		cmp	r3, #4
 3006 0032 02D9     		bls	.L190
1999:FreeRTOS/Source/tasks.c **** 	{
2000:FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 3007              		.loc 1 2000 0
 3008 0034 4FF00403 		mov	r3, #4
 3009 0038 7B60     		str	r3, [r7, #4]
 3010              	.L190:
2001:FreeRTOS/Source/tasks.c **** 	}
2002:FreeRTOS/Source/tasks.c **** 
2003:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3011              		.loc 1 2003 0
 3012 003a FB68     		ldr	r3, [r7, #12]
 3013 003c 7A68     		ldr	r2, [r7, #4]
 3014 003e DA62     		str	r2, [r3, #44]
2004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:FreeRTOS/Source/tasks.c **** 	{
2006:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3015              		.loc 1 2006 0
 3016 0040 FB68     		ldr	r3, [r7, #12]
 3017 0042 7A68     		ldr	r2, [r7, #4]
 3018 0044 5A64     		str	r2, [r3, #68]
2007:FreeRTOS/Source/tasks.c **** 	}
2008:FreeRTOS/Source/tasks.c **** 	#endif
2009:FreeRTOS/Source/tasks.c **** 
2010:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3019              		.loc 1 2010 0
 3020 0046 FB68     		ldr	r3, [r7, #12]
 3021 0048 03F10403 		add	r3, r3, #4
 3022 004c 1846     		mov	r0, r3
 3023 004e FFF7FEFF 		bl	vListInitialiseItem
2011:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3024              		.loc 1 2011 0
 3025 0052 FB68     		ldr	r3, [r7, #12]
 3026 0054 03F11803 		add	r3, r3, #24
 3027 0058 1846     		mov	r0, r3
 3028 005a FFF7FEFF 		bl	vListInitialiseItem
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3029              		.loc 1 2015 0
 3030 005e FB68     		ldr	r3, [r7, #12]
 3031 0060 FA68     		ldr	r2, [r7, #12]
 3032 0062 1A61     		str	r2, [r3, #16]
2016:FreeRTOS/Source/tasks.c **** 
2017:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3033              		.loc 1 2018 0
 3034 0064 7B68     		ldr	r3, [r7, #4]
 3035 0066 C3F10502 		rsb	r2, r3, #5
 3036 006a FB68     		ldr	r3, [r7, #12]
 3037 006c 9A61     		str	r2, [r3, #24]
2019:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3038              		.loc 1 2019 0
 3039 006e FB68     		ldr	r3, [r7, #12]
 3040 0070 FA68     		ldr	r2, [r7, #12]
 3041 0072 5A62     		str	r2, [r3, #36]
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:FreeRTOS/Source/tasks.c **** 	{
2023:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:FreeRTOS/Source/tasks.c **** 	}
2025:FreeRTOS/Source/tasks.c **** 	#endif
2026:FreeRTOS/Source/tasks.c **** 
2027:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:FreeRTOS/Source/tasks.c **** 	{
2029:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
 3042              		.loc 1 2029 0
 3043 0074 FB68     		ldr	r3, [r7, #12]
 3044 0076 4FF00002 		mov	r2, #0
 3045 007a 9A64     		str	r2, [r3, #72]
2030:FreeRTOS/Source/tasks.c **** 	}
2031:FreeRTOS/Source/tasks.c **** 	#endif
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:FreeRTOS/Source/tasks.c **** 	{
2035:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 3046              		.loc 1 2035 0
 3047 007c FB68     		ldr	r3, [r7, #12]
 3048 007e 4FF00002 		mov	r2, #0
 3049 0082 DA64     		str	r2, [r3, #76]
2036:FreeRTOS/Source/tasks.c **** 	}
2037:FreeRTOS/Source/tasks.c **** 	#endif
2038:FreeRTOS/Source/tasks.c **** 
2039:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:FreeRTOS/Source/tasks.c **** 	{
2041:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:FreeRTOS/Source/tasks.c **** 	}
2043:FreeRTOS/Source/tasks.c **** 	#else
2044:FreeRTOS/Source/tasks.c **** 	{
2045:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:FreeRTOS/Source/tasks.c **** 	}
2048:FreeRTOS/Source/tasks.c **** 	#endif
2049:FreeRTOS/Source/tasks.c **** }
 3050              		.loc 1 2049 0
 3051 0084 07F11007 		add	r7, r7, #16
 3052 0088 BD46     		mov	sp, r7
 3053 008a 80BD     		pop	{r7, pc}
 3054              		.cfi_endproc
 3055              	.LFE140:
 3057              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3058              		.align	2
 3059              		.thumb
 3060              		.thumb_func
 3062              	prvInitialiseTaskLists:
 3063              	.LFB141:
2050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:FreeRTOS/Source/tasks.c **** 
2052:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:FreeRTOS/Source/tasks.c **** 
2054:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:FreeRTOS/Source/tasks.c **** 	{
2056:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:FreeRTOS/Source/tasks.c **** 	
2058:FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:FreeRTOS/Source/tasks.c **** 		{
2060:FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:FreeRTOS/Source/tasks.c **** 		}
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:FreeRTOS/Source/tasks.c **** 
2066:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:FreeRTOS/Source/tasks.c **** 	}
2068:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:FreeRTOS/Source/tasks.c **** #endif
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:FreeRTOS/Source/tasks.c **** {
 3064              		.loc 1 2072 0
 3065              		.cfi_startproc
 3066              		@ args = 0, pretend = 0, frame = 8
 3067              		@ frame_needed = 1, uses_anonymous_args = 0
 3068 0000 80B5     		push	{r7, lr}
 3069              	.LCFI88:
 3070              		.cfi_def_cfa_offset 8
 3071 0002 82B0     		sub	sp, sp, #8
 3072              	.LCFI89:
 3073              		.cfi_def_cfa_offset 16
 3074 0004 00AF     		add	r7, sp, #0
 3075              		.cfi_offset 14, -4
 3076              		.cfi_offset 7, -8
 3077              	.LCFI90:
 3078              		.cfi_def_cfa_register 7
2073:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:FreeRTOS/Source/tasks.c **** 
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3079              		.loc 1 2075 0
 3080 0006 4FF00003 		mov	r3, #0
 3081 000a 7B60     		str	r3, [r7, #4]
 3082 000c 10E0     		b	.L192
 3083              	.L193:
2076:FreeRTOS/Source/tasks.c **** 	{
2077:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3084              		.loc 1 2077 0 discriminator 2
 3085 000e 7A68     		ldr	r2, [r7, #4]
 3086 0010 1346     		mov	r3, r2
 3087 0012 4FEA8303 		lsl	r3, r3, #2
 3088 0016 9B18     		adds	r3, r3, r2
 3089 0018 4FEA8303 		lsl	r3, r3, #2
 3090 001c 1A46     		mov	r2, r3
 3091 001e 124B     		ldr	r3, .L194
 3092 0020 D318     		adds	r3, r2, r3
 3093 0022 1846     		mov	r0, r3
 3094 0024 FFF7FEFF 		bl	vListInitialise
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3095              		.loc 1 2075 0 discriminator 2
 3096 0028 7B68     		ldr	r3, [r7, #4]
 3097 002a 03F10103 		add	r3, r3, #1
 3098 002e 7B60     		str	r3, [r7, #4]
 3099              	.L192:
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3100              		.loc 1 2075 0 is_stmt 0 discriminator 1
 3101 0030 7B68     		ldr	r3, [r7, #4]
 3102 0032 042B     		cmp	r3, #4
 3103 0034 EBD9     		bls	.L193
2078:FreeRTOS/Source/tasks.c **** 	}
2079:FreeRTOS/Source/tasks.c **** 
2080:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3104              		.loc 1 2080 0 is_stmt 1
 3105 0036 0D48     		ldr	r0, .L194+4
 3106 0038 FFF7FEFF 		bl	vListInitialise
2081:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3107              		.loc 1 2081 0
 3108 003c 0C48     		ldr	r0, .L194+8
 3109 003e FFF7FEFF 		bl	vListInitialise
2082:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3110              		.loc 1 2082 0
 3111 0042 0C48     		ldr	r0, .L194+12
 3112 0044 FFF7FEFF 		bl	vListInitialise
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3113              		.loc 1 2086 0
 3114 0048 0B48     		ldr	r0, .L194+16
 3115 004a FFF7FEFF 		bl	vListInitialise
2087:FreeRTOS/Source/tasks.c **** 	}
2088:FreeRTOS/Source/tasks.c **** 	#endif
2089:FreeRTOS/Source/tasks.c **** 
2090:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:FreeRTOS/Source/tasks.c **** 	{
2092:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3116              		.loc 1 2092 0
 3117 004e 0B48     		ldr	r0, .L194+20
 3118 0050 FFF7FEFF 		bl	vListInitialise
2093:FreeRTOS/Source/tasks.c **** 	}
2094:FreeRTOS/Source/tasks.c **** 	#endif
2095:FreeRTOS/Source/tasks.c **** 
2096:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:FreeRTOS/Source/tasks.c **** 	using list2. */
2098:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3119              		.loc 1 2098 0
 3120 0054 0A4B     		ldr	r3, .L194+24
 3121 0056 054A     		ldr	r2, .L194+4
 3122 0058 1A60     		str	r2, [r3, #0]
2099:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3123              		.loc 1 2099 0
 3124 005a 0A4B     		ldr	r3, .L194+28
 3125 005c 044A     		ldr	r2, .L194+8
 3126 005e 1A60     		str	r2, [r3, #0]
2100:FreeRTOS/Source/tasks.c **** }
 3127              		.loc 1 2100 0
 3128 0060 07F10807 		add	r7, r7, #8
 3129 0064 BD46     		mov	sp, r7
 3130 0066 80BD     		pop	{r7, pc}
 3131              	.L195:
 3132              		.align	2
 3133              	.L194:
 3134 0068 00000000 		.word	pxReadyTasksLists
 3135 006c 00000000 		.word	xDelayedTaskList1
 3136 0070 00000000 		.word	xDelayedTaskList2
 3137 0074 00000000 		.word	xPendingReadyList
 3138 0078 00000000 		.word	xTasksWaitingTermination
 3139 007c 00000000 		.word	xSuspendedTaskList
 3140 0080 00000000 		.word	pxDelayedTaskList
 3141 0084 00000000 		.word	pxOverflowDelayedTaskList
 3142              		.cfi_endproc
 3143              	.LFE141:
 3145              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3146              		.align	2
 3147              		.thumb
 3148              		.thumb_func
 3150              	prvCheckTasksWaitingTermination:
 3151              	.LFB142:
2101:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:FreeRTOS/Source/tasks.c **** 
2103:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:FreeRTOS/Source/tasks.c **** {
 3152              		.loc 1 2104 0
 3153              		.cfi_startproc
 3154              		@ args = 0, pretend = 0, frame = 8
 3155              		@ frame_needed = 1, uses_anonymous_args = 0
 3156 0000 80B5     		push	{r7, lr}
 3157              	.LCFI91:
 3158              		.cfi_def_cfa_offset 8
 3159 0002 82B0     		sub	sp, sp, #8
 3160              	.LCFI92:
 3161              		.cfi_def_cfa_offset 16
 3162 0004 00AF     		add	r7, sp, #0
 3163              		.cfi_offset 14, -4
 3164              		.cfi_offset 7, -8
 3165              	.LCFI93:
 3166              		.cfi_def_cfa_register 7
 3167              	.LBB8:
2105:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:FreeRTOS/Source/tasks.c **** 	{
2107:FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:FreeRTOS/Source/tasks.c **** 
2109:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 3168              		.loc 1 2111 0
 3169 0006 194B     		ldr	r3, .L198
 3170 0008 1B68     		ldr	r3, [r3, #0]
 3171 000a 002B     		cmp	r3, #0
 3172 000c 2AD0     		beq	.L196
2112:FreeRTOS/Source/tasks.c **** 		{
2113:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 3173              		.loc 1 2113 0
 3174 000e FFF7FEFF 		bl	vTaskSuspendAll
2114:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3175              		.loc 1 2114 0
 3176 0012 174B     		ldr	r3, .L198+4
 3177 0014 1B68     		ldr	r3, [r3, #0]
 3178 0016 002B     		cmp	r3, #0
 3179 0018 14BF     		ite	ne
 3180 001a 0023     		movne	r3, #0
 3181 001c 0123     		moveq	r3, #1
 3182 001e 7B60     		str	r3, [r7, #4]
2115:FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 3183              		.loc 1 2115 0
 3184 0020 FFF7FEFF 		bl	xTaskResumeAll
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3185              		.loc 1 2117 0
 3186 0024 7B68     		ldr	r3, [r7, #4]
 3187 0026 002B     		cmp	r3, #0
 3188 0028 1CD1     		bne	.L196
 3189              	.LBB9:
2118:FreeRTOS/Source/tasks.c **** 			{
2119:FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
 3190              		.loc 1 2121 0
 3191 002a FFF7FEFF 		bl	vPortEnterCritical
2122:FreeRTOS/Source/tasks.c **** 				{
2123:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3192              		.loc 1 2123 0
 3193 002e 104B     		ldr	r3, .L198+4
 3194 0030 DB68     		ldr	r3, [r3, #12]
 3195 0032 DB68     		ldr	r3, [r3, #12]
 3196 0034 3B60     		str	r3, [r7, #0]
2124:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3197              		.loc 1 2124 0
 3198 0036 3B68     		ldr	r3, [r7, #0]
 3199 0038 03F10403 		add	r3, r3, #4
 3200 003c 1846     		mov	r0, r3
 3201 003e FFF7FEFF 		bl	vListRemove
2125:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3202              		.loc 1 2125 0
 3203 0042 0C4B     		ldr	r3, .L198+8
 3204 0044 1B68     		ldr	r3, [r3, #0]
 3205 0046 03F1FF32 		add	r2, r3, #-1
 3206 004a 0A4B     		ldr	r3, .L198+8
 3207 004c 1A60     		str	r2, [r3, #0]
2126:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 3208              		.loc 1 2126 0
 3209 004e 074B     		ldr	r3, .L198
 3210 0050 1B68     		ldr	r3, [r3, #0]
 3211 0052 03F1FF32 		add	r2, r3, #-1
 3212 0056 054B     		ldr	r3, .L198
 3213 0058 1A60     		str	r2, [r3, #0]
2127:FreeRTOS/Source/tasks.c **** 				}
2128:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
 3214              		.loc 1 2128 0
 3215 005a FFF7FEFF 		bl	vPortExitCritical
2129:FreeRTOS/Source/tasks.c **** 
2130:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3216              		.loc 1 2130 0
 3217 005e 3868     		ldr	r0, [r7, #0]
 3218 0060 FFF7FEFF 		bl	prvDeleteTCB
 3219              	.L196:
 3220              	.LBE9:
 3221              	.LBE8:
2131:FreeRTOS/Source/tasks.c **** 			}
2132:FreeRTOS/Source/tasks.c **** 		}
2133:FreeRTOS/Source/tasks.c **** 	}
2134:FreeRTOS/Source/tasks.c **** 	#endif
2135:FreeRTOS/Source/tasks.c **** }
 3222              		.loc 1 2135 0
 3223 0064 07F10807 		add	r7, r7, #8
 3224 0068 BD46     		mov	sp, r7
 3225 006a 80BD     		pop	{r7, pc}
 3226              	.L199:
 3227              		.align	2
 3228              	.L198:
 3229 006c 00000000 		.word	uxTasksDeleted
 3230 0070 00000000 		.word	xTasksWaitingTermination
 3231 0074 00000000 		.word	uxCurrentNumberOfTasks
 3232              		.cfi_endproc
 3233              	.LFE142:
 3235              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 3236              		.align	2
 3237              		.thumb
 3238              		.thumb_func
 3240              	prvAddCurrentTaskToDelayedList:
 3241              	.LFB143:
2136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:FreeRTOS/Source/tasks.c **** {
 3242              		.loc 1 2139 0
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 8
 3245              		@ frame_needed = 1, uses_anonymous_args = 0
 3246 0000 80B5     		push	{r7, lr}
 3247              	.LCFI94:
 3248              		.cfi_def_cfa_offset 8
 3249 0002 82B0     		sub	sp, sp, #8
 3250              	.LCFI95:
 3251              		.cfi_def_cfa_offset 16
 3252 0004 00AF     		add	r7, sp, #0
 3253              		.cfi_offset 14, -4
 3254              		.cfi_offset 7, -8
 3255              	.LCFI96:
 3256              		.cfi_def_cfa_register 7
 3257 0006 7860     		str	r0, [r7, #4]
2140:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 3258              		.loc 1 2141 0
 3259 0008 144B     		ldr	r3, .L203
 3260 000a 1B68     		ldr	r3, [r3, #0]
 3261 000c 7A68     		ldr	r2, [r7, #4]
 3262 000e 5A60     		str	r2, [r3, #4]
2142:FreeRTOS/Source/tasks.c **** 
2143:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
 3263              		.loc 1 2143 0
 3264 0010 134B     		ldr	r3, .L203+4
 3265 0012 1B68     		ldr	r3, [r3, #0]
 3266 0014 7A68     		ldr	r2, [r7, #4]
 3267 0016 9A42     		cmp	r2, r3
 3268 0018 0AD2     		bcs	.L201
2144:FreeRTOS/Source/tasks.c **** 	{
2145:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 3269              		.loc 1 2146 0
 3270 001a 124B     		ldr	r3, .L203+8
 3271 001c 1A68     		ldr	r2, [r3, #0]
 3272 001e 0F4B     		ldr	r3, .L203
 3273 0020 1B68     		ldr	r3, [r3, #0]
 3274 0022 03F10403 		add	r3, r3, #4
 3275 0026 1046     		mov	r0, r2
 3276 0028 1946     		mov	r1, r3
 3277 002a FFF7FEFF 		bl	vListInsert
 3278 002e 11E0     		b	.L200
 3279              	.L201:
2147:FreeRTOS/Source/tasks.c **** 	}
2148:FreeRTOS/Source/tasks.c **** 	else
2149:FreeRTOS/Source/tasks.c **** 	{
2150:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 3280              		.loc 1 2151 0
 3281 0030 0D4B     		ldr	r3, .L203+12
 3282 0032 1A68     		ldr	r2, [r3, #0]
 3283 0034 094B     		ldr	r3, .L203
 3284 0036 1B68     		ldr	r3, [r3, #0]
 3285 0038 03F10403 		add	r3, r3, #4
 3286 003c 1046     		mov	r0, r2
 3287 003e 1946     		mov	r1, r3
 3288 0040 FFF7FEFF 		bl	vListInsert
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:FreeRTOS/Source/tasks.c **** 		too. */
2156:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 3289              		.loc 1 2156 0
 3290 0044 094B     		ldr	r3, .L203+16
 3291 0046 1B68     		ldr	r3, [r3, #0]
 3292 0048 7A68     		ldr	r2, [r7, #4]
 3293 004a 9A42     		cmp	r2, r3
 3294 004c 02D2     		bcs	.L200
2157:FreeRTOS/Source/tasks.c **** 		{
2158:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 3295              		.loc 1 2158 0
 3296 004e 074B     		ldr	r3, .L203+16
 3297 0050 7A68     		ldr	r2, [r7, #4]
 3298 0052 1A60     		str	r2, [r3, #0]
 3299              	.L200:
2159:FreeRTOS/Source/tasks.c **** 		}
2160:FreeRTOS/Source/tasks.c **** 	}
2161:FreeRTOS/Source/tasks.c **** }
 3300              		.loc 1 2161 0
 3301 0054 07F10807 		add	r7, r7, #8
 3302 0058 BD46     		mov	sp, r7
 3303 005a 80BD     		pop	{r7, pc}
 3304              	.L204:
 3305              		.align	2
 3306              	.L203:
 3307 005c 00000000 		.word	pxCurrentTCB
 3308 0060 00000000 		.word	xTickCount
 3309 0064 00000000 		.word	pxOverflowDelayedTaskList
 3310 0068 00000000 		.word	pxDelayedTaskList
 3311 006c 00000000 		.word	xNextTaskUnblockTime
 3312              		.cfi_endproc
 3313              	.LFE143:
 3315              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3316              		.align	2
 3317              		.thumb
 3318              		.thumb_func
 3320              	prvAllocateTCBAndStack:
 3321              	.LFB144:
2162:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:FreeRTOS/Source/tasks.c **** 
2164:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:FreeRTOS/Source/tasks.c **** {
 3322              		.loc 1 2165 0
 3323              		.cfi_startproc
 3324              		@ args = 0, pretend = 0, frame = 16
 3325              		@ frame_needed = 1, uses_anonymous_args = 0
 3326 0000 80B5     		push	{r7, lr}
 3327              	.LCFI97:
 3328              		.cfi_def_cfa_offset 8
 3329 0002 84B0     		sub	sp, sp, #16
 3330              	.LCFI98:
 3331              		.cfi_def_cfa_offset 24
 3332 0004 00AF     		add	r7, sp, #0
 3333              		.cfi_offset 14, -4
 3334              		.cfi_offset 7, -8
 3335              	.LCFI99:
 3336              		.cfi_def_cfa_register 7
 3337 0006 0346     		mov	r3, r0
 3338 0008 3960     		str	r1, [r7, #0]
 3339 000a FB80     		strh	r3, [r7, #6]	@ movhi
2166:FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3340              		.loc 1 2170 0
 3341 000c 4FF05000 		mov	r0, #80
 3342 0010 FFF7FEFF 		bl	malloc
 3343 0014 0346     		mov	r3, r0
 3344 0016 FB60     		str	r3, [r7, #12]
2171:FreeRTOS/Source/tasks.c **** 
2172:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 3345              		.loc 1 2172 0
 3346 0018 FB68     		ldr	r3, [r7, #12]
 3347 001a 002B     		cmp	r3, #0
 3348 001c 23D0     		beq	.L206
2173:FreeRTOS/Source/tasks.c **** 	{
2174:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3349              		.loc 1 2177 0
 3350 001e 3B68     		ldr	r3, [r7, #0]
 3351 0020 002B     		cmp	r3, #0
 3352 0022 07D1     		bne	.L207
 3353              		.loc 1 2177 0 is_stmt 0 discriminator 1
 3354 0024 FB88     		ldrh	r3, [r7, #6]
 3355 0026 4FEA8303 		lsl	r3, r3, #2
 3356 002a 1846     		mov	r0, r3
 3357 002c FFF7FEFF 		bl	malloc
 3358 0030 0346     		mov	r3, r0
 3359 0032 00E0     		b	.L208
 3360              	.L207:
 3361              		.loc 1 2177 0 discriminator 2
 3362 0034 3B68     		ldr	r3, [r7, #0]
 3363              	.L208:
 3364              		.loc 1 2177 0 discriminator 3
 3365 0036 FA68     		ldr	r2, [r7, #12]
 3366 0038 1363     		str	r3, [r2, #48]
2178:FreeRTOS/Source/tasks.c **** 
2179:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3367              		.loc 1 2179 0 is_stmt 1 discriminator 3
 3368 003a FB68     		ldr	r3, [r7, #12]
 3369 003c 1B6B     		ldr	r3, [r3, #48]
 3370 003e 002B     		cmp	r3, #0
 3371 0040 06D1     		bne	.L209
2180:FreeRTOS/Source/tasks.c **** 		{
2181:FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
 3372              		.loc 1 2182 0
 3373 0042 F868     		ldr	r0, [r7, #12]
 3374 0044 FFF7FEFF 		bl	free
2183:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 3375              		.loc 1 2183 0
 3376 0048 4FF00003 		mov	r3, #0
 3377 004c FB60     		str	r3, [r7, #12]
 3378 004e 0AE0     		b	.L206
 3379              	.L209:
2184:FreeRTOS/Source/tasks.c **** 		}
2185:FreeRTOS/Source/tasks.c **** 		else
2186:FreeRTOS/Source/tasks.c **** 		{
2187:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 3380              		.loc 1 2188 0
 3381 0050 FB68     		ldr	r3, [r7, #12]
 3382 0052 1A6B     		ldr	r2, [r3, #48]
 3383 0054 FB88     		ldrh	r3, [r7, #6]
 3384 0056 4FEA8303 		lsl	r3, r3, #2
 3385 005a 1046     		mov	r0, r2
 3386 005c 4FF0A501 		mov	r1, #165
 3387 0060 1A46     		mov	r2, r3
 3388 0062 FFF7FEFF 		bl	memset
 3389              	.L206:
2189:FreeRTOS/Source/tasks.c **** 		}
2190:FreeRTOS/Source/tasks.c **** 	}
2191:FreeRTOS/Source/tasks.c **** 
2192:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
 3390              		.loc 1 2192 0
 3391 0066 FB68     		ldr	r3, [r7, #12]
2193:FreeRTOS/Source/tasks.c **** }
 3392              		.loc 1 2193 0
 3393 0068 1846     		mov	r0, r3
 3394 006a 07F11007 		add	r7, r7, #16
 3395 006e BD46     		mov	sp, r7
 3396 0070 80BD     		pop	{r7, pc}
 3397              		.cfi_endproc
 3398              	.LFE144:
 3400 0072 00BF     		.section	.rodata
 3401 000b 00       		.align	2
 3402              	.LC2:
 3403 000c 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 3403      25632020 
 3403      252D3136 
 3403      73202020 
 3403      20202020 
 3404 0032 0000     		.align	2
 3405              	.LC3:
 3406 0034 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 3406      25632020 
 3406      252D3136 
 3406      73202531 
 3406      30752025 
 3407              		.align	2
 3408              	.LC4:
 3409 0054 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 3409      25632020 
 3409      252D3136 
 3409      73202531 
 3409      30752020 
 3410              		.section	.text.prvGenerateRunTimeStatsForTasksInList,"ax",%progbits
 3411              		.align	2
 3412              		.thumb
 3413              		.thumb_func
 3415              	prvGenerateRunTimeStatsForTasksInList:
 3416              	.LFB145:
2194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:FreeRTOS/Source/tasks.c **** 
2196:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:FreeRTOS/Source/tasks.c **** 
2198:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:FreeRTOS/Source/tasks.c **** 	{
2200:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:FreeRTOS/Source/tasks.c **** 		do
2206:FreeRTOS/Source/tasks.c **** 		{
2207:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:FreeRTOS/Source/tasks.c **** 			{
2210:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:FreeRTOS/Source/tasks.c **** 			}
2212:FreeRTOS/Source/tasks.c **** 			#else
2213:FreeRTOS/Source/tasks.c **** 			{
2214:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:FreeRTOS/Source/tasks.c **** 			}
2216:FreeRTOS/Source/tasks.c **** 			#endif			
2217:FreeRTOS/Source/tasks.c **** 			
2218:FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:FreeRTOS/Source/tasks.c **** 	}
2223:FreeRTOS/Source/tasks.c **** 
2224:FreeRTOS/Source/tasks.c **** #endif
2225:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:FreeRTOS/Source/tasks.c **** 
2227:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:FreeRTOS/Source/tasks.c **** 	{
 3417              		.loc 1 2230 0
 3418              		.cfi_startproc
 3419              		@ args = 0, pretend = 0, frame = 40
 3420              		@ frame_needed = 1, uses_anonymous_args = 0
 3421 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3422              	.LCFI100:
 3423              		.cfi_def_cfa_offset 24
 3424 0004 8EB0     		sub	sp, sp, #56
 3425              	.LCFI101:
 3426              		.cfi_def_cfa_offset 80
 3427 0006 04AF     		add	r7, sp, #16
 3428              		.cfi_offset 14, -4
 3429              		.cfi_offset 8, -8
 3430              		.cfi_offset 7, -12
 3431              		.cfi_offset 6, -16
 3432              		.cfi_offset 5, -20
 3433              		.cfi_offset 4, -24
 3434              	.LCFI102:
 3435              		.cfi_def_cfa 7, 64
 3436 0008 F860     		str	r0, [r7, #12]
 3437 000a B960     		str	r1, [r7, #8]
 3438 000c 7A60     		str	r2, [r7, #4]
 3439 000e FB70     		strb	r3, [r7, #3]
 3440              	.LBB10:
2231:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:FreeRTOS/Source/tasks.c **** 
2234:FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 3441              		.loc 1 2235 0
 3442 0010 BB68     		ldr	r3, [r7, #8]
 3443 0012 7B62     		str	r3, [r7, #36]
 3444 0014 7B6A     		ldr	r3, [r7, #36]
 3445 0016 5B68     		ldr	r3, [r3, #4]
 3446 0018 5A68     		ldr	r2, [r3, #4]
 3447 001a 7B6A     		ldr	r3, [r7, #36]
 3448 001c 5A60     		str	r2, [r3, #4]
 3449 001e 7B6A     		ldr	r3, [r7, #36]
 3450 0020 5A68     		ldr	r2, [r3, #4]
 3451 0022 7B6A     		ldr	r3, [r7, #36]
 3452 0024 03F10803 		add	r3, r3, #8
 3453 0028 9A42     		cmp	r2, r3
 3454 002a 04D1     		bne	.L211
 3455              		.loc 1 2235 0 is_stmt 0 discriminator 1
 3456 002c 7B6A     		ldr	r3, [r7, #36]
 3457 002e 5B68     		ldr	r3, [r3, #4]
 3458 0030 5A68     		ldr	r2, [r3, #4]
 3459 0032 7B6A     		ldr	r3, [r7, #36]
 3460 0034 5A60     		str	r2, [r3, #4]
 3461              	.L211:
 3462              		.loc 1 2235 0 discriminator 2
 3463 0036 7B6A     		ldr	r3, [r7, #36]
 3464 0038 5B68     		ldr	r3, [r3, #4]
 3465 003a DB68     		ldr	r3, [r3, #12]
 3466 003c 3B62     		str	r3, [r7, #32]
 3467              	.L217:
 3468              	.LBE10:
 3469              	.LBB11:
2236:FreeRTOS/Source/tasks.c **** 		do
2237:FreeRTOS/Source/tasks.c **** 		{
2238:FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 3470              		.loc 1 2239 0 is_stmt 1
 3471 003e BB68     		ldr	r3, [r7, #8]
 3472 0040 FB61     		str	r3, [r7, #28]
 3473 0042 FB69     		ldr	r3, [r7, #28]
 3474 0044 5B68     		ldr	r3, [r3, #4]
 3475 0046 5A68     		ldr	r2, [r3, #4]
 3476 0048 FB69     		ldr	r3, [r7, #28]
 3477 004a 5A60     		str	r2, [r3, #4]
 3478 004c FB69     		ldr	r3, [r7, #28]
 3479 004e 5A68     		ldr	r2, [r3, #4]
 3480 0050 FB69     		ldr	r3, [r7, #28]
 3481 0052 03F10803 		add	r3, r3, #8
 3482 0056 9A42     		cmp	r2, r3
 3483 0058 04D1     		bne	.L212
 3484              		.loc 1 2239 0 is_stmt 0 discriminator 1
 3485 005a FB69     		ldr	r3, [r7, #28]
 3486 005c 5B68     		ldr	r3, [r3, #4]
 3487 005e 5A68     		ldr	r2, [r3, #4]
 3488 0060 FB69     		ldr	r3, [r7, #28]
 3489 0062 5A60     		str	r2, [r3, #4]
 3490              	.L212:
 3491              		.loc 1 2239 0 discriminator 2
 3492 0064 FB69     		ldr	r3, [r7, #28]
 3493 0066 5B68     		ldr	r3, [r3, #4]
 3494 0068 DB68     		ldr	r3, [r3, #12]
 3495 006a BB61     		str	r3, [r7, #24]
 3496              	.LBE11:
2240:FreeRTOS/Source/tasks.c **** 
2241:FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
 3497              		.loc 1 2242 0 is_stmt 1 discriminator 2
 3498 006c 7B68     		ldr	r3, [r7, #4]
 3499 006e 002B     		cmp	r3, #0
 3500 0070 5CD0     		beq	.L213
2243:FreeRTOS/Source/tasks.c **** 			{
2244:FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 3501              		.loc 1 2245 0
 3502 0072 BB69     		ldr	r3, [r7, #24]
 3503 0074 DB6C     		ldr	r3, [r3, #76]
 3504 0076 002B     		cmp	r3, #0
 3505 0078 15D1     		bne	.L214
2246:FreeRTOS/Source/tasks.c **** 				{
2247:FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
 3506              		.loc 1 2248 0
 3507 007a BB69     		ldr	r3, [r7, #24]
 3508 007c DD6A     		ldr	r5, [r3, #44]
 3509 007e 97F90340 		ldrsb	r4, [r7, #3]
 3510 0082 BB69     		ldr	r3, [r7, #24]
 3511 0084 03F13406 		add	r6, r3, #52
 3512 0088 BB69     		ldr	r3, [r7, #24]
 3513 008a 1B6B     		ldr	r3, [r3, #48]
 3514 008c 1846     		mov	r0, r3
 3515 008e FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3516 0092 0346     		mov	r3, r0
 3517 0094 0096     		str	r6, [sp, #0]
 3518 0096 0193     		str	r3, [sp, #4]
 3519 0098 2948     		ldr	r0, .L218
 3520 009a 2A49     		ldr	r1, .L218+4
 3521 009c 2A46     		mov	r2, r5
 3522 009e 2346     		mov	r3, r4
 3523 00a0 FFF7FEFF 		bl	sprintf
 3524 00a4 3DE0     		b	.L215
 3525              	.L214:
2249:FreeRTOS/Source/tasks.c **** 				}
2250:FreeRTOS/Source/tasks.c **** 				else
2251:FreeRTOS/Source/tasks.c **** 				{
2252:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 3526              		.loc 1 2255 0
 3527 00a6 BB69     		ldr	r3, [r7, #24]
 3528 00a8 DA6C     		ldr	r2, [r3, #76]
 3529 00aa 7B68     		ldr	r3, [r7, #4]
 3530 00ac B2FBF3F3 		udiv	r3, r2, r3
 3531 00b0 7B61     		str	r3, [r7, #20]
2256:FreeRTOS/Source/tasks.c **** 
2257:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 3532              		.loc 1 2257 0
 3533 00b2 7B69     		ldr	r3, [r7, #20]
 3534 00b4 002B     		cmp	r3, #0
 3535 00b6 1BD0     		beq	.L216
2258:FreeRTOS/Source/tasks.c **** 					{
2259:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:FreeRTOS/Source/tasks.c **** 						{
2261:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:FreeRTOS/Source/tasks.c **** 						}
2263:FreeRTOS/Source/tasks.c **** 						#else
2264:FreeRTOS/Source/tasks.c **** 						{
2265:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
 3536              		.loc 1 2267 0
 3537 00b8 BB69     		ldr	r3, [r7, #24]
 3538 00ba DD6A     		ldr	r5, [r3, #44]
 3539 00bc 97F90340 		ldrsb	r4, [r7, #3]
 3540 00c0 BB69     		ldr	r3, [r7, #24]
 3541 00c2 03F13408 		add	r8, r3, #52
 3542 00c6 BB69     		ldr	r3, [r7, #24]
 3543 00c8 DE6C     		ldr	r6, [r3, #76]
 3544 00ca BB69     		ldr	r3, [r7, #24]
 3545 00cc 1B6B     		ldr	r3, [r3, #48]
 3546 00ce 1846     		mov	r0, r3
 3547 00d0 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3548 00d4 0346     		mov	r3, r0
 3549 00d6 CDF80080 		str	r8, [sp, #0]
 3550 00da 0196     		str	r6, [sp, #4]
 3551 00dc 7A69     		ldr	r2, [r7, #20]
 3552 00de 0292     		str	r2, [sp, #8]
 3553 00e0 0393     		str	r3, [sp, #12]
 3554 00e2 1748     		ldr	r0, .L218
 3555 00e4 1849     		ldr	r1, .L218+8
 3556 00e6 2A46     		mov	r2, r5
 3557 00e8 2346     		mov	r3, r4
 3558 00ea FFF7FEFF 		bl	sprintf
 3559 00ee 18E0     		b	.L215
 3560              	.L216:
2268:FreeRTOS/Source/tasks.c **** 						}
2269:FreeRTOS/Source/tasks.c **** 						#endif
2270:FreeRTOS/Source/tasks.c **** 					}
2271:FreeRTOS/Source/tasks.c **** 					else
2272:FreeRTOS/Source/tasks.c **** 					{
2273:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:FreeRTOS/Source/tasks.c **** 						{
2277:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:FreeRTOS/Source/tasks.c **** 						}
2279:FreeRTOS/Source/tasks.c **** 						#else
2280:FreeRTOS/Source/tasks.c **** 						{
2281:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
 3561              		.loc 1 2283 0
 3562 00f0 BB69     		ldr	r3, [r7, #24]
 3563 00f2 DD6A     		ldr	r5, [r3, #44]
 3564 00f4 97F90340 		ldrsb	r4, [r7, #3]
 3565 00f8 BB69     		ldr	r3, [r7, #24]
 3566 00fa 03F13408 		add	r8, r3, #52
 3567 00fe BB69     		ldr	r3, [r7, #24]
 3568 0100 DE6C     		ldr	r6, [r3, #76]
 3569 0102 BB69     		ldr	r3, [r7, #24]
 3570 0104 1B6B     		ldr	r3, [r3, #48]
 3571 0106 1846     		mov	r0, r3
 3572 0108 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3573 010c 0346     		mov	r3, r0
 3574 010e CDF80080 		str	r8, [sp, #0]
 3575 0112 0196     		str	r6, [sp, #4]
 3576 0114 0293     		str	r3, [sp, #8]
 3577 0116 0A48     		ldr	r0, .L218
 3578 0118 0C49     		ldr	r1, .L218+12
 3579 011a 2A46     		mov	r2, r5
 3580 011c 2346     		mov	r3, r4
 3581 011e FFF7FEFF 		bl	sprintf
 3582              	.L215:
2284:FreeRTOS/Source/tasks.c **** 						}
2285:FreeRTOS/Source/tasks.c **** 						#endif
2286:FreeRTOS/Source/tasks.c **** 					}
2287:FreeRTOS/Source/tasks.c **** 				}
2288:FreeRTOS/Source/tasks.c **** 
2289:FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 3583              		.loc 1 2289 0
 3584 0122 FB68     		ldr	r3, [r7, #12]
 3585 0124 1846     		mov	r0, r3
 3586 0126 0649     		ldr	r1, .L218
 3587 0128 FFF7FEFF 		bl	strcat
 3588              	.L213:
2290:FreeRTOS/Source/tasks.c **** 			}
2291:FreeRTOS/Source/tasks.c **** 
2292:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 3589              		.loc 1 2292 0
 3590 012c BA69     		ldr	r2, [r7, #24]
 3591 012e 3B6A     		ldr	r3, [r7, #32]
 3592 0130 9A42     		cmp	r2, r3
 3593 0132 84D1     		bne	.L217
2293:FreeRTOS/Source/tasks.c **** 	}
 3594              		.loc 1 2293 0
 3595 0134 07F12807 		add	r7, r7, #40
 3596 0138 BD46     		mov	sp, r7
 3597 013a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3598              	.L219:
 3599 013e 00BF     		.align	2
 3600              	.L218:
 3601 0140 00000000 		.word	pcStatsString
 3602 0144 0C000000 		.word	.LC2
 3603 0148 34000000 		.word	.LC3
 3604 014c 54000000 		.word	.LC4
 3605              		.cfi_endproc
 3606              	.LFE145:
 3608              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
 3609              		.align	2
 3610              		.thumb
 3611              		.thumb_func
 3613              	usTaskCheckFreeStackSpace:
 3614              	.LFB146:
2294:FreeRTOS/Source/tasks.c **** 
2295:FreeRTOS/Source/tasks.c **** #endif
2296:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:FreeRTOS/Source/tasks.c **** 
2298:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:FreeRTOS/Source/tasks.c **** 	{
 3615              		.loc 1 2301 0
 3616              		.cfi_startproc
 3617              		@ args = 0, pretend = 0, frame = 8
 3618              		@ frame_needed = 1, uses_anonymous_args = 0
 3619              		@ link register save eliminated.
 3620 0000 90B4     		push	{r4, r7}
 3621              	.LCFI103:
 3622              		.cfi_def_cfa_offset 8
 3623 0002 82B0     		sub	sp, sp, #8
 3624              	.LCFI104:
 3625              		.cfi_def_cfa_offset 16
 3626 0004 00AF     		add	r7, sp, #0
 3627              		.cfi_offset 7, -4
 3628              		.cfi_offset 4, -8
 3629              	.LCFI105:
 3630              		.cfi_def_cfa_register 7
 3631 0006 7860     		str	r0, [r7, #4]
2302:FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
 3632              		.loc 1 2302 0
 3633 0008 4FF00004 		mov	r4, #0
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3634              		.loc 1 2304 0
 3635 000c 06E0     		b	.L221
 3636              	.L222:
2305:FreeRTOS/Source/tasks.c **** 		{
2306:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3637              		.loc 1 2306 0
 3638 000e 7B68     		ldr	r3, [r7, #4]
 3639 0010 03F10103 		add	r3, r3, #1
 3640 0014 7B60     		str	r3, [r7, #4]
2307:FreeRTOS/Source/tasks.c **** 			usCount++;
 3641              		.loc 1 2307 0
 3642 0016 04F10103 		add	r3, r4, #1
 3643 001a 9CB2     		uxth	r4, r3
 3644              	.L221:
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 3645              		.loc 1 2304 0 discriminator 1
 3646 001c 7B68     		ldr	r3, [r7, #4]
 3647 001e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 3648 0020 A52B     		cmp	r3, #165
 3649 0022 F4D0     		beq	.L222
2308:FreeRTOS/Source/tasks.c **** 		}
2309:FreeRTOS/Source/tasks.c **** 
2310:FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 3650              		.loc 1 2310 0
 3651 0024 4FEA9403 		lsr	r3, r4, #2
 3652 0028 9CB2     		uxth	r4, r3
2311:FreeRTOS/Source/tasks.c **** 
2312:FreeRTOS/Source/tasks.c **** 		return usCount;
 3653              		.loc 1 2312 0
 3654 002a 2346     		mov	r3, r4
2313:FreeRTOS/Source/tasks.c **** 	}
 3655              		.loc 1 2313 0
 3656 002c 1846     		mov	r0, r3
 3657 002e 07F10807 		add	r7, r7, #8
 3658 0032 BD46     		mov	sp, r7
 3659 0034 90BC     		pop	{r4, r7}
 3660 0036 7047     		bx	lr
 3661              		.cfi_endproc
 3662              	.LFE146:
 3664              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3665              		.align	2
 3666              		.global	uxTaskGetStackHighWaterMark
 3667              		.thumb
 3668              		.thumb_func
 3670              	uxTaskGetStackHighWaterMark:
 3671              	.LFB147:
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** #endif
2316:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:FreeRTOS/Source/tasks.c **** 
2318:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:FreeRTOS/Source/tasks.c **** 
2320:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:FreeRTOS/Source/tasks.c **** 	{
 3672              		.loc 1 2321 0
 3673              		.cfi_startproc
 3674              		@ args = 0, pretend = 0, frame = 24
 3675              		@ frame_needed = 1, uses_anonymous_args = 0
 3676 0000 80B5     		push	{r7, lr}
 3677              	.LCFI106:
 3678              		.cfi_def_cfa_offset 8
 3679 0002 86B0     		sub	sp, sp, #24
 3680              	.LCFI107:
 3681              		.cfi_def_cfa_offset 32
 3682 0004 00AF     		add	r7, sp, #0
 3683              		.cfi_offset 14, -4
 3684              		.cfi_offset 7, -8
 3685              	.LCFI108:
 3686              		.cfi_def_cfa_register 7
 3687 0006 7860     		str	r0, [r7, #4]
2322:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:FreeRTOS/Source/tasks.c **** 
2326:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3688              		.loc 1 2326 0
 3689 0008 7B68     		ldr	r3, [r7, #4]
 3690 000a 002B     		cmp	r3, #0
 3691 000c 02D1     		bne	.L224
 3692              		.loc 1 2326 0 is_stmt 0 discriminator 1
 3693 000e 094B     		ldr	r3, .L226
 3694 0010 1B68     		ldr	r3, [r3, #0]
 3695 0012 00E0     		b	.L225
 3696              	.L224:
 3697              		.loc 1 2326 0 discriminator 2
 3698 0014 7B68     		ldr	r3, [r7, #4]
 3699              	.L225:
 3700              		.loc 1 2326 0 discriminator 3
 3701 0016 7B61     		str	r3, [r7, #20]
2327:FreeRTOS/Source/tasks.c **** 
2328:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:FreeRTOS/Source/tasks.c **** 		{
2330:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 3702              		.loc 1 2330 0 is_stmt 1 discriminator 3
 3703 0018 7B69     		ldr	r3, [r7, #20]
 3704 001a 1B6B     		ldr	r3, [r3, #48]
 3705 001c 3B61     		str	r3, [r7, #16]
2331:FreeRTOS/Source/tasks.c **** 		}
2332:FreeRTOS/Source/tasks.c **** 		#else
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:FreeRTOS/Source/tasks.c **** 		}
2336:FreeRTOS/Source/tasks.c **** 		#endif
2337:FreeRTOS/Source/tasks.c **** 
2338:FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 3706              		.loc 1 2338 0 discriminator 3
 3707 001e 3869     		ldr	r0, [r7, #16]
 3708 0020 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 3709 0024 0346     		mov	r3, r0
 3710 0026 FB60     		str	r3, [r7, #12]
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 3711              		.loc 1 2340 0 discriminator 3
 3712 0028 FB68     		ldr	r3, [r7, #12]
2341:FreeRTOS/Source/tasks.c **** 	}
 3713              		.loc 1 2341 0 discriminator 3
 3714 002a 1846     		mov	r0, r3
 3715 002c 07F11807 		add	r7, r7, #24
 3716 0030 BD46     		mov	sp, r7
 3717 0032 80BD     		pop	{r7, pc}
 3718              	.L227:
 3719              		.align	2
 3720              	.L226:
 3721 0034 00000000 		.word	pxCurrentTCB
 3722              		.cfi_endproc
 3723              	.LFE147:
 3725              		.section	.text.prvDeleteTCB,"ax",%progbits
 3726              		.align	2
 3727              		.thumb
 3728              		.thumb_func
 3730              	prvDeleteTCB:
 3731              	.LFB148:
2342:FreeRTOS/Source/tasks.c **** 
2343:FreeRTOS/Source/tasks.c **** #endif
2344:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:FreeRTOS/Source/tasks.c **** 
2348:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:FreeRTOS/Source/tasks.c **** 	{
 3732              		.loc 1 2349 0
 3733              		.cfi_startproc
 3734              		@ args = 0, pretend = 0, frame = 8
 3735              		@ frame_needed = 1, uses_anonymous_args = 0
 3736 0000 80B5     		push	{r7, lr}
 3737              	.LCFI109:
 3738              		.cfi_def_cfa_offset 8
 3739 0002 82B0     		sub	sp, sp, #8
 3740              	.LCFI110:
 3741              		.cfi_def_cfa_offset 16
 3742 0004 00AF     		add	r7, sp, #0
 3743              		.cfi_offset 14, -4
 3744              		.cfi_offset 7, -8
 3745              	.LCFI111:
 3746              		.cfi_def_cfa_register 7
 3747 0006 7860     		str	r0, [r7, #4]
2350:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3748              		.loc 1 2352 0
 3749 0008 7B68     		ldr	r3, [r7, #4]
 3750 000a 1B6B     		ldr	r3, [r3, #48]
 3751 000c 1846     		mov	r0, r3
 3752 000e FFF7FEFF 		bl	free
2353:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
 3753              		.loc 1 2353 0
 3754 0012 7868     		ldr	r0, [r7, #4]
 3755 0014 FFF7FEFF 		bl	free
2354:FreeRTOS/Source/tasks.c **** 	}
 3756              		.loc 1 2354 0
 3757 0018 07F10807 		add	r7, r7, #8
 3758 001c BD46     		mov	sp, r7
 3759 001e 80BD     		pop	{r7, pc}
 3760              		.cfi_endproc
 3761              	.LFE148:
 3763              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3764              		.align	2
 3765              		.global	xTaskGetCurrentTaskHandle
 3766              		.thumb
 3767              		.thumb_func
 3769              	xTaskGetCurrentTaskHandle:
 3770              	.LFB149:
2355:FreeRTOS/Source/tasks.c **** 
2356:FreeRTOS/Source/tasks.c **** #endif
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** 
2359:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:FreeRTOS/Source/tasks.c **** 
2361:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:FreeRTOS/Source/tasks.c **** 
2363:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:FreeRTOS/Source/tasks.c **** 	{
 3771              		.loc 1 2364 0
 3772              		.cfi_startproc
 3773              		@ args = 0, pretend = 0, frame = 8
 3774              		@ frame_needed = 1, uses_anonymous_args = 0
 3775              		@ link register save eliminated.
 3776 0000 80B4     		push	{r7}
 3777              	.LCFI112:
 3778              		.cfi_def_cfa_offset 4
 3779 0002 83B0     		sub	sp, sp, #12
 3780              	.LCFI113:
 3781              		.cfi_def_cfa_offset 16
 3782 0004 00AF     		add	r7, sp, #0
 3783              		.cfi_offset 7, -4
 3784              	.LCFI114:
 3785              		.cfi_def_cfa_register 7
2365:FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:FreeRTOS/Source/tasks.c **** 
2367:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3786              		.loc 1 2370 0
 3787 0006 054B     		ldr	r3, .L230
 3788 0008 1B68     		ldr	r3, [r3, #0]
 3789 000a 7B60     		str	r3, [r7, #4]
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 		return xReturn;
 3790              		.loc 1 2372 0
 3791 000c 7B68     		ldr	r3, [r7, #4]
2373:FreeRTOS/Source/tasks.c **** 	}
 3792              		.loc 1 2373 0
 3793 000e 1846     		mov	r0, r3
 3794 0010 07F10C07 		add	r7, r7, #12
 3795 0014 BD46     		mov	sp, r7
 3796 0016 80BC     		pop	{r7}
 3797 0018 7047     		bx	lr
 3798              	.L231:
 3799 001a 00BF     		.align	2
 3800              	.L230:
 3801 001c 00000000 		.word	pxCurrentTCB
 3802              		.cfi_endproc
 3803              	.LFE149:
 3805              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3806              		.align	2
 3807              		.global	vTaskPriorityInherit
 3808              		.thumb
 3809              		.thumb_func
 3811              	vTaskPriorityInherit:
 3812              	.LFB150:
2374:FreeRTOS/Source/tasks.c **** 
2375:FreeRTOS/Source/tasks.c **** #endif
2376:FreeRTOS/Source/tasks.c **** 
2377:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:FreeRTOS/Source/tasks.c **** 	{
2383:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:FreeRTOS/Source/tasks.c **** 		{
2387:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:FreeRTOS/Source/tasks.c **** 		}
2389:FreeRTOS/Source/tasks.c **** 		else
2390:FreeRTOS/Source/tasks.c **** 		{
2391:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:FreeRTOS/Source/tasks.c **** 			{
2393:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:FreeRTOS/Source/tasks.c **** 			}
2395:FreeRTOS/Source/tasks.c **** 			else
2396:FreeRTOS/Source/tasks.c **** 			{
2397:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:FreeRTOS/Source/tasks.c **** 			}
2399:FreeRTOS/Source/tasks.c **** 		}
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:FreeRTOS/Source/tasks.c **** 	}
2403:FreeRTOS/Source/tasks.c **** 
2404:FreeRTOS/Source/tasks.c **** #endif
2405:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:FreeRTOS/Source/tasks.c **** 
2409:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:FreeRTOS/Source/tasks.c **** 	{
 3813              		.loc 1 2410 0
 3814              		.cfi_startproc
 3815              		@ args = 0, pretend = 0, frame = 16
 3816              		@ frame_needed = 1, uses_anonymous_args = 0
 3817 0000 80B5     		push	{r7, lr}
 3818              	.LCFI115:
 3819              		.cfi_def_cfa_offset 8
 3820 0002 84B0     		sub	sp, sp, #16
 3821              	.LCFI116:
 3822              		.cfi_def_cfa_offset 24
 3823 0004 00AF     		add	r7, sp, #0
 3824              		.cfi_offset 14, -4
 3825              		.cfi_offset 7, -8
 3826              	.LCFI117:
 3827              		.cfi_def_cfa_register 7
 3828 0006 7860     		str	r0, [r7, #4]
2411:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3829              		.loc 1 2411 0
 3830 0008 7B68     		ldr	r3, [r7, #4]
 3831 000a FB60     		str	r3, [r7, #12]
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3832              		.loc 1 2415 0
 3833 000c FB68     		ldr	r3, [r7, #12]
 3834 000e DA6A     		ldr	r2, [r3, #44]
 3835 0010 254B     		ldr	r3, .L236
 3836 0012 1B68     		ldr	r3, [r3, #0]
 3837 0014 DB6A     		ldr	r3, [r3, #44]
 3838 0016 9A42     		cmp	r2, r3
 3839 0018 42D2     		bcs	.L232
2416:FreeRTOS/Source/tasks.c **** 		{
2417:FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3840              		.loc 1 2418 0
 3841 001a 234B     		ldr	r3, .L236
 3842 001c 1B68     		ldr	r3, [r3, #0]
 3843 001e DB6A     		ldr	r3, [r3, #44]
 3844 0020 C3F10502 		rsb	r2, r3, #5
 3845 0024 FB68     		ldr	r3, [r7, #12]
 3846 0026 9A61     		str	r2, [r3, #24]
2419:FreeRTOS/Source/tasks.c **** 
2420:FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3847              		.loc 1 2422 0
 3848 0028 FB68     		ldr	r3, [r7, #12]
 3849 002a 5969     		ldr	r1, [r3, #20]
 3850 002c FB68     		ldr	r3, [r7, #12]
 3851 002e DA6A     		ldr	r2, [r3, #44]
 3852 0030 1346     		mov	r3, r2
 3853 0032 4FEA8303 		lsl	r3, r3, #2
 3854 0036 9B18     		adds	r3, r3, r2
 3855 0038 4FEA8303 		lsl	r3, r3, #2
 3856 003c 1A46     		mov	r2, r3
 3857 003e 1B4B     		ldr	r3, .L236+4
 3858 0040 D318     		adds	r3, r2, r3
 3859 0042 9942     		cmp	r1, r3
 3860 0044 27D1     		bne	.L234
2423:FreeRTOS/Source/tasks.c **** 			{
2424:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3861              		.loc 1 2424 0
 3862 0046 FB68     		ldr	r3, [r7, #12]
 3863 0048 03F10403 		add	r3, r3, #4
 3864 004c 1846     		mov	r0, r3
 3865 004e FFF7FEFF 		bl	vListRemove
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3866              		.loc 1 2427 0
 3867 0052 154B     		ldr	r3, .L236
 3868 0054 1B68     		ldr	r3, [r3, #0]
 3869 0056 DA6A     		ldr	r2, [r3, #44]
 3870 0058 FB68     		ldr	r3, [r7, #12]
 3871 005a DA62     		str	r2, [r3, #44]
2428:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3872              		.loc 1 2428 0
 3873 005c FB68     		ldr	r3, [r7, #12]
 3874 005e DA6A     		ldr	r2, [r3, #44]
 3875 0060 134B     		ldr	r3, .L236+8
 3876 0062 1B68     		ldr	r3, [r3, #0]
 3877 0064 9A42     		cmp	r2, r3
 3878 0066 03D9     		bls	.L235
 3879              		.loc 1 2428 0 is_stmt 0 discriminator 1
 3880 0068 FB68     		ldr	r3, [r7, #12]
 3881 006a DA6A     		ldr	r2, [r3, #44]
 3882 006c 104B     		ldr	r3, .L236+8
 3883 006e 1A60     		str	r2, [r3, #0]
 3884              	.L235:
 3885              		.loc 1 2428 0 discriminator 2
 3886 0070 FB68     		ldr	r3, [r7, #12]
 3887 0072 DA6A     		ldr	r2, [r3, #44]
 3888 0074 1346     		mov	r3, r2
 3889 0076 4FEA8303 		lsl	r3, r3, #2
 3890 007a 9B18     		adds	r3, r3, r2
 3891 007c 4FEA8303 		lsl	r3, r3, #2
 3892 0080 1A46     		mov	r2, r3
 3893 0082 0A4B     		ldr	r3, .L236+4
 3894 0084 D218     		adds	r2, r2, r3
 3895 0086 FB68     		ldr	r3, [r7, #12]
 3896 0088 03F10403 		add	r3, r3, #4
 3897 008c 1046     		mov	r0, r2
 3898 008e 1946     		mov	r1, r3
 3899 0090 FFF7FEFF 		bl	vListInsertEnd
 3900 0094 04E0     		b	.L232
 3901              	.L234:
2429:FreeRTOS/Source/tasks.c **** 			}
2430:FreeRTOS/Source/tasks.c **** 			else
2431:FreeRTOS/Source/tasks.c **** 			{
2432:FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3902              		.loc 1 2433 0 is_stmt 1
 3903 0096 044B     		ldr	r3, .L236
 3904 0098 1B68     		ldr	r3, [r3, #0]
 3905 009a DA6A     		ldr	r2, [r3, #44]
 3906 009c FB68     		ldr	r3, [r7, #12]
 3907 009e DA62     		str	r2, [r3, #44]
 3908              	.L232:
2434:FreeRTOS/Source/tasks.c **** 			}
2435:FreeRTOS/Source/tasks.c **** 		}
2436:FreeRTOS/Source/tasks.c **** 	}
 3909              		.loc 1 2436 0
 3910 00a0 07F11007 		add	r7, r7, #16
 3911 00a4 BD46     		mov	sp, r7
 3912 00a6 80BD     		pop	{r7, pc}
 3913              	.L237:
 3914              		.align	2
 3915              	.L236:
 3916 00a8 00000000 		.word	pxCurrentTCB
 3917 00ac 00000000 		.word	pxReadyTasksLists
 3918 00b0 00000000 		.word	uxTopReadyPriority
 3919              		.cfi_endproc
 3920              	.LFE150:
 3922              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3923              		.align	2
 3924              		.global	vTaskPriorityDisinherit
 3925              		.thumb
 3926              		.thumb_func
 3928              	vTaskPriorityDisinherit:
 3929              	.LFB151:
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #endif
2439:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:FreeRTOS/Source/tasks.c **** 
2441:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:FreeRTOS/Source/tasks.c **** 
2443:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:FreeRTOS/Source/tasks.c **** 	{
 3930              		.loc 1 2444 0
 3931              		.cfi_startproc
 3932              		@ args = 0, pretend = 0, frame = 16
 3933              		@ frame_needed = 1, uses_anonymous_args = 0
 3934 0000 80B5     		push	{r7, lr}
 3935              	.LCFI118:
 3936              		.cfi_def_cfa_offset 8
 3937 0002 84B0     		sub	sp, sp, #16
 3938              	.LCFI119:
 3939              		.cfi_def_cfa_offset 24
 3940 0004 00AF     		add	r7, sp, #0
 3941              		.cfi_offset 14, -4
 3942              		.cfi_offset 7, -8
 3943              	.LCFI120:
 3944              		.cfi_def_cfa_register 7
 3945 0006 7860     		str	r0, [r7, #4]
2445:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3946              		.loc 1 2445 0
 3947 0008 7B68     		ldr	r3, [r7, #4]
 3948 000a FB60     		str	r3, [r7, #12]
2446:FreeRTOS/Source/tasks.c **** 
2447:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3949              		.loc 1 2447 0
 3950 000c 7B68     		ldr	r3, [r7, #4]
 3951 000e 002B     		cmp	r3, #0
 3952 0010 31D0     		beq	.L238
2448:FreeRTOS/Source/tasks.c **** 		{
2449:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3953              		.loc 1 2449 0
 3954 0012 FB68     		ldr	r3, [r7, #12]
 3955 0014 DA6A     		ldr	r2, [r3, #44]
 3956 0016 FB68     		ldr	r3, [r7, #12]
 3957 0018 5B6C     		ldr	r3, [r3, #68]
 3958 001a 9A42     		cmp	r2, r3
 3959 001c 2BD0     		beq	.L238
2450:FreeRTOS/Source/tasks.c **** 			{
2451:FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3960              		.loc 1 2453 0
 3961 001e FB68     		ldr	r3, [r7, #12]
 3962 0020 03F10403 		add	r3, r3, #4
 3963 0024 1846     		mov	r0, r3
 3964 0026 FFF7FEFF 		bl	vListRemove
2454:FreeRTOS/Source/tasks.c **** 
2455:FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:FreeRTOS/Source/tasks.c **** 				ready list. */
2457:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3965              		.loc 1 2457 0
 3966 002a FB68     		ldr	r3, [r7, #12]
 3967 002c 5A6C     		ldr	r2, [r3, #68]
 3968 002e FB68     		ldr	r3, [r7, #12]
 3969 0030 DA62     		str	r2, [r3, #44]
2458:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3970              		.loc 1 2458 0
 3971 0032 FB68     		ldr	r3, [r7, #12]
 3972 0034 DB6A     		ldr	r3, [r3, #44]
 3973 0036 C3F10502 		rsb	r2, r3, #5
 3974 003a FB68     		ldr	r3, [r7, #12]
 3975 003c 9A61     		str	r2, [r3, #24]
2459:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3976              		.loc 1 2459 0
 3977 003e FB68     		ldr	r3, [r7, #12]
 3978 0040 DA6A     		ldr	r2, [r3, #44]
 3979 0042 0F4B     		ldr	r3, .L241
 3980 0044 1B68     		ldr	r3, [r3, #0]
 3981 0046 9A42     		cmp	r2, r3
 3982 0048 03D9     		bls	.L240
 3983              		.loc 1 2459 0 is_stmt 0 discriminator 1
 3984 004a FB68     		ldr	r3, [r7, #12]
 3985 004c DA6A     		ldr	r2, [r3, #44]
 3986 004e 0C4B     		ldr	r3, .L241
 3987 0050 1A60     		str	r2, [r3, #0]
 3988              	.L240:
 3989              		.loc 1 2459 0 discriminator 2
 3990 0052 FB68     		ldr	r3, [r7, #12]
 3991 0054 DA6A     		ldr	r2, [r3, #44]
 3992 0056 1346     		mov	r3, r2
 3993 0058 4FEA8303 		lsl	r3, r3, #2
 3994 005c 9B18     		adds	r3, r3, r2
 3995 005e 4FEA8303 		lsl	r3, r3, #2
 3996 0062 1A46     		mov	r2, r3
 3997 0064 074B     		ldr	r3, .L241+4
 3998 0066 D218     		adds	r2, r2, r3
 3999 0068 FB68     		ldr	r3, [r7, #12]
 4000 006a 03F10403 		add	r3, r3, #4
 4001 006e 1046     		mov	r0, r2
 4002 0070 1946     		mov	r1, r3
 4003 0072 FFF7FEFF 		bl	vListInsertEnd
 4004              	.L238:
2460:FreeRTOS/Source/tasks.c **** 			}
2461:FreeRTOS/Source/tasks.c **** 		}
2462:FreeRTOS/Source/tasks.c **** 	}
 4005              		.loc 1 2462 0 is_stmt 1
 4006 0076 07F11007 		add	r7, r7, #16
 4007 007a BD46     		mov	sp, r7
 4008 007c 80BD     		pop	{r7, pc}
 4009              	.L242:
 4010 007e 00BF     		.align	2
 4011              	.L241:
 4012 0080 00000000 		.word	uxTopReadyPriority
 4013 0084 00000000 		.word	pxReadyTasksLists
 4014              		.cfi_endproc
 4015              	.LFE151:
 4017              		.text
 4018              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccnMoWm4.s:29     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccnMoWm4.s:26     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccnMoWm4.s:32     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccnMoWm4.s:35     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccnMoWm4.s:38     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccnMoWm4.s:41     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccnMoWm4.s:44     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccnMoWm4.s:47     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccnMoWm4.s:50     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccnMoWm4.s:53     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccnMoWm4.s:56     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccnMoWm4.s:59     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccnMoWm4.s:62     .bss.xPendingReadyList:00000000 $d
     /tmp/ccnMoWm4.s:65     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccnMoWm4.s:68     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccnMoWm4.s:71     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccnMoWm4.s:74     .bss.uxTasksDeleted:00000000 $d
     /tmp/ccnMoWm4.s:77     .bss.uxTasksDeleted:00000000 uxTasksDeleted
     /tmp/ccnMoWm4.s:80     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccnMoWm4.s:83     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccnMoWm4.s:86     .bss.xIdleTaskHandle:00000000 $d
     /tmp/ccnMoWm4.s:89     .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
     /tmp/ccnMoWm4.s:92     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccnMoWm4.s:95     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccnMoWm4.s:98     .bss.xTickCount:00000000 $d
     /tmp/ccnMoWm4.s:101    .bss.xTickCount:00000000 xTickCount
     /tmp/ccnMoWm4.s:104    .bss.uxTopUsedPriority:00000000 $d
     /tmp/ccnMoWm4.s:107    .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
     /tmp/ccnMoWm4.s:110    .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccnMoWm4.s:113    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccnMoWm4.s:116    .bss.xSchedulerRunning:00000000 $d
     /tmp/ccnMoWm4.s:119    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccnMoWm4.s:122    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccnMoWm4.s:125    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccnMoWm4.s:128    .bss.uxMissedTicks:00000000 $d
     /tmp/ccnMoWm4.s:131    .bss.uxMissedTicks:00000000 uxMissedTicks
     /tmp/ccnMoWm4.s:134    .bss.xMissedYield:00000000 $d
     /tmp/ccnMoWm4.s:137    .bss.xMissedYield:00000000 xMissedYield
     /tmp/ccnMoWm4.s:140    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccnMoWm4.s:143    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccnMoWm4.s:146    .bss.uxTaskNumber:00000000 $d
     /tmp/ccnMoWm4.s:149    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccnMoWm4.s:152    .data.xNextTaskUnblockTime:00000000 $d
     /tmp/ccnMoWm4.s:155    .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccnMoWm4.s:158    .bss.pcStatsString:00000000 $d
     /tmp/ccnMoWm4.s:161    .bss.pcStatsString:00000000 pcStatsString
     /tmp/ccnMoWm4.s:164    .bss.ulTaskSwitchedInTime:00000000 $d
     /tmp/ccnMoWm4.s:167    .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
     /tmp/ccnMoWm4.s:170    .text.xTaskGenericCreate:00000000 $t
     /tmp/ccnMoWm4.s:175    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
     /tmp/ccnMoWm4.s:3320   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
     /tmp/ccnMoWm4.s:2969   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
     /tmp/ccnMoWm4.s:3062   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccnMoWm4.s:378    .text.xTaskGenericCreate:00000144 $d
     /tmp/ccnMoWm4.s:389    .text.vTaskDelete:00000000 $t
     /tmp/ccnMoWm4.s:394    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccnMoWm4.s:493    .text.vTaskDelete:00000090 $d
     /tmp/ccnMoWm4.s:502    .text.vTaskDelayUntil:00000000 $t
     /tmp/ccnMoWm4.s:507    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
     /tmp/ccnMoWm4.s:1463   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccnMoWm4.s:3240   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccnMoWm4.s:1500   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccnMoWm4.s:613    .text.vTaskDelayUntil:00000098 $d
     /tmp/ccnMoWm4.s:619    .text.vTaskDelay:00000000 $t
     /tmp/ccnMoWm4.s:624    .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccnMoWm4.s:684    .text.vTaskDelay:00000050 $d
     /tmp/ccnMoWm4.s:690    .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccnMoWm4.s:695    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccnMoWm4.s:745    .text.uxTaskPriorityGet:00000034 $d
     /tmp/ccnMoWm4.s:750    .text.vTaskPrioritySet:00000000 $t
     /tmp/ccnMoWm4.s:755    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccnMoWm4.s:926    .text.vTaskPrioritySet:00000108 $d
     /tmp/ccnMoWm4.s:933    .text.vTaskSuspend:00000000 $t
     /tmp/ccnMoWm4.s:938    .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccnMoWm4.s:2405   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccnMoWm4.s:1042   .text.vTaskSuspend:00000094 $d
     /tmp/ccnMoWm4.s:1050   .text.xTaskIsTaskSuspended:00000000 $t
     /tmp/ccnMoWm4.s:1055   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
     /tmp/ccnMoWm4.s:1111   .text.xTaskIsTaskSuspended:00000044 $d
     /tmp/ccnMoWm4.s:1117   .text.vTaskResume:00000000 $t
     /tmp/ccnMoWm4.s:1122   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccnMoWm4.s:1215   .text.vTaskResume:00000090 $d
     /tmp/ccnMoWm4.s:1222   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccnMoWm4.s:1227   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccnMoWm4.s:1325   .text.xTaskResumeFromISR:0000009c $d
     /tmp/ccnMoWm4.s:1334   .rodata:00000000 $d
     /tmp/ccnMoWm4.s:1338   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccnMoWm4.s:1343   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccnMoWm4.s:1407   .text.vTaskStartScheduler:00000060 $d
     /tmp/ccnMoWm4.s:2923   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccnMoWm4.s:1416   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccnMoWm4.s:1421   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccnMoWm4.s:1453   .text.vTaskEndScheduler:0000001c $d
     /tmp/ccnMoWm4.s:1458   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccnMoWm4.s:1490   .text.vTaskSuspendAll:00000018 $d
     /tmp/ccnMoWm4.s:1495   .text.xTaskResumeAll:00000000 $t
     /tmp/ccnMoWm4.s:2020   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
     /tmp/ccnMoWm4.s:1658   .text.xTaskResumeAll:000000f4 $d
     /tmp/ccnMoWm4.s:1670   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccnMoWm4.s:1675   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccnMoWm4.s:1710   .text.xTaskGetTickCount:00000020 $d
     /tmp/ccnMoWm4.s:1715   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccnMoWm4.s:1720   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccnMoWm4.s:1768   .text.xTaskGetTickCountFromISR:00000030 $d
     /tmp/ccnMoWm4.s:1773   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccnMoWm4.s:1778   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccnMoWm4.s:1803   .text.uxTaskGetNumberOfTasks:00000010 $d
     /tmp/ccnMoWm4.s:1812   .text.vTaskGetRunTimeStats:00000000 $t
     /tmp/ccnMoWm4.s:1817   .text.vTaskGetRunTimeStats:00000000 vTaskGetRunTimeStats
     /tmp/ccnMoWm4.s:3415   .text.prvGenerateRunTimeStatsForTasksInList:00000000 prvGenerateRunTimeStatsForTasksInList
     /tmp/ccnMoWm4.s:1968   .text.vTaskGetRunTimeStats:0000010c $d
     /tmp/ccnMoWm4.s:1980   .text.xTaskGetIdleTaskHandle:00000000 $t
     /tmp/ccnMoWm4.s:1985   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
     /tmp/ccnMoWm4.s:2010   .text.xTaskGetIdleTaskHandle:00000010 $d
     /tmp/ccnMoWm4.s:2015   .text.vTaskIncrementTick:00000000 $t
     /tmp/ccnMoWm4.s:2199   .text.vTaskIncrementTick:00000118 $d
     /tmp/ccnMoWm4.s:2212   .text.vTaskSetApplicationTaskTag:00000000 $t
     /tmp/ccnMoWm4.s:2217   .text.vTaskSetApplicationTaskTag:00000000 vTaskSetApplicationTaskTag
     /tmp/ccnMoWm4.s:2265   .text.vTaskSetApplicationTaskTag:00000034 $d
     /tmp/ccnMoWm4.s:2270   .text.xTaskGetApplicationTaskTag:00000000 $t
     /tmp/ccnMoWm4.s:2275   .text.xTaskGetApplicationTaskTag:00000000 xTaskGetApplicationTaskTag
     /tmp/ccnMoWm4.s:2325   .text.xTaskGetApplicationTaskTag:00000034 $d
     /tmp/ccnMoWm4.s:2330   .text.xTaskCallApplicationTaskHook:00000000 $t
     /tmp/ccnMoWm4.s:2335   .text.xTaskCallApplicationTaskHook:00000000 xTaskCallApplicationTaskHook
     /tmp/ccnMoWm4.s:2395   .text.xTaskCallApplicationTaskHook:00000044 $d
     /tmp/ccnMoWm4.s:2400   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccnMoWm4.s:2530   .text.vTaskSwitchContext:000000c0 $d
     /tmp/ccnMoWm4.s:2541   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccnMoWm4.s:2546   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccnMoWm4.s:2608   .text.vTaskPlaceOnEventList:0000005c $d
     /tmp/ccnMoWm4.s:2615   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccnMoWm4.s:2620   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccnMoWm4.s:2722   .text.xTaskRemoveFromEventList:000000a0 $d
     /tmp/ccnMoWm4.s:2731   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccnMoWm4.s:2736   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccnMoWm4.s:2772   .text.vTaskSetTimeOutState:00000024 $d
     /tmp/ccnMoWm4.s:2778   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccnMoWm4.s:2783   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccnMoWm4.s:2878   .text.xTaskCheckForTimeOut:0000008c $d
     /tmp/ccnMoWm4.s:2884   .text.vTaskMissedYield:00000000 $t
     /tmp/ccnMoWm4.s:2889   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccnMoWm4.s:2914   .text.vTaskMissedYield:00000014 $d
     /tmp/ccnMoWm4.s:2919   .text.prvIdleTask:00000000 $t
     /tmp/ccnMoWm4.s:3150   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccnMoWm4.s:2960   .text.prvIdleTask:00000020 $d
     /tmp/ccnMoWm4.s:2965   .text.prvInitialiseTCBVariables:00000000 $t
     /tmp/ccnMoWm4.s:3058   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccnMoWm4.s:3134   .text.prvInitialiseTaskLists:00000068 $d
     /tmp/ccnMoWm4.s:3146   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccnMoWm4.s:3730   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccnMoWm4.s:3229   .text.prvCheckTasksWaitingTermination:0000006c $d
     /tmp/ccnMoWm4.s:3236   .text.prvAddCurrentTaskToDelayedList:00000000 $t
     /tmp/ccnMoWm4.s:3307   .text.prvAddCurrentTaskToDelayedList:0000005c $d
     /tmp/ccnMoWm4.s:3316   .text.prvAllocateTCBAndStack:00000000 $t
     /tmp/ccnMoWm4.s:3411   .text.prvGenerateRunTimeStatsForTasksInList:00000000 $t
     /tmp/ccnMoWm4.s:3613   .text.usTaskCheckFreeStackSpace:00000000 usTaskCheckFreeStackSpace
     /tmp/ccnMoWm4.s:3601   .text.prvGenerateRunTimeStatsForTasksInList:00000140 $d
     /tmp/ccnMoWm4.s:3609   .text.usTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccnMoWm4.s:3665   .text.uxTaskGetStackHighWaterMark:00000000 $t
     /tmp/ccnMoWm4.s:3670   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
     /tmp/ccnMoWm4.s:3721   .text.uxTaskGetStackHighWaterMark:00000034 $d
     /tmp/ccnMoWm4.s:3726   .text.prvDeleteTCB:00000000 $t
     /tmp/ccnMoWm4.s:3764   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccnMoWm4.s:3769   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccnMoWm4.s:3801   .text.xTaskGetCurrentTaskHandle:0000001c $d
     /tmp/ccnMoWm4.s:3806   .text.vTaskPriorityInherit:00000000 $t
     /tmp/ccnMoWm4.s:3811   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
     /tmp/ccnMoWm4.s:3916   .text.vTaskPriorityInherit:000000a8 $d
     /tmp/ccnMoWm4.s:3923   .text.vTaskPriorityDisinherit:00000000 $t
     /tmp/ccnMoWm4.s:3928   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
     /tmp/ccnMoWm4.s:4012   .text.vTaskPriorityDisinherit:00000080 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
strlen
memcpy
vListInsert
strncpy
vListInitialiseItem
vListInitialise
malloc
free
memset
sprintf
strcat
