   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.section	.text.xQueueCreate,"ax",%progbits
  25              		.align	2
  26              		.global	xQueueCreate
  27              		.thumb
  28              		.thumb_func
  30              	xQueueCreate:
  31              	.LFB110:
  32              		.file 1 "FreeRTOS/Source/queue.c"
   1:FreeRTOS/Source/queue.c **** /*
   2:FreeRTOS/Source/queue.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/queue.c **** 
   4:FreeRTOS/Source/queue.c **** 
   5:FreeRTOS/Source/queue.c ****     ***************************************************************************
   6:FreeRTOS/Source/queue.c ****      *                                                                       *
   7:FreeRTOS/Source/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/queue.c ****      *    available.                                                         *
  10:FreeRTOS/Source/queue.c ****      *                                                                       *
  11:FreeRTOS/Source/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/queue.c ****      *                                                                       *
  18:FreeRTOS/Source/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/queue.c ****      *                                                                       *
  20:FreeRTOS/Source/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/queue.c ****      *                                                                       *
  22:FreeRTOS/Source/queue.c ****     ***************************************************************************
  23:FreeRTOS/Source/queue.c **** 
  24:FreeRTOS/Source/queue.c **** 
  25:FreeRTOS/Source/queue.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/queue.c **** 
  27:FreeRTOS/Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/queue.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/queue.c **** 
  42:FreeRTOS/Source/queue.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/queue.c **** 
  44:FreeRTOS/Source/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/queue.c ****     contact details.
  46:FreeRTOS/Source/queue.c **** 
  47:FreeRTOS/Source/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/queue.c ****     critical systems.
  49:FreeRTOS/Source/queue.c **** 
  50:FreeRTOS/Source/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/queue.c ****     licensing and training services.
  52:FreeRTOS/Source/queue.c **** */
  53:FreeRTOS/Source/queue.c **** 
  54:FreeRTOS/Source/queue.c **** #include <stdlib.h>
  55:FreeRTOS/Source/queue.c **** #include <string.h>
  56:FreeRTOS/Source/queue.c **** 
  57:FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:FreeRTOS/Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:FreeRTOS/Source/queue.c **** task.h is included from an application file. */
  60:FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:FreeRTOS/Source/queue.c **** 
  62:FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  63:FreeRTOS/Source/queue.c **** #include "task.h"
  64:FreeRTOS/Source/queue.c **** 
  65:FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:FreeRTOS/Source/queue.c **** 	#include "croutine.h"
  67:FreeRTOS/Source/queue.c **** #endif
  68:FreeRTOS/Source/queue.c **** 
  69:FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/queue.c **** 
  71:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
  72:FreeRTOS/Source/queue.c ****  * PUBLIC LIST API documented in list.h
  73:FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
  74:FreeRTOS/Source/queue.c **** 
  75:FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:FreeRTOS/Source/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:FreeRTOS/Source/queue.c **** 
  79:FreeRTOS/Source/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:FreeRTOS/Source/queue.c **** 
  81:FreeRTOS/Source/queue.c **** /* For internal use only. */
  82:FreeRTOS/Source/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:FreeRTOS/Source/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:FreeRTOS/Source/queue.c **** 
  85:FreeRTOS/Source/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:FreeRTOS/Source/queue.c **** #define pxMutexHolder					pcTail
  87:FreeRTOS/Source/queue.c **** #define uxQueueType						pcHead
  88:FreeRTOS/Source/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:FreeRTOS/Source/queue.c **** 
  91:FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:FreeRTOS/Source/queue.c **** zero. */
  93:FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:FreeRTOS/Source/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:FreeRTOS/Source/queue.c **** 
  97:FreeRTOS/Source/queue.c **** /*
  98:FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  99:FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.
 100:FreeRTOS/Source/queue.c ****  */
 101:FreeRTOS/Source/queue.c **** typedef struct QueueDefinition
 102:FreeRTOS/Source/queue.c **** {
 103:FreeRTOS/Source/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 104:FreeRTOS/Source/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 105:FreeRTOS/Source/queue.c **** 
 106:FreeRTOS/Source/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 107:FreeRTOS/Source/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 108:FreeRTOS/Source/queue.c **** 
 109:FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 110:FreeRTOS/Source/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 111:FreeRTOS/Source/queue.c **** 
 112:FreeRTOS/Source/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 113:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 114:FreeRTOS/Source/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 115:FreeRTOS/Source/queue.c **** 
 116:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 117:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 118:FreeRTOS/Source/queue.c **** 
 119:FreeRTOS/Source/queue.c **** } xQUEUE;
 120:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 121:FreeRTOS/Source/queue.c **** 
 122:FreeRTOS/Source/queue.c **** /*
 123:FreeRTOS/Source/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 124:FreeRTOS/Source/queue.c ****  * To keep the definition private the API header file defines it as a
 125:FreeRTOS/Source/queue.c ****  * pointer to void.
 126:FreeRTOS/Source/queue.c ****  */
 127:FreeRTOS/Source/queue.c **** typedef xQUEUE * xQueueHandle;
 128:FreeRTOS/Source/queue.c **** 
 129:FreeRTOS/Source/queue.c **** /*
 130:FreeRTOS/Source/queue.c ****  * Prototypes for public functions are included here so we don't have to
 131:FreeRTOS/Source/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 132:FreeRTOS/Source/queue.c ****  * functions are documented in the API header file.
 133:FreeRTOS/Source/queue.c ****  */
 134:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 135:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 136:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 137:FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 138:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 139:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 140:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 141:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateMutex( void ) PRIVILEGED_FUNCTION;
 142:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 143:FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 144:FreeRTOS/Source/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 145:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 146:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 147:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 148:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 150:FreeRTOS/Source/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 151:FreeRTOS/Source/queue.c **** 
 152:FreeRTOS/Source/queue.c **** /*
 153:FreeRTOS/Source/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 154:FreeRTOS/Source/queue.c ****  * an optional component.
 155:FreeRTOS/Source/queue.c ****  */
 156:FreeRTOS/Source/queue.c **** #if configUSE_CO_ROUTINES == 1
 157:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 158:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 159:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 160:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 161:FreeRTOS/Source/queue.c **** #endif
 162:FreeRTOS/Source/queue.c **** 
 163:FreeRTOS/Source/queue.c **** /*
 164:FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 165:FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 166:FreeRTOS/Source/queue.c ****  */
 167:FreeRTOS/Source/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 168:FreeRTOS/Source/queue.c **** 
 169:FreeRTOS/Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 170:FreeRTOS/Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 171:FreeRTOS/Source/queue.c **** 	more user friendly. */
 172:FreeRTOS/Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 173:FreeRTOS/Source/queue.c **** 	{
 174:FreeRTOS/Source/queue.c **** 		signed char *pcQueueName;
 175:FreeRTOS/Source/queue.c **** 		xQueueHandle xHandle;
 176:FreeRTOS/Source/queue.c **** 	} xQueueRegistryItem;
 177:FreeRTOS/Source/queue.c **** 
 178:FreeRTOS/Source/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 179:FreeRTOS/Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 180:FreeRTOS/Source/queue.c **** 	array position being vacant. */
 181:FreeRTOS/Source/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 182:FreeRTOS/Source/queue.c **** 
 183:FreeRTOS/Source/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 184:FreeRTOS/Source/queue.c **** 	member to NULL. */
 185:FreeRTOS/Source/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 186:FreeRTOS/Source/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 187:FreeRTOS/Source/queue.c **** #endif
 188:FreeRTOS/Source/queue.c **** 
 189:FreeRTOS/Source/queue.c **** /*
 190:FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 191:FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 192:FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 193:FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 194:FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 195:FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 196:FreeRTOS/Source/queue.c ****  */
 197:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 198:FreeRTOS/Source/queue.c **** 
 199:FreeRTOS/Source/queue.c **** /*
 200:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 201:FreeRTOS/Source/queue.c ****  *
 202:FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 203:FreeRTOS/Source/queue.c ****  */
 204:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 205:FreeRTOS/Source/queue.c **** 
 206:FreeRTOS/Source/queue.c **** /*
 207:FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 208:FreeRTOS/Source/queue.c ****  *
 209:FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 210:FreeRTOS/Source/queue.c ****  */
 211:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 212:FreeRTOS/Source/queue.c **** 
 213:FreeRTOS/Source/queue.c **** /*
 214:FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 215:FreeRTOS/Source/queue.c ****  * back of the queue.
 216:FreeRTOS/Source/queue.c ****  */
 217:FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 218:FreeRTOS/Source/queue.c **** 
 219:FreeRTOS/Source/queue.c **** /*
 220:FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 221:FreeRTOS/Source/queue.c ****  */
 222:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 223:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 224:FreeRTOS/Source/queue.c **** 
 225:FreeRTOS/Source/queue.c **** /*
 226:FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 227:FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 228:FreeRTOS/Source/queue.c ****  */
 229:FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )								\
 230:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();									\
 231:FreeRTOS/Source/queue.c **** 	{														\
 232:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 233:FreeRTOS/Source/queue.c **** 		{													\
 234:FreeRTOS/Source/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 235:FreeRTOS/Source/queue.c **** 		}													\
 236:FreeRTOS/Source/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 237:FreeRTOS/Source/queue.c **** 		{													\
 238:FreeRTOS/Source/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 239:FreeRTOS/Source/queue.c **** 		}													\
 240:FreeRTOS/Source/queue.c **** 	}														\
 241:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL()
 242:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 243:FreeRTOS/Source/queue.c **** 
 244:FreeRTOS/Source/queue.c **** 
 245:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------
 246:FreeRTOS/Source/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 247:FreeRTOS/Source/queue.c ****  *----------------------------------------------------------*/
 248:FreeRTOS/Source/queue.c **** 
 249:FreeRTOS/Source/queue.c **** xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize 
 250:FreeRTOS/Source/queue.c **** {
  33              		.loc 1 250 0
  34              		.cfi_startproc
  35              		@ args = 0, pretend = 0, frame = 24
  36              		@ frame_needed = 1, uses_anonymous_args = 0
  37 0000 80B5     		push	{r7, lr}
  38              	.LCFI0:
  39              		.cfi_def_cfa_offset 8
  40 0002 86B0     		sub	sp, sp, #24
  41              	.LCFI1:
  42              		.cfi_def_cfa_offset 32
  43 0004 00AF     		add	r7, sp, #0
  44              		.cfi_offset 14, -4
  45              		.cfi_offset 7, -8
  46              	.LCFI2:
  47              		.cfi_def_cfa_register 7
  48 0006 7860     		str	r0, [r7, #4]
  49 0008 3960     		str	r1, [r7, #0]
 251:FreeRTOS/Source/queue.c **** xQUEUE *pxNewQueue;
 252:FreeRTOS/Source/queue.c **** size_t xQueueSizeInBytes;
 253:FreeRTOS/Source/queue.c **** xQueueHandle xReturn = NULL;
  50              		.loc 1 253 0
  51 000a 4FF00003 		mov	r3, #0
  52 000e 7B61     		str	r3, [r7, #20]
 254:FreeRTOS/Source/queue.c **** 
 255:FreeRTOS/Source/queue.c **** 	/* Allocate the new queue structure. */
 256:FreeRTOS/Source/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  53              		.loc 1 256 0
  54 0010 7B68     		ldr	r3, [r7, #4]
  55 0012 002B     		cmp	r3, #0
  56 0014 56D0     		beq	.L2
 257:FreeRTOS/Source/queue.c **** 	{
 258:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  57              		.loc 1 258 0
  58 0016 4FF04C00 		mov	r0, #76
  59 001a FFF7FEFF 		bl	malloc
  60 001e 0346     		mov	r3, r0
  61 0020 3B61     		str	r3, [r7, #16]
 259:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
  62              		.loc 1 259 0
  63 0022 3B69     		ldr	r3, [r7, #16]
  64 0024 002B     		cmp	r3, #0
  65 0026 4DD0     		beq	.L2
 260:FreeRTOS/Source/queue.c **** 		{
 261:FreeRTOS/Source/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 262:FreeRTOS/Source/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 263:FreeRTOS/Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  66              		.loc 1 263 0
  67 0028 7B68     		ldr	r3, [r7, #4]
  68 002a 3A68     		ldr	r2, [r7, #0]
  69 002c 02FB03F3 		mul	r3, r2, r3
  70 0030 03F10103 		add	r3, r3, #1
  71 0034 FB60     		str	r3, [r7, #12]
 264:FreeRTOS/Source/queue.c **** 
 265:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  72              		.loc 1 265 0
  73 0036 F868     		ldr	r0, [r7, #12]
  74 0038 FFF7FEFF 		bl	malloc
  75 003c 0346     		mov	r3, r0
  76 003e 1A46     		mov	r2, r3
  77 0040 3B69     		ldr	r3, [r7, #16]
  78 0042 1A60     		str	r2, [r3, #0]
 266:FreeRTOS/Source/queue.c **** 			if( pxNewQueue->pcHead != NULL )
  79              		.loc 1 266 0
  80 0044 3B69     		ldr	r3, [r7, #16]
  81 0046 1B68     		ldr	r3, [r3, #0]
  82 0048 002B     		cmp	r3, #0
  83 004a 38D0     		beq	.L3
 267:FreeRTOS/Source/queue.c **** 			{
 268:FreeRTOS/Source/queue.c **** 				/* Initialise the queue members as described above where the
 269:FreeRTOS/Source/queue.c **** 				queue type is defined. */
 270:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
  84              		.loc 1 270 0
  85 004c 3B69     		ldr	r3, [r7, #16]
  86 004e 1A68     		ldr	r2, [r3, #0]
  87 0050 7B68     		ldr	r3, [r7, #4]
  88 0052 3968     		ldr	r1, [r7, #0]
  89 0054 01FB03F3 		mul	r3, r1, r3
  90 0058 D218     		adds	r2, r2, r3
  91 005a 3B69     		ldr	r3, [r7, #16]
  92 005c 5A60     		str	r2, [r3, #4]
 271:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  93              		.loc 1 271 0
  94 005e 3B69     		ldr	r3, [r7, #16]
  95 0060 4FF00002 		mov	r2, #0
  96 0064 9A63     		str	r2, [r3, #56]
 272:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
  97              		.loc 1 272 0
  98 0066 3B69     		ldr	r3, [r7, #16]
  99 0068 1A68     		ldr	r2, [r3, #0]
 100 006a 3B69     		ldr	r3, [r7, #16]
 101 006c 9A60     		str	r2, [r3, #8]
 273:FreeRTOS/Source/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
 102              		.loc 1 273 0
 103 006e 3B69     		ldr	r3, [r7, #16]
 104 0070 1A68     		ldr	r2, [r3, #0]
 105 0072 7B68     		ldr	r3, [r7, #4]
 106 0074 03F1FF33 		add	r3, r3, #-1
 107 0078 3968     		ldr	r1, [r7, #0]
 108 007a 01FB03F3 		mul	r3, r1, r3
 109 007e D218     		adds	r2, r2, r3
 110 0080 3B69     		ldr	r3, [r7, #16]
 111 0082 DA60     		str	r2, [r3, #12]
 274:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 112              		.loc 1 274 0
 113 0084 3B69     		ldr	r3, [r7, #16]
 114 0086 7A68     		ldr	r2, [r7, #4]
 115 0088 DA63     		str	r2, [r3, #60]
 275:FreeRTOS/Source/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 116              		.loc 1 275 0
 117 008a 3B69     		ldr	r3, [r7, #16]
 118 008c 3A68     		ldr	r2, [r7, #0]
 119 008e 1A64     		str	r2, [r3, #64]
 276:FreeRTOS/Source/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 120              		.loc 1 276 0
 121 0090 3B69     		ldr	r3, [r7, #16]
 122 0092 4FF0FF32 		mov	r2, #-1
 123 0096 5A64     		str	r2, [r3, #68]
 277:FreeRTOS/Source/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 124              		.loc 1 277 0
 125 0098 3B69     		ldr	r3, [r7, #16]
 126 009a 4FF0FF32 		mov	r2, #-1
 127 009e 9A64     		str	r2, [r3, #72]
 278:FreeRTOS/Source/queue.c **** 
 279:FreeRTOS/Source/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 280:FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 128              		.loc 1 280 0
 129 00a0 3B69     		ldr	r3, [r7, #16]
 130 00a2 03F11003 		add	r3, r3, #16
 131 00a6 1846     		mov	r0, r3
 132 00a8 FFF7FEFF 		bl	vListInitialise
 281:FreeRTOS/Source/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 133              		.loc 1 281 0
 134 00ac 3B69     		ldr	r3, [r7, #16]
 135 00ae 03F12403 		add	r3, r3, #36
 136 00b2 1846     		mov	r0, r3
 137 00b4 FFF7FEFF 		bl	vListInitialise
 282:FreeRTOS/Source/queue.c **** 
 283:FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 284:FreeRTOS/Source/queue.c **** 				xReturn = pxNewQueue;
 138              		.loc 1 284 0
 139 00b8 3B69     		ldr	r3, [r7, #16]
 140 00ba 7B61     		str	r3, [r7, #20]
 141 00bc 02E0     		b	.L2
 142              	.L3:
 285:FreeRTOS/Source/queue.c **** 			}
 286:FreeRTOS/Source/queue.c **** 			else
 287:FreeRTOS/Source/queue.c **** 			{
 288:FreeRTOS/Source/queue.c **** 				traceQUEUE_CREATE_FAILED();
 289:FreeRTOS/Source/queue.c **** 				vPortFree( pxNewQueue );
 143              		.loc 1 289 0
 144 00be 3869     		ldr	r0, [r7, #16]
 145 00c0 FFF7FEFF 		bl	free
 146              	.L2:
 290:FreeRTOS/Source/queue.c **** 			}
 291:FreeRTOS/Source/queue.c **** 		}
 292:FreeRTOS/Source/queue.c **** 	}
 293:FreeRTOS/Source/queue.c **** 
 294:FreeRTOS/Source/queue.c **** 	configASSERT( xReturn );
 295:FreeRTOS/Source/queue.c **** 
 296:FreeRTOS/Source/queue.c **** 	return xReturn;
 147              		.loc 1 296 0
 148 00c4 7B69     		ldr	r3, [r7, #20]
 297:FreeRTOS/Source/queue.c **** }
 149              		.loc 1 297 0
 150 00c6 1846     		mov	r0, r3
 151 00c8 07F11807 		add	r7, r7, #24
 152 00cc BD46     		mov	sp, r7
 153 00ce 80BD     		pop	{r7, pc}
 154              		.cfi_endproc
 155              	.LFE110:
 157              		.section	.text.xQueueCreateMutex,"ax",%progbits
 158              		.align	2
 159              		.global	xQueueCreateMutex
 160              		.thumb
 161              		.thumb_func
 163              	xQueueCreateMutex:
 164              	.LFB111:
 298:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 299:FreeRTOS/Source/queue.c **** 
 300:FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 301:FreeRTOS/Source/queue.c **** 
 302:FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateMutex( void )
 303:FreeRTOS/Source/queue.c **** 	{
 165              		.loc 1 303 0
 166              		.cfi_startproc
 167              		@ args = 0, pretend = 0, frame = 8
 168              		@ frame_needed = 1, uses_anonymous_args = 0
 169 0000 80B5     		push	{r7, lr}
 170              	.LCFI3:
 171              		.cfi_def_cfa_offset 8
 172 0002 82B0     		sub	sp, sp, #8
 173              	.LCFI4:
 174              		.cfi_def_cfa_offset 16
 175 0004 00AF     		add	r7, sp, #0
 176              		.cfi_offset 14, -4
 177              		.cfi_offset 7, -8
 178              	.LCFI5:
 179              		.cfi_def_cfa_register 7
 304:FreeRTOS/Source/queue.c **** 	xQUEUE *pxNewQueue;
 305:FreeRTOS/Source/queue.c **** 
 306:FreeRTOS/Source/queue.c **** 		/* Allocate the new queue structure. */
 307:FreeRTOS/Source/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 180              		.loc 1 307 0
 181 0006 4FF04C00 		mov	r0, #76
 182 000a FFF7FEFF 		bl	malloc
 183 000e 0346     		mov	r3, r0
 184 0010 7B60     		str	r3, [r7, #4]
 308:FreeRTOS/Source/queue.c **** 		if( pxNewQueue != NULL )
 185              		.loc 1 308 0
 186 0012 7B68     		ldr	r3, [r7, #4]
 187 0014 002B     		cmp	r3, #0
 188 0016 38D0     		beq	.L5
 309:FreeRTOS/Source/queue.c **** 		{
 310:FreeRTOS/Source/queue.c **** 			/* Information required for priority inheritance. */
 311:FreeRTOS/Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 189              		.loc 1 311 0
 190 0018 7B68     		ldr	r3, [r7, #4]
 191 001a 4FF00002 		mov	r2, #0
 192 001e 5A60     		str	r2, [r3, #4]
 312:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 193              		.loc 1 312 0
 194 0020 7B68     		ldr	r3, [r7, #4]
 195 0022 4FF00002 		mov	r2, #0
 196 0026 1A60     		str	r2, [r3, #0]
 313:FreeRTOS/Source/queue.c **** 
 314:FreeRTOS/Source/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 315:FreeRTOS/Source/queue.c **** 			of the queue. */
 316:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 197              		.loc 1 316 0
 198 0028 7B68     		ldr	r3, [r7, #4]
 199 002a 4FF00002 		mov	r2, #0
 200 002e 9A60     		str	r2, [r3, #8]
 317:FreeRTOS/Source/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 201              		.loc 1 317 0
 202 0030 7B68     		ldr	r3, [r7, #4]
 203 0032 4FF00002 		mov	r2, #0
 204 0036 DA60     		str	r2, [r3, #12]
 318:FreeRTOS/Source/queue.c **** 
 319:FreeRTOS/Source/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 320:FreeRTOS/Source/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 321:FreeRTOS/Source/queue.c **** 			of the mutex. */
 322:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 205              		.loc 1 322 0
 206 0038 7B68     		ldr	r3, [r7, #4]
 207 003a 4FF00002 		mov	r2, #0
 208 003e 9A63     		str	r2, [r3, #56]
 323:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 209              		.loc 1 323 0
 210 0040 7B68     		ldr	r3, [r7, #4]
 211 0042 4FF00102 		mov	r2, #1
 212 0046 DA63     		str	r2, [r3, #60]
 324:FreeRTOS/Source/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 213              		.loc 1 324 0
 214 0048 7B68     		ldr	r3, [r7, #4]
 215 004a 4FF00002 		mov	r2, #0
 216 004e 1A64     		str	r2, [r3, #64]
 325:FreeRTOS/Source/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 217              		.loc 1 325 0
 218 0050 7B68     		ldr	r3, [r7, #4]
 219 0052 4FF0FF32 		mov	r2, #-1
 220 0056 5A64     		str	r2, [r3, #68]
 326:FreeRTOS/Source/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 221              		.loc 1 326 0
 222 0058 7B68     		ldr	r3, [r7, #4]
 223 005a 4FF0FF32 		mov	r2, #-1
 224 005e 9A64     		str	r2, [r3, #72]
 327:FreeRTOS/Source/queue.c **** 
 328:FreeRTOS/Source/queue.c **** 			/* Ensure the event queues start with the correct state. */
 329:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 225              		.loc 1 329 0
 226 0060 7B68     		ldr	r3, [r7, #4]
 227 0062 03F11003 		add	r3, r3, #16
 228 0066 1846     		mov	r0, r3
 229 0068 FFF7FEFF 		bl	vListInitialise
 330:FreeRTOS/Source/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 230              		.loc 1 330 0
 231 006c 7B68     		ldr	r3, [r7, #4]
 232 006e 03F12403 		add	r3, r3, #36
 233 0072 1846     		mov	r0, r3
 234 0074 FFF7FEFF 		bl	vListInitialise
 331:FreeRTOS/Source/queue.c **** 
 332:FreeRTOS/Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 333:FreeRTOS/Source/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 235              		.loc 1 333 0
 236 0078 7868     		ldr	r0, [r7, #4]
 237 007a 4FF00001 		mov	r1, #0
 238 007e 4FF00002 		mov	r2, #0
 239 0082 4FF00003 		mov	r3, #0
 240 0086 FFF7FEFF 		bl	xQueueGenericSend
 241              	.L5:
 334:FreeRTOS/Source/queue.c **** 
 335:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 336:FreeRTOS/Source/queue.c **** 		}
 337:FreeRTOS/Source/queue.c **** 		else
 338:FreeRTOS/Source/queue.c **** 		{
 339:FreeRTOS/Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 340:FreeRTOS/Source/queue.c **** 		}
 341:FreeRTOS/Source/queue.c **** 
 342:FreeRTOS/Source/queue.c **** 		configASSERT( pxNewQueue );
 343:FreeRTOS/Source/queue.c **** 		return pxNewQueue;
 242              		.loc 1 343 0
 243 008a 7B68     		ldr	r3, [r7, #4]
 344:FreeRTOS/Source/queue.c **** 	}
 244              		.loc 1 344 0
 245 008c 1846     		mov	r0, r3
 246 008e 07F10807 		add	r7, r7, #8
 247 0092 BD46     		mov	sp, r7
 248 0094 80BD     		pop	{r7, pc}
 249              		.cfi_endproc
 250              	.LFE111:
 252 0096 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 253              		.align	2
 254              		.global	xQueueGenericSend
 255              		.thumb
 256              		.thumb_func
 258              	xQueueGenericSend:
 259              	.LFB112:
 345:FreeRTOS/Source/queue.c **** 
 346:FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 347:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 348:FreeRTOS/Source/queue.c **** 
 349:FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 350:FreeRTOS/Source/queue.c **** 
 351:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 352:FreeRTOS/Source/queue.c **** 	{
 353:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 354:FreeRTOS/Source/queue.c **** 
 355:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 356:FreeRTOS/Source/queue.c **** 
 357:FreeRTOS/Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 358:FreeRTOS/Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 359:FreeRTOS/Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 360:FreeRTOS/Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 361:FreeRTOS/Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 362:FreeRTOS/Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 363:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 364:FreeRTOS/Source/queue.c **** 		{
 365:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 366:FreeRTOS/Source/queue.c **** 
 367:FreeRTOS/Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 368:FreeRTOS/Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 369:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 370:FreeRTOS/Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 371:FreeRTOS/Source/queue.c **** 			uxRecursiveCallCount member. */
 372:FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 373:FreeRTOS/Source/queue.c **** 
 374:FreeRTOS/Source/queue.c **** 			/* Have we unwound the call count? */
 375:FreeRTOS/Source/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 376:FreeRTOS/Source/queue.c **** 			{
 377:FreeRTOS/Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 378:FreeRTOS/Source/queue.c **** 				task that might be waiting to access the mutex. */
 379:FreeRTOS/Source/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 380:FreeRTOS/Source/queue.c **** 			}
 381:FreeRTOS/Source/queue.c **** 
 382:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 383:FreeRTOS/Source/queue.c **** 		}
 384:FreeRTOS/Source/queue.c **** 		else
 385:FreeRTOS/Source/queue.c **** 		{
 386:FreeRTOS/Source/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 387:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 388:FreeRTOS/Source/queue.c **** 
 389:FreeRTOS/Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 390:FreeRTOS/Source/queue.c **** 		}
 391:FreeRTOS/Source/queue.c **** 
 392:FreeRTOS/Source/queue.c **** 		return xReturn;
 393:FreeRTOS/Source/queue.c **** 	}
 394:FreeRTOS/Source/queue.c **** 
 395:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 396:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 397:FreeRTOS/Source/queue.c **** 
 398:FreeRTOS/Source/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 399:FreeRTOS/Source/queue.c **** 
 400:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 401:FreeRTOS/Source/queue.c **** 	{
 402:FreeRTOS/Source/queue.c **** 	portBASE_TYPE xReturn;
 403:FreeRTOS/Source/queue.c **** 
 404:FreeRTOS/Source/queue.c **** 		configASSERT( pxMutex );
 405:FreeRTOS/Source/queue.c **** 
 406:FreeRTOS/Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 407:FreeRTOS/Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 408:FreeRTOS/Source/queue.c **** 
 409:FreeRTOS/Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 410:FreeRTOS/Source/queue.c **** 
 411:FreeRTOS/Source/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 412:FreeRTOS/Source/queue.c **** 		{
 413:FreeRTOS/Source/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 414:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 415:FreeRTOS/Source/queue.c **** 		}
 416:FreeRTOS/Source/queue.c **** 		else
 417:FreeRTOS/Source/queue.c **** 		{
 418:FreeRTOS/Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 419:FreeRTOS/Source/queue.c **** 
 420:FreeRTOS/Source/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 421:FreeRTOS/Source/queue.c **** 			we may have blocked to reach here. */
 422:FreeRTOS/Source/queue.c **** 			if( xReturn == pdPASS )
 423:FreeRTOS/Source/queue.c **** 			{
 424:FreeRTOS/Source/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 425:FreeRTOS/Source/queue.c **** 			}
 426:FreeRTOS/Source/queue.c **** 			else
 427:FreeRTOS/Source/queue.c **** 			{
 428:FreeRTOS/Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 429:FreeRTOS/Source/queue.c **** 			}
 430:FreeRTOS/Source/queue.c **** 		}
 431:FreeRTOS/Source/queue.c **** 
 432:FreeRTOS/Source/queue.c **** 		return xReturn;
 433:FreeRTOS/Source/queue.c **** 	}
 434:FreeRTOS/Source/queue.c **** 
 435:FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 436:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 437:FreeRTOS/Source/queue.c **** 
 438:FreeRTOS/Source/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 439:FreeRTOS/Source/queue.c **** 
 440:FreeRTOS/Source/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 441:FreeRTOS/Source/queue.c **** 	{
 442:FreeRTOS/Source/queue.c **** 	xQueueHandle pxHandle;
 443:FreeRTOS/Source/queue.c **** 
 444:FreeRTOS/Source/queue.c **** 		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGT
 445:FreeRTOS/Source/queue.c **** 
 446:FreeRTOS/Source/queue.c **** 		if( pxHandle != NULL )
 447:FreeRTOS/Source/queue.c **** 		{
 448:FreeRTOS/Source/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 449:FreeRTOS/Source/queue.c **** 
 450:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 451:FreeRTOS/Source/queue.c **** 		}
 452:FreeRTOS/Source/queue.c **** 		else
 453:FreeRTOS/Source/queue.c **** 		{
 454:FreeRTOS/Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 455:FreeRTOS/Source/queue.c **** 		}
 456:FreeRTOS/Source/queue.c **** 
 457:FreeRTOS/Source/queue.c **** 		configASSERT( pxHandle );
 458:FreeRTOS/Source/queue.c **** 		return pxHandle;
 459:FreeRTOS/Source/queue.c **** 	}
 460:FreeRTOS/Source/queue.c **** 
 461:FreeRTOS/Source/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 462:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 463:FreeRTOS/Source/queue.c **** 
 464:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 465:FreeRTOS/Source/queue.c **** {
 260              		.loc 1 465 0
 261              		.cfi_startproc
 262              		@ args = 0, pretend = 0, frame = 32
 263              		@ frame_needed = 1, uses_anonymous_args = 0
 264 0000 80B5     		push	{r7, lr}
 265              	.LCFI6:
 266              		.cfi_def_cfa_offset 8
 267 0002 88B0     		sub	sp, sp, #32
 268              	.LCFI7:
 269              		.cfi_def_cfa_offset 40
 270 0004 00AF     		add	r7, sp, #0
 271              		.cfi_offset 14, -4
 272              		.cfi_offset 7, -8
 273              	.LCFI8:
 274              		.cfi_def_cfa_register 7
 275 0006 F860     		str	r0, [r7, #12]
 276 0008 B960     		str	r1, [r7, #8]
 277 000a 7A60     		str	r2, [r7, #4]
 278 000c 3B60     		str	r3, [r7, #0]
 466:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 279              		.loc 1 466 0
 280 000e 4FF00003 		mov	r3, #0
 281 0012 FB61     		str	r3, [r7, #28]
 282 0014 00E0     		b	.L17
 283              	.L18:
 467:FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 468:FreeRTOS/Source/queue.c **** 
 469:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 470:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 471:FreeRTOS/Source/queue.c **** 
 472:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 473:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 474:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 475:FreeRTOS/Source/queue.c **** 	for( ;; )
 476:FreeRTOS/Source/queue.c **** 	{
 477:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 478:FreeRTOS/Source/queue.c **** 		{
 479:FreeRTOS/Source/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 480:FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 481:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 482:FreeRTOS/Source/queue.c **** 			{
 483:FreeRTOS/Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 484:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 485:FreeRTOS/Source/queue.c **** 
 486:FreeRTOS/Source/queue.c **** 				/* If there was a task waiting for data to arrive on the
 487:FreeRTOS/Source/queue.c **** 				queue then unblock it now. */
 488:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 489:FreeRTOS/Source/queue.c **** 				{
 490:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 491:FreeRTOS/Source/queue.c **** 					{
 492:FreeRTOS/Source/queue.c **** 						/* The unblocked task has a priority higher than
 493:FreeRTOS/Source/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 494:FreeRTOS/Source/queue.c **** 						this from within the critical section - the kernel
 495:FreeRTOS/Source/queue.c **** 						takes care of that. */
 496:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 497:FreeRTOS/Source/queue.c **** 					}
 498:FreeRTOS/Source/queue.c **** 				}
 499:FreeRTOS/Source/queue.c **** 
 500:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 501:FreeRTOS/Source/queue.c **** 
 502:FreeRTOS/Source/queue.c **** 				/* Return to the original privilege level before exiting the
 503:FreeRTOS/Source/queue.c **** 				function. */
 504:FreeRTOS/Source/queue.c **** 				return pdPASS;
 505:FreeRTOS/Source/queue.c **** 			}
 506:FreeRTOS/Source/queue.c **** 			else
 507:FreeRTOS/Source/queue.c **** 			{
 508:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 509:FreeRTOS/Source/queue.c **** 				{
 510:FreeRTOS/Source/queue.c **** 					/* The queue was full and no block time is specified (or
 511:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 512:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 513:FreeRTOS/Source/queue.c **** 
 514:FreeRTOS/Source/queue.c **** 					/* Return to the original privilege level before exiting
 515:FreeRTOS/Source/queue.c **** 					the function. */
 516:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 517:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 518:FreeRTOS/Source/queue.c **** 				}
 519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 520:FreeRTOS/Source/queue.c **** 				{
 521:FreeRTOS/Source/queue.c **** 					/* The queue was full and a block time was specified so
 522:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 523:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 525:FreeRTOS/Source/queue.c **** 				}
 526:FreeRTOS/Source/queue.c **** 			}
 527:FreeRTOS/Source/queue.c **** 		}
 528:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 529:FreeRTOS/Source/queue.c **** 
 530:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 531:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 532:FreeRTOS/Source/queue.c **** 
 533:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 535:FreeRTOS/Source/queue.c **** 
 536:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 537:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 538:FreeRTOS/Source/queue.c **** 		{
 539:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 540:FreeRTOS/Source/queue.c **** 			{
 541:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 542:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 543:FreeRTOS/Source/queue.c **** 
 544:FreeRTOS/Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 545:FreeRTOS/Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 546:FreeRTOS/Source/queue.c **** 				remove this task from the event	list again - but as the
 547:FreeRTOS/Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 548:FreeRTOS/Source/queue.c **** 				ready last instead of the actual ready list. */
 549:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 550:FreeRTOS/Source/queue.c **** 
 551:FreeRTOS/Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 552:FreeRTOS/Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 553:FreeRTOS/Source/queue.c **** 				task is already in a ready list before it yields - in which
 554:FreeRTOS/Source/queue.c **** 				case the yield will not cause a context switch unless there
 555:FreeRTOS/Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 556:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 557:FreeRTOS/Source/queue.c **** 				{
 558:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 559:FreeRTOS/Source/queue.c **** 				}
 560:FreeRTOS/Source/queue.c **** 			}
 561:FreeRTOS/Source/queue.c **** 			else
 562:FreeRTOS/Source/queue.c **** 			{
 563:FreeRTOS/Source/queue.c **** 				/* Try again. */
 564:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 565:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 566:FreeRTOS/Source/queue.c **** 			}
 567:FreeRTOS/Source/queue.c **** 		}
 568:FreeRTOS/Source/queue.c **** 		else
 569:FreeRTOS/Source/queue.c **** 		{
 570:FreeRTOS/Source/queue.c **** 			/* The timeout has expired. */
 571:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 572:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 573:FreeRTOS/Source/queue.c **** 
 574:FreeRTOS/Source/queue.c **** 			/* Return to the original privilege level before exiting the
 575:FreeRTOS/Source/queue.c **** 			function. */
 576:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 577:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 578:FreeRTOS/Source/queue.c **** 		}
 579:FreeRTOS/Source/queue.c **** 	}
 284              		.loc 1 579 0
 285 0016 00BF     		nop
 286              	.L17:
 477:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 287              		.loc 1 477 0
 288 0018 FFF7FEFF 		bl	vPortEnterCritical
 481:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 289              		.loc 1 481 0
 290 001c FB68     		ldr	r3, [r7, #12]
 291 001e 9A6B     		ldr	r2, [r3, #56]
 292 0020 FB68     		ldr	r3, [r7, #12]
 293 0022 DB6B     		ldr	r3, [r3, #60]
 294 0024 9A42     		cmp	r2, r3
 295 0026 18D2     		bcs	.L7
 484:FreeRTOS/Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 296              		.loc 1 484 0
 297 0028 F868     		ldr	r0, [r7, #12]
 298 002a B968     		ldr	r1, [r7, #8]
 299 002c 3A68     		ldr	r2, [r7, #0]
 300 002e FFF7FEFF 		bl	prvCopyDataToQueue
 488:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 301              		.loc 1 488 0
 302 0032 FB68     		ldr	r3, [r7, #12]
 303 0034 5B6A     		ldr	r3, [r3, #36]
 304 0036 002B     		cmp	r3, #0
 305 0038 0AD0     		beq	.L8
 490:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 306              		.loc 1 490 0
 307 003a FB68     		ldr	r3, [r7, #12]
 308 003c 03F12403 		add	r3, r3, #36
 309 0040 1846     		mov	r0, r3
 310 0042 FFF7FEFF 		bl	xTaskRemoveFromEventList
 311 0046 0346     		mov	r3, r0
 312 0048 012B     		cmp	r3, #1
 313 004a 01D1     		bne	.L8
 496:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 314              		.loc 1 496 0
 315 004c FFF7FEFF 		bl	vPortYieldFromISR
 316              	.L8:
 500:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 317              		.loc 1 500 0
 318 0050 FFF7FEFF 		bl	vPortExitCritical
 504:FreeRTOS/Source/queue.c **** 				return pdPASS;
 319              		.loc 1 504 0
 320 0054 4FF00103 		mov	r3, #1
 321 0058 5DE0     		b	.L9
 322              	.L7:
 508:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 323              		.loc 1 508 0
 324 005a 7B68     		ldr	r3, [r7, #4]
 325 005c 002B     		cmp	r3, #0
 326 005e 04D1     		bne	.L10
 512:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 327              		.loc 1 512 0
 328 0060 FFF7FEFF 		bl	vPortExitCritical
 517:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 329              		.loc 1 517 0
 330 0064 4FF00003 		mov	r3, #0
 331 0068 55E0     		b	.L9
 332              	.L10:
 519:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 333              		.loc 1 519 0
 334 006a FB69     		ldr	r3, [r7, #28]
 335 006c 002B     		cmp	r3, #0
 336 006e 07D1     		bne	.L11
 523:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 337              		.loc 1 523 0
 338 0070 07F11403 		add	r3, r7, #20
 339 0074 1846     		mov	r0, r3
 340 0076 FFF7FEFF 		bl	vTaskSetTimeOutState
 524:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 341              		.loc 1 524 0
 342 007a 4FF00103 		mov	r3, #1
 343 007e FB61     		str	r3, [r7, #28]
 344              	.L11:
 528:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 345              		.loc 1 528 0
 346 0080 FFF7FEFF 		bl	vPortExitCritical
 533:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 347              		.loc 1 533 0
 348 0084 FFF7FEFF 		bl	vTaskSuspendAll
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 349              		.loc 1 534 0
 350 0088 FFF7FEFF 		bl	vPortEnterCritical
 351 008c FB68     		ldr	r3, [r7, #12]
 352 008e 5B6C     		ldr	r3, [r3, #68]
 353 0090 B3F1FF3F 		cmp	r3, #-1
 354 0094 03D1     		bne	.L12
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 355              		.loc 1 534 0 is_stmt 0 discriminator 1
 356 0096 FB68     		ldr	r3, [r7, #12]
 357 0098 4FF00002 		mov	r2, #0
 358 009c 5A64     		str	r2, [r3, #68]
 359              	.L12:
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 360              		.loc 1 534 0 discriminator 2
 361 009e FB68     		ldr	r3, [r7, #12]
 362 00a0 9B6C     		ldr	r3, [r3, #72]
 363 00a2 B3F1FF3F 		cmp	r3, #-1
 364 00a6 03D1     		bne	.L13
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 365              		.loc 1 534 0 discriminator 3
 366 00a8 FB68     		ldr	r3, [r7, #12]
 367 00aa 4FF00002 		mov	r2, #0
 368 00ae 9A64     		str	r2, [r3, #72]
 369              	.L13:
 534:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 370              		.loc 1 534 0 discriminator 4
 371 00b0 FFF7FEFF 		bl	vPortExitCritical
 537:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 372              		.loc 1 537 0 is_stmt 1 discriminator 4
 373 00b4 07F11402 		add	r2, r7, #20
 374 00b8 07F10403 		add	r3, r7, #4
 375 00bc 1046     		mov	r0, r2
 376 00be 1946     		mov	r1, r3
 377 00c0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 378 00c4 0346     		mov	r3, r0
 379 00c6 002B     		cmp	r3, #0
 380 00c8 1ED1     		bne	.L14
 539:FreeRTOS/Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 381              		.loc 1 539 0
 382 00ca F868     		ldr	r0, [r7, #12]
 383 00cc FFF7FEFF 		bl	prvIsQueueFull
 384 00d0 0346     		mov	r3, r0
 385 00d2 002B     		cmp	r3, #0
 386 00d4 12D0     		beq	.L15
 542:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 387              		.loc 1 542 0
 388 00d6 FB68     		ldr	r3, [r7, #12]
 389 00d8 03F11002 		add	r2, r3, #16
 390 00dc 7B68     		ldr	r3, [r7, #4]
 391 00de 1046     		mov	r0, r2
 392 00e0 1946     		mov	r1, r3
 393 00e2 FFF7FEFF 		bl	vTaskPlaceOnEventList
 549:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 394              		.loc 1 549 0
 395 00e6 F868     		ldr	r0, [r7, #12]
 396 00e8 FFF7FEFF 		bl	prvUnlockQueue
 556:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 397              		.loc 1 556 0
 398 00ec FFF7FEFF 		bl	xTaskResumeAll
 399 00f0 0346     		mov	r3, r0
 400 00f2 002B     		cmp	r3, #0
 401 00f4 8FD1     		bne	.L18
 558:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 402              		.loc 1 558 0
 403 00f6 FFF7FEFF 		bl	vPortYieldFromISR
 404              		.loc 1 579 0
 405 00fa 8DE7     		b	.L17
 406              	.L15:
 564:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 407              		.loc 1 564 0
 408 00fc F868     		ldr	r0, [r7, #12]
 409 00fe FFF7FEFF 		bl	prvUnlockQueue
 565:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 410              		.loc 1 565 0
 411 0102 FFF7FEFF 		bl	xTaskResumeAll
 412              		.loc 1 579 0
 413 0106 87E7     		b	.L17
 414              	.L14:
 571:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 415              		.loc 1 571 0
 416 0108 F868     		ldr	r0, [r7, #12]
 417 010a FFF7FEFF 		bl	prvUnlockQueue
 572:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 418              		.loc 1 572 0
 419 010e FFF7FEFF 		bl	xTaskResumeAll
 577:FreeRTOS/Source/queue.c **** 			return errQUEUE_FULL;
 420              		.loc 1 577 0
 421 0112 4FF00003 		mov	r3, #0
 422              	.L9:
 580:FreeRTOS/Source/queue.c **** }
 423              		.loc 1 580 0
 424 0116 1846     		mov	r0, r3
 425 0118 07F12007 		add	r7, r7, #32
 426 011c BD46     		mov	sp, r7
 427 011e 80BD     		pop	{r7, pc}
 428              		.cfi_endproc
 429              	.LFE112:
 431              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 432              		.align	2
 433              		.global	xQueueGenericSendFromISR
 434              		.thumb
 435              		.thumb_func
 437              	xQueueGenericSendFromISR:
 438              	.LFB113:
 581:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 582:FreeRTOS/Source/queue.c **** 
 583:FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 584:FreeRTOS/Source/queue.c **** 
 585:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 586:FreeRTOS/Source/queue.c **** 	{
 587:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 588:FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 589:FreeRTOS/Source/queue.c **** 
 590:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 591:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 592:FreeRTOS/Source/queue.c **** 
 593:FreeRTOS/Source/queue.c **** 		for( ;; )
 594:FreeRTOS/Source/queue.c **** 		{
 595:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 596:FreeRTOS/Source/queue.c **** 			{
 597:FreeRTOS/Source/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 598:FreeRTOS/Source/queue.c **** 				the highest priority task wanting to access the queue. */
 599:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 600:FreeRTOS/Source/queue.c **** 				{
 601:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND( pxQueue );
 602:FreeRTOS/Source/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 603:FreeRTOS/Source/queue.c **** 
 604:FreeRTOS/Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 605:FreeRTOS/Source/queue.c **** 					queue then unblock it now. */
 606:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 607:FreeRTOS/Source/queue.c **** 					{
 608:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 609:FreeRTOS/Source/queue.c **** 						{
 610:FreeRTOS/Source/queue.c **** 							/* The unblocked task has a priority higher than
 611:FreeRTOS/Source/queue.c **** 							our own so yield immediately. */
 612:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 613:FreeRTOS/Source/queue.c **** 						}
 614:FreeRTOS/Source/queue.c **** 					}
 615:FreeRTOS/Source/queue.c **** 
 616:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 617:FreeRTOS/Source/queue.c **** 					return pdPASS;
 618:FreeRTOS/Source/queue.c **** 				}
 619:FreeRTOS/Source/queue.c **** 				else
 620:FreeRTOS/Source/queue.c **** 				{
 621:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 622:FreeRTOS/Source/queue.c **** 					{
 623:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 624:FreeRTOS/Source/queue.c **** 						return errQUEUE_FULL;
 625:FreeRTOS/Source/queue.c **** 					}
 626:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 627:FreeRTOS/Source/queue.c **** 					{
 628:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 629:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 630:FreeRTOS/Source/queue.c **** 					}
 631:FreeRTOS/Source/queue.c **** 				}
 632:FreeRTOS/Source/queue.c **** 			}
 633:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 634:FreeRTOS/Source/queue.c **** 
 635:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 636:FreeRTOS/Source/queue.c **** 			{
 637:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 638:FreeRTOS/Source/queue.c **** 				{
 639:FreeRTOS/Source/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 640:FreeRTOS/Source/queue.c **** 					{
 641:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 642:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 643:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 644:FreeRTOS/Source/queue.c **** 					}
 645:FreeRTOS/Source/queue.c **** 				}
 646:FreeRTOS/Source/queue.c **** 				else
 647:FreeRTOS/Source/queue.c **** 				{
 648:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 649:FreeRTOS/Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 650:FreeRTOS/Source/queue.c **** 					return errQUEUE_FULL;
 651:FreeRTOS/Source/queue.c **** 				}
 652:FreeRTOS/Source/queue.c **** 			}
 653:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 654:FreeRTOS/Source/queue.c **** 		}
 655:FreeRTOS/Source/queue.c **** 	}
 656:FreeRTOS/Source/queue.c **** 
 657:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 658:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 659:FreeRTOS/Source/queue.c **** 
 660:FreeRTOS/Source/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 661:FreeRTOS/Source/queue.c **** 
 662:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 663:FreeRTOS/Source/queue.c **** 	{
 664:FreeRTOS/Source/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 665:FreeRTOS/Source/queue.c **** 	xTimeOutType xTimeOut;
 666:FreeRTOS/Source/queue.c **** 	signed char *pcOriginalReadPosition;
 667:FreeRTOS/Source/queue.c **** 
 668:FreeRTOS/Source/queue.c **** 		configASSERT( pxQueue );
 669:FreeRTOS/Source/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 670:FreeRTOS/Source/queue.c **** 
 671:FreeRTOS/Source/queue.c **** 		for( ;; )
 672:FreeRTOS/Source/queue.c **** 		{
 673:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 674:FreeRTOS/Source/queue.c **** 			{
 675:FreeRTOS/Source/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 676:FreeRTOS/Source/queue.c **** 				{
 677:FreeRTOS/Source/queue.c **** 					/* Remember our read position in case we are just peeking. */
 678:FreeRTOS/Source/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 679:FreeRTOS/Source/queue.c **** 
 680:FreeRTOS/Source/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 681:FreeRTOS/Source/queue.c **** 
 682:FreeRTOS/Source/queue.c **** 					if( xJustPeeking == pdFALSE )
 683:FreeRTOS/Source/queue.c **** 					{
 684:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 685:FreeRTOS/Source/queue.c **** 
 686:FreeRTOS/Source/queue.c **** 						/* We are actually removing data. */
 687:FreeRTOS/Source/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 688:FreeRTOS/Source/queue.c **** 
 689:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 690:FreeRTOS/Source/queue.c **** 						{
 691:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 692:FreeRTOS/Source/queue.c **** 							{
 693:FreeRTOS/Source/queue.c **** 								/* Record the information required to implement
 694:FreeRTOS/Source/queue.c **** 								priority inheritance should it become necessary. */
 695:FreeRTOS/Source/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 696:FreeRTOS/Source/queue.c **** 							}
 697:FreeRTOS/Source/queue.c **** 						}
 698:FreeRTOS/Source/queue.c **** 						#endif
 699:FreeRTOS/Source/queue.c **** 
 700:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 701:FreeRTOS/Source/queue.c **** 						{
 702:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 703:FreeRTOS/Source/queue.c **** 							{
 704:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 705:FreeRTOS/Source/queue.c **** 							}
 706:FreeRTOS/Source/queue.c **** 						}
 707:FreeRTOS/Source/queue.c **** 					}
 708:FreeRTOS/Source/queue.c **** 					else
 709:FreeRTOS/Source/queue.c **** 					{
 710:FreeRTOS/Source/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 711:FreeRTOS/Source/queue.c **** 
 712:FreeRTOS/Source/queue.c **** 						/* We are not removing the data, so reset our read
 713:FreeRTOS/Source/queue.c **** 						pointer. */
 714:FreeRTOS/Source/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 715:FreeRTOS/Source/queue.c **** 
 716:FreeRTOS/Source/queue.c **** 						/* The data is being left in the queue, so see if there are
 717:FreeRTOS/Source/queue.c **** 						any other tasks waiting for the data. */
 718:FreeRTOS/Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 719:FreeRTOS/Source/queue.c **** 						{
 720:FreeRTOS/Source/queue.c **** 							/* Tasks that are removed from the event list will get added to
 721:FreeRTOS/Source/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 722:FreeRTOS/Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 723:FreeRTOS/Source/queue.c **** 							{
 724:FreeRTOS/Source/queue.c **** 								/* The task waiting has a higher priority than this task. */
 725:FreeRTOS/Source/queue.c **** 								portYIELD_WITHIN_API();
 726:FreeRTOS/Source/queue.c **** 							}
 727:FreeRTOS/Source/queue.c **** 						}
 728:FreeRTOS/Source/queue.c **** 
 729:FreeRTOS/Source/queue.c **** 					}
 730:FreeRTOS/Source/queue.c **** 
 731:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 732:FreeRTOS/Source/queue.c **** 					return pdPASS;
 733:FreeRTOS/Source/queue.c **** 				}
 734:FreeRTOS/Source/queue.c **** 				else
 735:FreeRTOS/Source/queue.c **** 				{
 736:FreeRTOS/Source/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 737:FreeRTOS/Source/queue.c **** 					{
 738:FreeRTOS/Source/queue.c **** 						taskEXIT_CRITICAL();
 739:FreeRTOS/Source/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 740:FreeRTOS/Source/queue.c **** 						return errQUEUE_EMPTY;
 741:FreeRTOS/Source/queue.c **** 					}
 742:FreeRTOS/Source/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 743:FreeRTOS/Source/queue.c **** 					{
 744:FreeRTOS/Source/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 745:FreeRTOS/Source/queue.c **** 						xEntryTimeSet = pdTRUE;
 746:FreeRTOS/Source/queue.c **** 					}
 747:FreeRTOS/Source/queue.c **** 				}
 748:FreeRTOS/Source/queue.c **** 			}
 749:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 750:FreeRTOS/Source/queue.c **** 
 751:FreeRTOS/Source/queue.c **** 			taskENTER_CRITICAL();
 752:FreeRTOS/Source/queue.c **** 			{
 753:FreeRTOS/Source/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 754:FreeRTOS/Source/queue.c **** 				{
 755:FreeRTOS/Source/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 756:FreeRTOS/Source/queue.c **** 					{
 757:FreeRTOS/Source/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 758:FreeRTOS/Source/queue.c **** 
 759:FreeRTOS/Source/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 760:FreeRTOS/Source/queue.c **** 						{
 761:FreeRTOS/Source/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 762:FreeRTOS/Source/queue.c **** 							{
 763:FreeRTOS/Source/queue.c **** 								portENTER_CRITICAL();
 764:FreeRTOS/Source/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 765:FreeRTOS/Source/queue.c **** 								portEXIT_CRITICAL();
 766:FreeRTOS/Source/queue.c **** 							}
 767:FreeRTOS/Source/queue.c **** 						}
 768:FreeRTOS/Source/queue.c **** 						#endif
 769:FreeRTOS/Source/queue.c **** 
 770:FreeRTOS/Source/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 771:FreeRTOS/Source/queue.c **** 						portYIELD_WITHIN_API();
 772:FreeRTOS/Source/queue.c **** 					}
 773:FreeRTOS/Source/queue.c **** 				}
 774:FreeRTOS/Source/queue.c **** 				else
 775:FreeRTOS/Source/queue.c **** 				{
 776:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 777:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 778:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 779:FreeRTOS/Source/queue.c **** 				}
 780:FreeRTOS/Source/queue.c **** 			}
 781:FreeRTOS/Source/queue.c **** 			taskEXIT_CRITICAL();
 782:FreeRTOS/Source/queue.c **** 		}
 783:FreeRTOS/Source/queue.c **** 	}
 784:FreeRTOS/Source/queue.c **** 
 785:FreeRTOS/Source/queue.c **** 
 786:FreeRTOS/Source/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 787:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 788:FreeRTOS/Source/queue.c **** 
 789:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 790:FreeRTOS/Source/queue.c **** {
 439              		.loc 1 790 0
 440              		.cfi_startproc
 441              		@ args = 0, pretend = 0, frame = 24
 442              		@ frame_needed = 1, uses_anonymous_args = 0
 443 0000 80B5     		push	{r7, lr}
 444              	.LCFI9:
 445              		.cfi_def_cfa_offset 8
 446 0002 86B0     		sub	sp, sp, #24
 447              	.LCFI10:
 448              		.cfi_def_cfa_offset 32
 449 0004 00AF     		add	r7, sp, #0
 450              		.cfi_offset 14, -4
 451              		.cfi_offset 7, -8
 452              	.LCFI11:
 453              		.cfi_def_cfa_register 7
 454 0006 F860     		str	r0, [r7, #12]
 455 0008 B960     		str	r1, [r7, #8]
 456 000a 7A60     		str	r2, [r7, #4]
 457 000c 3B60     		str	r3, [r7, #0]
 791:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 792:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 793:FreeRTOS/Source/queue.c **** 
 794:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 795:FreeRTOS/Source/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 796:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 797:FreeRTOS/Source/queue.c **** 
 798:FreeRTOS/Source/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 799:FreeRTOS/Source/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 800:FreeRTOS/Source/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 801:FreeRTOS/Source/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 802:FreeRTOS/Source/queue.c **** 	by this	post). */
 803:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 458              		.loc 1 803 0
 459 000e 4FF00003 		mov	r3, #0
 460 0012 3B61     		str	r3, [r7, #16]
 461              	@ 803 "FreeRTOS/Source/queue.c" 1
 462 0014 4FF0BF00 			mov r0, #191								
 463 0018 80F31188 		msr basepri, r0							
 464              	
 465              	@ 0 "" 2
 804:FreeRTOS/Source/queue.c **** 	{
 805:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 466              		.loc 1 805 0
 467              		.thumb
 468 001c FB68     		ldr	r3, [r7, #12]
 469 001e 9A6B     		ldr	r2, [r3, #56]
 470 0020 FB68     		ldr	r3, [r7, #12]
 471 0022 DB6B     		ldr	r3, [r3, #60]
 472 0024 9A42     		cmp	r2, r3
 473 0026 25D2     		bcs	.L20
 806:FreeRTOS/Source/queue.c **** 		{
 807:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 808:FreeRTOS/Source/queue.c **** 
 809:FreeRTOS/Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 474              		.loc 1 809 0
 475 0028 F868     		ldr	r0, [r7, #12]
 476 002a B968     		ldr	r1, [r7, #8]
 477 002c 3A68     		ldr	r2, [r7, #0]
 478 002e FFF7FEFF 		bl	prvCopyDataToQueue
 810:FreeRTOS/Source/queue.c **** 
 811:FreeRTOS/Source/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 812:FreeRTOS/Source/queue.c **** 			be done when the queue is unlocked later. */
 813:FreeRTOS/Source/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 479              		.loc 1 813 0
 480 0032 FB68     		ldr	r3, [r7, #12]
 481 0034 9B6C     		ldr	r3, [r3, #72]
 482 0036 B3F1FF3F 		cmp	r3, #-1
 483 003a 11D1     		bne	.L21
 814:FreeRTOS/Source/queue.c **** 			{
 815:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 484              		.loc 1 815 0
 485 003c FB68     		ldr	r3, [r7, #12]
 486 003e 5B6A     		ldr	r3, [r3, #36]
 487 0040 002B     		cmp	r3, #0
 488 0042 13D0     		beq	.L22
 816:FreeRTOS/Source/queue.c **** 				{
 817:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 489              		.loc 1 817 0
 490 0044 FB68     		ldr	r3, [r7, #12]
 491 0046 03F12403 		add	r3, r3, #36
 492 004a 1846     		mov	r0, r3
 493 004c FFF7FEFF 		bl	xTaskRemoveFromEventList
 494 0050 0346     		mov	r3, r0
 495 0052 002B     		cmp	r3, #0
 496 0054 0AD0     		beq	.L22
 818:FreeRTOS/Source/queue.c **** 					{
 819:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority so record that a
 820:FreeRTOS/Source/queue.c **** 						context	switch is required. */
 821:FreeRTOS/Source/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 497              		.loc 1 821 0
 498 0056 7B68     		ldr	r3, [r7, #4]
 499 0058 4FF00102 		mov	r2, #1
 500 005c 1A60     		str	r2, [r3, #0]
 501 005e 05E0     		b	.L22
 502              	.L21:
 822:FreeRTOS/Source/queue.c **** 					}
 823:FreeRTOS/Source/queue.c **** 				}
 824:FreeRTOS/Source/queue.c **** 			}
 825:FreeRTOS/Source/queue.c **** 			else
 826:FreeRTOS/Source/queue.c **** 			{
 827:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 828:FreeRTOS/Source/queue.c **** 				knows that data was posted while it was locked. */
 829:FreeRTOS/Source/queue.c **** 				++( pxQueue->xTxLock );
 503              		.loc 1 829 0
 504 0060 FB68     		ldr	r3, [r7, #12]
 505 0062 9B6C     		ldr	r3, [r3, #72]
 506 0064 03F10102 		add	r2, r3, #1
 507 0068 FB68     		ldr	r3, [r7, #12]
 508 006a 9A64     		str	r2, [r3, #72]
 509              	.L22:
 830:FreeRTOS/Source/queue.c **** 			}
 831:FreeRTOS/Source/queue.c **** 
 832:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 510              		.loc 1 832 0
 511 006c 4FF00103 		mov	r3, #1
 512 0070 7B61     		str	r3, [r7, #20]
 513 0072 02E0     		b	.L23
 514              	.L20:
 833:FreeRTOS/Source/queue.c **** 		}
 834:FreeRTOS/Source/queue.c **** 		else
 835:FreeRTOS/Source/queue.c **** 		{
 836:FreeRTOS/Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 837:FreeRTOS/Source/queue.c **** 			xReturn = errQUEUE_FULL;
 515              		.loc 1 837 0
 516 0074 4FF00003 		mov	r3, #0
 517 0078 7B61     		str	r3, [r7, #20]
 518              	.L23:
 838:FreeRTOS/Source/queue.c **** 		}
 839:FreeRTOS/Source/queue.c **** 	}
 840:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 519              		.loc 1 840 0
 520              	@ 840 "FreeRTOS/Source/queue.c" 1
 521 007a 4FF00000 			mov r0, #0					
 522 007e 80F31188 		msr basepri, r0				
 523              	
 524              	@ 0 "" 2
 841:FreeRTOS/Source/queue.c **** 
 842:FreeRTOS/Source/queue.c **** 	return xReturn;
 525              		.loc 1 842 0
 526              		.thumb
 527 0082 7B69     		ldr	r3, [r7, #20]
 843:FreeRTOS/Source/queue.c **** }
 528              		.loc 1 843 0
 529 0084 1846     		mov	r0, r3
 530 0086 07F11807 		add	r7, r7, #24
 531 008a BD46     		mov	sp, r7
 532 008c 80BD     		pop	{r7, pc}
 533              		.cfi_endproc
 534              	.LFE113:
 536 008e 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 537              		.align	2
 538              		.global	xQueueGenericReceive
 539              		.thumb
 540              		.thumb_func
 542              	xQueueGenericReceive:
 543              	.LFB114:
 844:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 845:FreeRTOS/Source/queue.c **** 
 846:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 847:FreeRTOS/Source/queue.c **** {
 544              		.loc 1 847 0
 545              		.cfi_startproc
 546              		@ args = 0, pretend = 0, frame = 32
 547              		@ frame_needed = 1, uses_anonymous_args = 0
 548 0000 80B5     		push	{r7, lr}
 549              	.LCFI12:
 550              		.cfi_def_cfa_offset 8
 551 0002 88B0     		sub	sp, sp, #32
 552              	.LCFI13:
 553              		.cfi_def_cfa_offset 40
 554 0004 00AF     		add	r7, sp, #0
 555              		.cfi_offset 14, -4
 556              		.cfi_offset 7, -8
 557              	.LCFI14:
 558              		.cfi_def_cfa_register 7
 559 0006 F860     		str	r0, [r7, #12]
 560 0008 B960     		str	r1, [r7, #8]
 561 000a 7A60     		str	r2, [r7, #4]
 562 000c 3B60     		str	r3, [r7, #0]
 848:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 563              		.loc 1 848 0
 564 000e 4FF00003 		mov	r3, #0
 565 0012 FB61     		str	r3, [r7, #28]
 566 0014 00E0     		b	.L38
 567              	.L39:
 849:FreeRTOS/Source/queue.c **** xTimeOutType xTimeOut;
 850:FreeRTOS/Source/queue.c **** signed char *pcOriginalReadPosition;
 851:FreeRTOS/Source/queue.c **** 
 852:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
 853:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 854:FreeRTOS/Source/queue.c **** 
 855:FreeRTOS/Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 856:FreeRTOS/Source/queue.c **** 	statements within the function itself.  This is done in the interest
 857:FreeRTOS/Source/queue.c **** 	of execution time efficiency. */
 858:FreeRTOS/Source/queue.c **** 
 859:FreeRTOS/Source/queue.c **** 	for( ;; )
 860:FreeRTOS/Source/queue.c **** 	{
 861:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 862:FreeRTOS/Source/queue.c **** 		{
 863:FreeRTOS/Source/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 864:FreeRTOS/Source/queue.c **** 			the highest priority task wanting to access the queue. */
 865:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 866:FreeRTOS/Source/queue.c **** 			{
 867:FreeRTOS/Source/queue.c **** 				/* Remember our read position in case we are just peeking. */
 868:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 869:FreeRTOS/Source/queue.c **** 
 870:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 871:FreeRTOS/Source/queue.c **** 
 872:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 873:FreeRTOS/Source/queue.c **** 				{
 874:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 875:FreeRTOS/Source/queue.c **** 
 876:FreeRTOS/Source/queue.c **** 					/* We are actually removing data. */
 877:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 878:FreeRTOS/Source/queue.c **** 
 879:FreeRTOS/Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 880:FreeRTOS/Source/queue.c **** 					{
 881:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 882:FreeRTOS/Source/queue.c **** 						{
 883:FreeRTOS/Source/queue.c **** 							/* Record the information required to implement
 884:FreeRTOS/Source/queue.c **** 							priority inheritance should it become necessary. */
 885:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 886:FreeRTOS/Source/queue.c **** 						}
 887:FreeRTOS/Source/queue.c **** 					}
 888:FreeRTOS/Source/queue.c **** 					#endif
 889:FreeRTOS/Source/queue.c **** 
 890:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 891:FreeRTOS/Source/queue.c **** 					{
 892:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 893:FreeRTOS/Source/queue.c **** 						{
 894:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 895:FreeRTOS/Source/queue.c **** 						}
 896:FreeRTOS/Source/queue.c **** 					}
 897:FreeRTOS/Source/queue.c **** 				}
 898:FreeRTOS/Source/queue.c **** 				else
 899:FreeRTOS/Source/queue.c **** 				{
 900:FreeRTOS/Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 901:FreeRTOS/Source/queue.c **** 
 902:FreeRTOS/Source/queue.c **** 					/* We are not removing the data, so reset our read
 903:FreeRTOS/Source/queue.c **** 					pointer. */
 904:FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 905:FreeRTOS/Source/queue.c **** 
 906:FreeRTOS/Source/queue.c **** 					/* The data is being left in the queue, so see if there are
 907:FreeRTOS/Source/queue.c **** 					any other tasks waiting for the data. */
 908:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 909:FreeRTOS/Source/queue.c **** 					{
 910:FreeRTOS/Source/queue.c **** 						/* Tasks that are removed from the event list will get added to
 911:FreeRTOS/Source/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 912:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 913:FreeRTOS/Source/queue.c **** 						{
 914:FreeRTOS/Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
 915:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 916:FreeRTOS/Source/queue.c **** 						}
 917:FreeRTOS/Source/queue.c **** 					}
 918:FreeRTOS/Source/queue.c **** 
 919:FreeRTOS/Source/queue.c **** 				}
 920:FreeRTOS/Source/queue.c **** 
 921:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 922:FreeRTOS/Source/queue.c **** 				return pdPASS;
 923:FreeRTOS/Source/queue.c **** 			}
 924:FreeRTOS/Source/queue.c **** 			else
 925:FreeRTOS/Source/queue.c **** 			{
 926:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 927:FreeRTOS/Source/queue.c **** 				{
 928:FreeRTOS/Source/queue.c **** 					/* The queue was empty and no block time is specified (or
 929:FreeRTOS/Source/queue.c **** 					the block time has expired) so leave now. */
 930:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 931:FreeRTOS/Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 932:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 933:FreeRTOS/Source/queue.c **** 				}
 934:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 935:FreeRTOS/Source/queue.c **** 				{
 936:FreeRTOS/Source/queue.c **** 					/* The queue was empty and a block time was specified so
 937:FreeRTOS/Source/queue.c **** 					configure the timeout structure. */
 938:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 939:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 940:FreeRTOS/Source/queue.c **** 				}
 941:FreeRTOS/Source/queue.c **** 			}
 942:FreeRTOS/Source/queue.c **** 		}
 943:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 944:FreeRTOS/Source/queue.c **** 
 945:FreeRTOS/Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 946:FreeRTOS/Source/queue.c **** 		now the critical section has been exited. */
 947:FreeRTOS/Source/queue.c **** 
 948:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 950:FreeRTOS/Source/queue.c **** 
 951:FreeRTOS/Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 952:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 953:FreeRTOS/Source/queue.c **** 		{
 954:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 955:FreeRTOS/Source/queue.c **** 			{
 956:FreeRTOS/Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 957:FreeRTOS/Source/queue.c **** 
 958:FreeRTOS/Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 959:FreeRTOS/Source/queue.c **** 				{
 960:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 961:FreeRTOS/Source/queue.c **** 					{
 962:FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 963:FreeRTOS/Source/queue.c **** 						{
 964:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 965:FreeRTOS/Source/queue.c **** 						}
 966:FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 967:FreeRTOS/Source/queue.c **** 					}
 968:FreeRTOS/Source/queue.c **** 				}
 969:FreeRTOS/Source/queue.c **** 				#endif
 970:FreeRTOS/Source/queue.c **** 
 971:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 972:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 973:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 974:FreeRTOS/Source/queue.c **** 				{
 975:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 976:FreeRTOS/Source/queue.c **** 				}
 977:FreeRTOS/Source/queue.c **** 			}
 978:FreeRTOS/Source/queue.c **** 			else
 979:FreeRTOS/Source/queue.c **** 			{
 980:FreeRTOS/Source/queue.c **** 				/* Try again. */
 981:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 982:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 983:FreeRTOS/Source/queue.c **** 			}
 984:FreeRTOS/Source/queue.c **** 		}
 985:FreeRTOS/Source/queue.c **** 		else
 986:FreeRTOS/Source/queue.c **** 		{
 987:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 988:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 989:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
 990:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 991:FreeRTOS/Source/queue.c **** 		}
 992:FreeRTOS/Source/queue.c **** 	}
 568              		.loc 1 992 0
 569 0016 00BF     		nop
 570              	.L38:
 861:FreeRTOS/Source/queue.c **** 		taskENTER_CRITICAL();
 571              		.loc 1 861 0
 572 0018 FFF7FEFF 		bl	vPortEnterCritical
 865:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 573              		.loc 1 865 0
 574 001c FB68     		ldr	r3, [r7, #12]
 575 001e 9B6B     		ldr	r3, [r3, #56]
 576 0020 002B     		cmp	r3, #0
 577 0022 40D0     		beq	.L25
 868:FreeRTOS/Source/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 578              		.loc 1 868 0
 579 0024 FB68     		ldr	r3, [r7, #12]
 580 0026 DB68     		ldr	r3, [r3, #12]
 581 0028 BB61     		str	r3, [r7, #24]
 870:FreeRTOS/Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 582              		.loc 1 870 0
 583 002a F868     		ldr	r0, [r7, #12]
 584 002c B968     		ldr	r1, [r7, #8]
 585 002e FFF7FEFF 		bl	prvCopyDataFromQueue
 872:FreeRTOS/Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 586              		.loc 1 872 0
 587 0032 3B68     		ldr	r3, [r7, #0]
 588 0034 002B     		cmp	r3, #0
 589 0036 1FD1     		bne	.L26
 877:FreeRTOS/Source/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 590              		.loc 1 877 0
 591 0038 FB68     		ldr	r3, [r7, #12]
 592 003a 9B6B     		ldr	r3, [r3, #56]
 593 003c 03F1FF32 		add	r2, r3, #-1
 594 0040 FB68     		ldr	r3, [r7, #12]
 595 0042 9A63     		str	r2, [r3, #56]
 881:FreeRTOS/Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 596              		.loc 1 881 0
 597 0044 FB68     		ldr	r3, [r7, #12]
 598 0046 1B68     		ldr	r3, [r3, #0]
 599 0048 002B     		cmp	r3, #0
 600 004a 05D1     		bne	.L27
 885:FreeRTOS/Source/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 601              		.loc 1 885 0
 602 004c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 603 0050 0346     		mov	r3, r0
 604 0052 1A46     		mov	r2, r3
 605 0054 FB68     		ldr	r3, [r7, #12]
 606 0056 5A60     		str	r2, [r3, #4]
 607              	.L27:
 890:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 608              		.loc 1 890 0
 609 0058 FB68     		ldr	r3, [r7, #12]
 610 005a 1B69     		ldr	r3, [r3, #16]
 611 005c 002B     		cmp	r3, #0
 612 005e 1DD0     		beq	.L28
 892:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 613              		.loc 1 892 0
 614 0060 FB68     		ldr	r3, [r7, #12]
 615 0062 03F11003 		add	r3, r3, #16
 616 0066 1846     		mov	r0, r3
 617 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 618 006c 0346     		mov	r3, r0
 619 006e 012B     		cmp	r3, #1
 620 0070 14D1     		bne	.L28
 894:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 621              		.loc 1 894 0
 622 0072 FFF7FEFF 		bl	vPortYieldFromISR
 623 0076 11E0     		b	.L28
 624              	.L26:
 904:FreeRTOS/Source/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 625              		.loc 1 904 0
 626 0078 FB68     		ldr	r3, [r7, #12]
 627 007a BA69     		ldr	r2, [r7, #24]
 628 007c DA60     		str	r2, [r3, #12]
 908:FreeRTOS/Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 629              		.loc 1 908 0
 630 007e FB68     		ldr	r3, [r7, #12]
 631 0080 5B6A     		ldr	r3, [r3, #36]
 632 0082 002B     		cmp	r3, #0
 633 0084 0AD0     		beq	.L28
 912:FreeRTOS/Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 634              		.loc 1 912 0
 635 0086 FB68     		ldr	r3, [r7, #12]
 636 0088 03F12403 		add	r3, r3, #36
 637 008c 1846     		mov	r0, r3
 638 008e FFF7FEFF 		bl	xTaskRemoveFromEventList
 639 0092 0346     		mov	r3, r0
 640 0094 002B     		cmp	r3, #0
 641 0096 01D0     		beq	.L28
 915:FreeRTOS/Source/queue.c **** 							portYIELD_WITHIN_API();
 642              		.loc 1 915 0
 643 0098 FFF7FEFF 		bl	vPortYieldFromISR
 644              	.L28:
 921:FreeRTOS/Source/queue.c **** 				taskEXIT_CRITICAL();
 645              		.loc 1 921 0
 646 009c FFF7FEFF 		bl	vPortExitCritical
 922:FreeRTOS/Source/queue.c **** 				return pdPASS;
 647              		.loc 1 922 0
 648 00a0 4FF00103 		mov	r3, #1
 649 00a4 6BE0     		b	.L29
 650              	.L25:
 926:FreeRTOS/Source/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 651              		.loc 1 926 0
 652 00a6 7B68     		ldr	r3, [r7, #4]
 653 00a8 002B     		cmp	r3, #0
 654 00aa 04D1     		bne	.L30
 930:FreeRTOS/Source/queue.c **** 					taskEXIT_CRITICAL();
 655              		.loc 1 930 0
 656 00ac FFF7FEFF 		bl	vPortExitCritical
 932:FreeRTOS/Source/queue.c **** 					return errQUEUE_EMPTY;
 657              		.loc 1 932 0
 658 00b0 4FF00003 		mov	r3, #0
 659 00b4 63E0     		b	.L29
 660              	.L30:
 934:FreeRTOS/Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 661              		.loc 1 934 0
 662 00b6 FB69     		ldr	r3, [r7, #28]
 663 00b8 002B     		cmp	r3, #0
 664 00ba 07D1     		bne	.L31
 938:FreeRTOS/Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 665              		.loc 1 938 0
 666 00bc 07F11003 		add	r3, r7, #16
 667 00c0 1846     		mov	r0, r3
 668 00c2 FFF7FEFF 		bl	vTaskSetTimeOutState
 939:FreeRTOS/Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 669              		.loc 1 939 0
 670 00c6 4FF00103 		mov	r3, #1
 671 00ca FB61     		str	r3, [r7, #28]
 672              	.L31:
 943:FreeRTOS/Source/queue.c **** 		taskEXIT_CRITICAL();
 673              		.loc 1 943 0
 674 00cc FFF7FEFF 		bl	vPortExitCritical
 948:FreeRTOS/Source/queue.c **** 		vTaskSuspendAll();
 675              		.loc 1 948 0
 676 00d0 FFF7FEFF 		bl	vTaskSuspendAll
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 677              		.loc 1 949 0
 678 00d4 FFF7FEFF 		bl	vPortEnterCritical
 679 00d8 FB68     		ldr	r3, [r7, #12]
 680 00da 5B6C     		ldr	r3, [r3, #68]
 681 00dc B3F1FF3F 		cmp	r3, #-1
 682 00e0 03D1     		bne	.L32
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 683              		.loc 1 949 0 is_stmt 0 discriminator 1
 684 00e2 FB68     		ldr	r3, [r7, #12]
 685 00e4 4FF00002 		mov	r2, #0
 686 00e8 5A64     		str	r2, [r3, #68]
 687              	.L32:
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 688              		.loc 1 949 0 discriminator 2
 689 00ea FB68     		ldr	r3, [r7, #12]
 690 00ec 9B6C     		ldr	r3, [r3, #72]
 691 00ee B3F1FF3F 		cmp	r3, #-1
 692 00f2 03D1     		bne	.L33
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 693              		.loc 1 949 0 discriminator 3
 694 00f4 FB68     		ldr	r3, [r7, #12]
 695 00f6 4FF00002 		mov	r2, #0
 696 00fa 9A64     		str	r2, [r3, #72]
 697              	.L33:
 949:FreeRTOS/Source/queue.c **** 		prvLockQueue( pxQueue );
 698              		.loc 1 949 0 discriminator 4
 699 00fc FFF7FEFF 		bl	vPortExitCritical
 952:FreeRTOS/Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 700              		.loc 1 952 0 is_stmt 1 discriminator 4
 701 0100 07F11002 		add	r2, r7, #16
 702 0104 07F10403 		add	r3, r7, #4
 703 0108 1046     		mov	r0, r2
 704 010a 1946     		mov	r1, r3
 705 010c FFF7FEFF 		bl	xTaskCheckForTimeOut
 706 0110 0346     		mov	r3, r0
 707 0112 002B     		cmp	r3, #0
 708 0114 2CD1     		bne	.L34
 954:FreeRTOS/Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 709              		.loc 1 954 0
 710 0116 F868     		ldr	r0, [r7, #12]
 711 0118 FFF7FEFF 		bl	prvIsQueueEmpty
 712 011c 0346     		mov	r3, r0
 713 011e 002B     		cmp	r3, #0
 714 0120 20D0     		beq	.L35
 960:FreeRTOS/Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 715              		.loc 1 960 0
 716 0122 FB68     		ldr	r3, [r7, #12]
 717 0124 1B68     		ldr	r3, [r3, #0]
 718 0126 002B     		cmp	r3, #0
 719 0128 08D1     		bne	.L36
 962:FreeRTOS/Source/queue.c **** 						portENTER_CRITICAL();
 720              		.loc 1 962 0
 721 012a FFF7FEFF 		bl	vPortEnterCritical
 964:FreeRTOS/Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 722              		.loc 1 964 0
 723 012e FB68     		ldr	r3, [r7, #12]
 724 0130 5B68     		ldr	r3, [r3, #4]
 725 0132 1846     		mov	r0, r3
 726 0134 FFF7FEFF 		bl	vTaskPriorityInherit
 966:FreeRTOS/Source/queue.c **** 						portEXIT_CRITICAL();
 727              		.loc 1 966 0
 728 0138 FFF7FEFF 		bl	vPortExitCritical
 729              	.L36:
 971:FreeRTOS/Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 730              		.loc 1 971 0
 731 013c FB68     		ldr	r3, [r7, #12]
 732 013e 03F12402 		add	r2, r3, #36
 733 0142 7B68     		ldr	r3, [r7, #4]
 734 0144 1046     		mov	r0, r2
 735 0146 1946     		mov	r1, r3
 736 0148 FFF7FEFF 		bl	vTaskPlaceOnEventList
 972:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 737              		.loc 1 972 0
 738 014c F868     		ldr	r0, [r7, #12]
 739 014e FFF7FEFF 		bl	prvUnlockQueue
 973:FreeRTOS/Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 740              		.loc 1 973 0
 741 0152 FFF7FEFF 		bl	xTaskResumeAll
 742 0156 0346     		mov	r3, r0
 743 0158 002B     		cmp	r3, #0
 744 015a 7FF45CAF 		bne	.L39
 975:FreeRTOS/Source/queue.c **** 					portYIELD_WITHIN_API();
 745              		.loc 1 975 0
 746 015e FFF7FEFF 		bl	vPortYieldFromISR
 747              		.loc 1 992 0
 748 0162 59E7     		b	.L38
 749              	.L35:
 981:FreeRTOS/Source/queue.c **** 				prvUnlockQueue( pxQueue );
 750              		.loc 1 981 0
 751 0164 F868     		ldr	r0, [r7, #12]
 752 0166 FFF7FEFF 		bl	prvUnlockQueue
 982:FreeRTOS/Source/queue.c **** 				( void ) xTaskResumeAll();
 753              		.loc 1 982 0
 754 016a FFF7FEFF 		bl	xTaskResumeAll
 755              		.loc 1 992 0
 756 016e 53E7     		b	.L38
 757              	.L34:
 987:FreeRTOS/Source/queue.c **** 			prvUnlockQueue( pxQueue );
 758              		.loc 1 987 0
 759 0170 F868     		ldr	r0, [r7, #12]
 760 0172 FFF7FEFF 		bl	prvUnlockQueue
 988:FreeRTOS/Source/queue.c **** 			( void ) xTaskResumeAll();
 761              		.loc 1 988 0
 762 0176 FFF7FEFF 		bl	xTaskResumeAll
 990:FreeRTOS/Source/queue.c **** 			return errQUEUE_EMPTY;
 763              		.loc 1 990 0
 764 017a 4FF00003 		mov	r3, #0
 765              	.L29:
 993:FreeRTOS/Source/queue.c **** }
 766              		.loc 1 993 0
 767 017e 1846     		mov	r0, r3
 768 0180 07F12007 		add	r7, r7, #32
 769 0184 BD46     		mov	sp, r7
 770 0186 80BD     		pop	{r7, pc}
 771              		.cfi_endproc
 772              	.LFE114:
 774              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 775              		.align	2
 776              		.global	xQueueReceiveFromISR
 777              		.thumb
 778              		.thumb_func
 780              	xQueueReceiveFromISR:
 781              	.LFB115:
 994:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 995:FreeRTOS/Source/queue.c **** 
 996:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 997:FreeRTOS/Source/queue.c **** {
 782              		.loc 1 997 0
 783              		.cfi_startproc
 784              		@ args = 0, pretend = 0, frame = 24
 785              		@ frame_needed = 1, uses_anonymous_args = 0
 786 0000 80B5     		push	{r7, lr}
 787              	.LCFI15:
 788              		.cfi_def_cfa_offset 8
 789 0002 86B0     		sub	sp, sp, #24
 790              	.LCFI16:
 791              		.cfi_def_cfa_offset 32
 792 0004 00AF     		add	r7, sp, #0
 793              		.cfi_offset 14, -4
 794              		.cfi_offset 7, -8
 795              	.LCFI17:
 796              		.cfi_def_cfa_register 7
 797 0006 F860     		str	r0, [r7, #12]
 798 0008 B960     		str	r1, [r7, #8]
 799 000a 7A60     		str	r2, [r7, #4]
 998:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
 999:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1000:FreeRTOS/Source/queue.c **** 
1001:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1002:FreeRTOS/Source/queue.c **** 	configASSERT( pxTaskWoken );
1003:FreeRTOS/Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1004:FreeRTOS/Source/queue.c **** 
1005:FreeRTOS/Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800              		.loc 1 1005 0
 801 000c 4FF00003 		mov	r3, #0
 802 0010 3B61     		str	r3, [r7, #16]
 803              	@ 1005 "FreeRTOS/Source/queue.c" 1
 804 0012 4FF0BF00 			mov r0, #191								
 805 0016 80F31188 		msr basepri, r0							
 806              	
 807              	@ 0 "" 2
1006:FreeRTOS/Source/queue.c **** 	{
1007:FreeRTOS/Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1008:FreeRTOS/Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 808              		.loc 1 1008 0
 809              		.thumb
 810 001a FB68     		ldr	r3, [r7, #12]
 811 001c 9B6B     		ldr	r3, [r3, #56]
 812 001e 002B     		cmp	r3, #0
 813 0020 2AD0     		beq	.L41
1009:FreeRTOS/Source/queue.c **** 		{
1010:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1011:FreeRTOS/Source/queue.c **** 
1012:FreeRTOS/Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 814              		.loc 1 1012 0
 815 0022 F868     		ldr	r0, [r7, #12]
 816 0024 B968     		ldr	r1, [r7, #8]
 817 0026 FFF7FEFF 		bl	prvCopyDataFromQueue
1013:FreeRTOS/Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 818              		.loc 1 1013 0
 819 002a FB68     		ldr	r3, [r7, #12]
 820 002c 9B6B     		ldr	r3, [r3, #56]
 821 002e 03F1FF32 		add	r2, r3, #-1
 822 0032 FB68     		ldr	r3, [r7, #12]
 823 0034 9A63     		str	r2, [r3, #56]
1014:FreeRTOS/Source/queue.c **** 
1015:FreeRTOS/Source/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1016:FreeRTOS/Source/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1017:FreeRTOS/Source/queue.c **** 			that an ISR has removed data while the queue was locked. */
1018:FreeRTOS/Source/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 824              		.loc 1 1018 0
 825 0036 FB68     		ldr	r3, [r7, #12]
 826 0038 5B6C     		ldr	r3, [r3, #68]
 827 003a B3F1FF3F 		cmp	r3, #-1
 828 003e 11D1     		bne	.L42
1019:FreeRTOS/Source/queue.c **** 			{
1020:FreeRTOS/Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 829              		.loc 1 1020 0
 830 0040 FB68     		ldr	r3, [r7, #12]
 831 0042 1B69     		ldr	r3, [r3, #16]
 832 0044 002B     		cmp	r3, #0
 833 0046 13D0     		beq	.L43
1021:FreeRTOS/Source/queue.c **** 				{
1022:FreeRTOS/Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 834              		.loc 1 1022 0
 835 0048 FB68     		ldr	r3, [r7, #12]
 836 004a 03F11003 		add	r3, r3, #16
 837 004e 1846     		mov	r0, r3
 838 0050 FFF7FEFF 		bl	xTaskRemoveFromEventList
 839 0054 0346     		mov	r3, r0
 840 0056 002B     		cmp	r3, #0
 841 0058 0AD0     		beq	.L43
1023:FreeRTOS/Source/queue.c **** 					{
1024:FreeRTOS/Source/queue.c **** 						/* The task waiting has a higher priority than us so
1025:FreeRTOS/Source/queue.c **** 						force a context switch. */
1026:FreeRTOS/Source/queue.c **** 						*pxTaskWoken = pdTRUE;
 842              		.loc 1 1026 0
 843 005a 7B68     		ldr	r3, [r7, #4]
 844 005c 4FF00102 		mov	r2, #1
 845 0060 1A60     		str	r2, [r3, #0]
 846 0062 05E0     		b	.L43
 847              	.L42:
1027:FreeRTOS/Source/queue.c **** 					}
1028:FreeRTOS/Source/queue.c **** 				}
1029:FreeRTOS/Source/queue.c **** 			}
1030:FreeRTOS/Source/queue.c **** 			else
1031:FreeRTOS/Source/queue.c **** 			{
1032:FreeRTOS/Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1033:FreeRTOS/Source/queue.c **** 				knows that data was removed while it was locked. */
1034:FreeRTOS/Source/queue.c **** 				++( pxQueue->xRxLock );
 848              		.loc 1 1034 0
 849 0064 FB68     		ldr	r3, [r7, #12]
 850 0066 5B6C     		ldr	r3, [r3, #68]
 851 0068 03F10102 		add	r2, r3, #1
 852 006c FB68     		ldr	r3, [r7, #12]
 853 006e 5A64     		str	r2, [r3, #68]
 854              	.L43:
1035:FreeRTOS/Source/queue.c **** 			}
1036:FreeRTOS/Source/queue.c **** 
1037:FreeRTOS/Source/queue.c **** 			xReturn = pdPASS;
 855              		.loc 1 1037 0
 856 0070 4FF00103 		mov	r3, #1
 857 0074 7B61     		str	r3, [r7, #20]
 858 0076 02E0     		b	.L44
 859              	.L41:
1038:FreeRTOS/Source/queue.c **** 		}
1039:FreeRTOS/Source/queue.c **** 		else
1040:FreeRTOS/Source/queue.c **** 		{
1041:FreeRTOS/Source/queue.c **** 			xReturn = pdFAIL;
 860              		.loc 1 1041 0
 861 0078 4FF00003 		mov	r3, #0
 862 007c 7B61     		str	r3, [r7, #20]
 863              	.L44:
1042:FreeRTOS/Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1043:FreeRTOS/Source/queue.c **** 		}
1044:FreeRTOS/Source/queue.c **** 	}
1045:FreeRTOS/Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 864              		.loc 1 1045 0
 865              	@ 1045 "FreeRTOS/Source/queue.c" 1
 866 007e 4FF00000 			mov r0, #0					
 867 0082 80F31188 		msr basepri, r0				
 868              	
 869              	@ 0 "" 2
1046:FreeRTOS/Source/queue.c **** 
1047:FreeRTOS/Source/queue.c **** 	return xReturn;
 870              		.loc 1 1047 0
 871              		.thumb
 872 0086 7B69     		ldr	r3, [r7, #20]
1048:FreeRTOS/Source/queue.c **** }
 873              		.loc 1 1048 0
 874 0088 1846     		mov	r0, r3
 875 008a 07F11807 		add	r7, r7, #24
 876 008e BD46     		mov	sp, r7
 877 0090 80BD     		pop	{r7, pc}
 878              		.cfi_endproc
 879              	.LFE115:
 881 0092 00BF     		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 882              		.align	2
 883              		.global	uxQueueMessagesWaiting
 884              		.thumb
 885              		.thumb_func
 887              	uxQueueMessagesWaiting:
 888              	.LFB116:
1049:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1050:FreeRTOS/Source/queue.c **** 
1051:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1052:FreeRTOS/Source/queue.c **** {
 889              		.loc 1 1052 0
 890              		.cfi_startproc
 891              		@ args = 0, pretend = 0, frame = 16
 892              		@ frame_needed = 1, uses_anonymous_args = 0
 893 0000 80B5     		push	{r7, lr}
 894              	.LCFI18:
 895              		.cfi_def_cfa_offset 8
 896 0002 84B0     		sub	sp, sp, #16
 897              	.LCFI19:
 898              		.cfi_def_cfa_offset 24
 899 0004 00AF     		add	r7, sp, #0
 900              		.cfi_offset 14, -4
 901              		.cfi_offset 7, -8
 902              	.LCFI20:
 903              		.cfi_def_cfa_register 7
 904 0006 7860     		str	r0, [r7, #4]
1053:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1054:FreeRTOS/Source/queue.c **** 
1055:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1056:FreeRTOS/Source/queue.c **** 
1057:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 905              		.loc 1 1057 0
 906 0008 FFF7FEFF 		bl	vPortEnterCritical
1058:FreeRTOS/Source/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 907              		.loc 1 1058 0
 908 000c 7B68     		ldr	r3, [r7, #4]
 909 000e 9B6B     		ldr	r3, [r3, #56]
 910 0010 FB60     		str	r3, [r7, #12]
1059:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 911              		.loc 1 1059 0
 912 0012 FFF7FEFF 		bl	vPortExitCritical
1060:FreeRTOS/Source/queue.c **** 
1061:FreeRTOS/Source/queue.c **** 	return uxReturn;
 913              		.loc 1 1061 0
 914 0016 FB68     		ldr	r3, [r7, #12]
1062:FreeRTOS/Source/queue.c **** }
 915              		.loc 1 1062 0
 916 0018 1846     		mov	r0, r3
 917 001a 07F11007 		add	r7, r7, #16
 918 001e BD46     		mov	sp, r7
 919 0020 80BD     		pop	{r7, pc}
 920              		.cfi_endproc
 921              	.LFE116:
 923 0022 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 924              		.align	2
 925              		.global	uxQueueMessagesWaitingFromISR
 926              		.thumb
 927              		.thumb_func
 929              	uxQueueMessagesWaitingFromISR:
 930              	.LFB117:
1063:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1064:FreeRTOS/Source/queue.c **** 
1065:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1066:FreeRTOS/Source/queue.c **** {
 931              		.loc 1 1066 0
 932              		.cfi_startproc
 933              		@ args = 0, pretend = 0, frame = 16
 934              		@ frame_needed = 1, uses_anonymous_args = 0
 935              		@ link register save eliminated.
 936 0000 80B4     		push	{r7}
 937              	.LCFI21:
 938              		.cfi_def_cfa_offset 4
 939 0002 85B0     		sub	sp, sp, #20
 940              	.LCFI22:
 941              		.cfi_def_cfa_offset 24
 942 0004 00AF     		add	r7, sp, #0
 943              		.cfi_offset 7, -4
 944              	.LCFI23:
 945              		.cfi_def_cfa_register 7
 946 0006 7860     		str	r0, [r7, #4]
1067:FreeRTOS/Source/queue.c **** unsigned portBASE_TYPE uxReturn;
1068:FreeRTOS/Source/queue.c **** 
1069:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1070:FreeRTOS/Source/queue.c **** 
1071:FreeRTOS/Source/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 947              		.loc 1 1071 0
 948 0008 7B68     		ldr	r3, [r7, #4]
 949 000a 9B6B     		ldr	r3, [r3, #56]
 950 000c FB60     		str	r3, [r7, #12]
1072:FreeRTOS/Source/queue.c **** 
1073:FreeRTOS/Source/queue.c **** 	return uxReturn;
 951              		.loc 1 1073 0
 952 000e FB68     		ldr	r3, [r7, #12]
1074:FreeRTOS/Source/queue.c **** }
 953              		.loc 1 1074 0
 954 0010 1846     		mov	r0, r3
 955 0012 07F11407 		add	r7, r7, #20
 956 0016 BD46     		mov	sp, r7
 957 0018 80BC     		pop	{r7}
 958 001a 7047     		bx	lr
 959              		.cfi_endproc
 960              	.LFE117:
 962              		.section	.text.vQueueDelete,"ax",%progbits
 963              		.align	2
 964              		.global	vQueueDelete
 965              		.thumb
 966              		.thumb_func
 968              	vQueueDelete:
 969              	.LFB118:
1075:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1076:FreeRTOS/Source/queue.c **** 
1077:FreeRTOS/Source/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1078:FreeRTOS/Source/queue.c **** {
 970              		.loc 1 1078 0
 971              		.cfi_startproc
 972              		@ args = 0, pretend = 0, frame = 8
 973              		@ frame_needed = 1, uses_anonymous_args = 0
 974 0000 80B5     		push	{r7, lr}
 975              	.LCFI24:
 976              		.cfi_def_cfa_offset 8
 977 0002 82B0     		sub	sp, sp, #8
 978              	.LCFI25:
 979              		.cfi_def_cfa_offset 16
 980 0004 00AF     		add	r7, sp, #0
 981              		.cfi_offset 14, -4
 982              		.cfi_offset 7, -8
 983              	.LCFI26:
 984              		.cfi_def_cfa_register 7
 985 0006 7860     		str	r0, [r7, #4]
1079:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1080:FreeRTOS/Source/queue.c **** 
1081:FreeRTOS/Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1082:FreeRTOS/Source/queue.c **** 	vQueueUnregisterQueue( pxQueue );
1083:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue->pcHead );
 986              		.loc 1 1083 0
 987 0008 7B68     		ldr	r3, [r7, #4]
 988 000a 1B68     		ldr	r3, [r3, #0]
 989 000c 1846     		mov	r0, r3
 990 000e FFF7FEFF 		bl	free
1084:FreeRTOS/Source/queue.c **** 	vPortFree( pxQueue );
 991              		.loc 1 1084 0
 992 0012 7868     		ldr	r0, [r7, #4]
 993 0014 FFF7FEFF 		bl	free
1085:FreeRTOS/Source/queue.c **** }
 994              		.loc 1 1085 0
 995 0018 07F10807 		add	r7, r7, #8
 996 001c BD46     		mov	sp, r7
 997 001e 80BD     		pop	{r7, pc}
 998              		.cfi_endproc
 999              	.LFE118:
 1001              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1002              		.align	2
 1003              		.thumb
 1004              		.thumb_func
 1006              	prvCopyDataToQueue:
 1007              	.LFB119:
1086:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1087:FreeRTOS/Source/queue.c **** 
1088:FreeRTOS/Source/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1089:FreeRTOS/Source/queue.c **** {
 1008              		.loc 1 1089 0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 16
 1011              		@ frame_needed = 1, uses_anonymous_args = 0
 1012 0000 80B5     		push	{r7, lr}
 1013              	.LCFI27:
 1014              		.cfi_def_cfa_offset 8
 1015 0002 84B0     		sub	sp, sp, #16
 1016              	.LCFI28:
 1017              		.cfi_def_cfa_offset 24
 1018 0004 00AF     		add	r7, sp, #0
 1019              		.cfi_offset 14, -4
 1020              		.cfi_offset 7, -8
 1021              	.LCFI29:
 1022              		.cfi_def_cfa_register 7
 1023 0006 F860     		str	r0, [r7, #12]
 1024 0008 B960     		str	r1, [r7, #8]
 1025 000a 7A60     		str	r2, [r7, #4]
1090:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 1026              		.loc 1 1090 0
 1027 000c FB68     		ldr	r3, [r7, #12]
 1028 000e 1B6C     		ldr	r3, [r3, #64]
 1029 0010 002B     		cmp	r3, #0
 1030 0012 0DD1     		bne	.L49
1091:FreeRTOS/Source/queue.c **** 	{
1092:FreeRTOS/Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1093:FreeRTOS/Source/queue.c **** 		{
1094:FreeRTOS/Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1031              		.loc 1 1094 0
 1032 0014 FB68     		ldr	r3, [r7, #12]
 1033 0016 1B68     		ldr	r3, [r3, #0]
 1034 0018 002B     		cmp	r3, #0
 1035 001a 48D1     		bne	.L50
1095:FreeRTOS/Source/queue.c **** 			{
1096:FreeRTOS/Source/queue.c **** 				/* The mutex is no longer being held. */
1097:FreeRTOS/Source/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1036              		.loc 1 1097 0
 1037 001c FB68     		ldr	r3, [r7, #12]
 1038 001e 5B68     		ldr	r3, [r3, #4]
 1039 0020 1846     		mov	r0, r3
 1040 0022 FFF7FEFF 		bl	vTaskPriorityDisinherit
1098:FreeRTOS/Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1041              		.loc 1 1098 0
 1042 0026 FB68     		ldr	r3, [r7, #12]
 1043 0028 4FF00002 		mov	r2, #0
 1044 002c 5A60     		str	r2, [r3, #4]
 1045 002e 3EE0     		b	.L50
 1046              	.L49:
1099:FreeRTOS/Source/queue.c **** 			}
1100:FreeRTOS/Source/queue.c **** 		}
1101:FreeRTOS/Source/queue.c **** 		#endif
1102:FreeRTOS/Source/queue.c **** 	}
1103:FreeRTOS/Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1047              		.loc 1 1103 0
 1048 0030 7B68     		ldr	r3, [r7, #4]
 1049 0032 002B     		cmp	r3, #0
 1050 0034 1AD1     		bne	.L51
1104:FreeRTOS/Source/queue.c **** 	{
1105:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1051              		.loc 1 1105 0
 1052 0036 FB68     		ldr	r3, [r7, #12]
 1053 0038 9A68     		ldr	r2, [r3, #8]
 1054 003a FB68     		ldr	r3, [r7, #12]
 1055 003c 1B6C     		ldr	r3, [r3, #64]
 1056 003e 1046     		mov	r0, r2
 1057 0040 B968     		ldr	r1, [r7, #8]
 1058 0042 1A46     		mov	r2, r3
 1059 0044 FFF7FEFF 		bl	memcpy
1106:FreeRTOS/Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1060              		.loc 1 1106 0
 1061 0048 FB68     		ldr	r3, [r7, #12]
 1062 004a 9A68     		ldr	r2, [r3, #8]
 1063 004c FB68     		ldr	r3, [r7, #12]
 1064 004e 1B6C     		ldr	r3, [r3, #64]
 1065 0050 D218     		adds	r2, r2, r3
 1066 0052 FB68     		ldr	r3, [r7, #12]
 1067 0054 9A60     		str	r2, [r3, #8]
1107:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 1068              		.loc 1 1107 0
 1069 0056 FB68     		ldr	r3, [r7, #12]
 1070 0058 9A68     		ldr	r2, [r3, #8]
 1071 005a FB68     		ldr	r3, [r7, #12]
 1072 005c 5B68     		ldr	r3, [r3, #4]
 1073 005e 9A42     		cmp	r2, r3
 1074 0060 25D3     		bcc	.L50
1108:FreeRTOS/Source/queue.c **** 		{
1109:FreeRTOS/Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1075              		.loc 1 1109 0
 1076 0062 FB68     		ldr	r3, [r7, #12]
 1077 0064 1A68     		ldr	r2, [r3, #0]
 1078 0066 FB68     		ldr	r3, [r7, #12]
 1079 0068 9A60     		str	r2, [r3, #8]
 1080 006a 20E0     		b	.L50
 1081              	.L51:
1110:FreeRTOS/Source/queue.c **** 		}
1111:FreeRTOS/Source/queue.c **** 	}
1112:FreeRTOS/Source/queue.c **** 	else
1113:FreeRTOS/Source/queue.c **** 	{
1114:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 1082              		.loc 1 1114 0
 1083 006c FB68     		ldr	r3, [r7, #12]
 1084 006e DA68     		ldr	r2, [r3, #12]
 1085 0070 FB68     		ldr	r3, [r7, #12]
 1086 0072 1B6C     		ldr	r3, [r3, #64]
 1087 0074 1046     		mov	r0, r2
 1088 0076 B968     		ldr	r1, [r7, #8]
 1089 0078 1A46     		mov	r2, r3
 1090 007a FFF7FEFF 		bl	memcpy
1115:FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 1091              		.loc 1 1115 0
 1092 007e FB68     		ldr	r3, [r7, #12]
 1093 0080 DA68     		ldr	r2, [r3, #12]
 1094 0082 FB68     		ldr	r3, [r7, #12]
 1095 0084 1B6C     		ldr	r3, [r3, #64]
 1096 0086 C3F10003 		rsb	r3, r3, #0
 1097 008a D218     		adds	r2, r2, r3
 1098 008c FB68     		ldr	r3, [r7, #12]
 1099 008e DA60     		str	r2, [r3, #12]
1116:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 1100              		.loc 1 1116 0
 1101 0090 FB68     		ldr	r3, [r7, #12]
 1102 0092 DA68     		ldr	r2, [r3, #12]
 1103 0094 FB68     		ldr	r3, [r7, #12]
 1104 0096 1B68     		ldr	r3, [r3, #0]
 1105 0098 9A42     		cmp	r2, r3
 1106 009a 08D2     		bcs	.L50
1117:FreeRTOS/Source/queue.c **** 		{
1118:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1107              		.loc 1 1118 0
 1108 009c FB68     		ldr	r3, [r7, #12]
 1109 009e 5A68     		ldr	r2, [r3, #4]
 1110 00a0 FB68     		ldr	r3, [r7, #12]
 1111 00a2 1B6C     		ldr	r3, [r3, #64]
 1112 00a4 C3F10003 		rsb	r3, r3, #0
 1113 00a8 D218     		adds	r2, r2, r3
 1114 00aa FB68     		ldr	r3, [r7, #12]
 1115 00ac DA60     		str	r2, [r3, #12]
 1116              	.L50:
1119:FreeRTOS/Source/queue.c **** 		}
1120:FreeRTOS/Source/queue.c **** 	}
1121:FreeRTOS/Source/queue.c **** 
1122:FreeRTOS/Source/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 1117              		.loc 1 1122 0
 1118 00ae FB68     		ldr	r3, [r7, #12]
 1119 00b0 9B6B     		ldr	r3, [r3, #56]
 1120 00b2 03F10102 		add	r2, r3, #1
 1121 00b6 FB68     		ldr	r3, [r7, #12]
 1122 00b8 9A63     		str	r2, [r3, #56]
1123:FreeRTOS/Source/queue.c **** }
 1123              		.loc 1 1123 0
 1124 00ba 07F11007 		add	r7, r7, #16
 1125 00be BD46     		mov	sp, r7
 1126 00c0 80BD     		pop	{r7, pc}
 1127              		.cfi_endproc
 1128              	.LFE119:
 1130 00c2 00BF     		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1131              		.align	2
 1132              		.thumb
 1133              		.thumb_func
 1135              	prvCopyDataFromQueue:
 1136              	.LFB120:
1124:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1125:FreeRTOS/Source/queue.c **** 
1126:FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1127:FreeRTOS/Source/queue.c **** {
 1137              		.loc 1 1127 0
 1138              		.cfi_startproc
 1139              		@ args = 0, pretend = 0, frame = 8
 1140              		@ frame_needed = 1, uses_anonymous_args = 0
 1141 0000 80B5     		push	{r7, lr}
 1142              	.LCFI30:
 1143              		.cfi_def_cfa_offset 8
 1144 0002 82B0     		sub	sp, sp, #8
 1145              	.LCFI31:
 1146              		.cfi_def_cfa_offset 16
 1147 0004 00AF     		add	r7, sp, #0
 1148              		.cfi_offset 14, -4
 1149              		.cfi_offset 7, -8
 1150              	.LCFI32:
 1151              		.cfi_def_cfa_register 7
 1152 0006 7860     		str	r0, [r7, #4]
 1153 0008 3960     		str	r1, [r7, #0]
1128:FreeRTOS/Source/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 1154              		.loc 1 1128 0
 1155 000a 7B68     		ldr	r3, [r7, #4]
 1156 000c 1B68     		ldr	r3, [r3, #0]
 1157 000e 002B     		cmp	r3, #0
 1158 0010 19D0     		beq	.L52
1129:FreeRTOS/Source/queue.c **** 	{
1130:FreeRTOS/Source/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 1159              		.loc 1 1130 0
 1160 0012 7B68     		ldr	r3, [r7, #4]
 1161 0014 DA68     		ldr	r2, [r3, #12]
 1162 0016 7B68     		ldr	r3, [r7, #4]
 1163 0018 1B6C     		ldr	r3, [r3, #64]
 1164 001a D218     		adds	r2, r2, r3
 1165 001c 7B68     		ldr	r3, [r7, #4]
 1166 001e DA60     		str	r2, [r3, #12]
1131:FreeRTOS/Source/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 1167              		.loc 1 1131 0
 1168 0020 7B68     		ldr	r3, [r7, #4]
 1169 0022 DA68     		ldr	r2, [r3, #12]
 1170 0024 7B68     		ldr	r3, [r7, #4]
 1171 0026 5B68     		ldr	r3, [r3, #4]
 1172 0028 9A42     		cmp	r2, r3
 1173 002a 03D3     		bcc	.L54
1132:FreeRTOS/Source/queue.c **** 		{
1133:FreeRTOS/Source/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 1174              		.loc 1 1133 0
 1175 002c 7B68     		ldr	r3, [r7, #4]
 1176 002e 1A68     		ldr	r2, [r3, #0]
 1177 0030 7B68     		ldr	r3, [r7, #4]
 1178 0032 DA60     		str	r2, [r3, #12]
 1179              	.L54:
1134:FreeRTOS/Source/queue.c **** 		}
1135:FreeRTOS/Source/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 1180              		.loc 1 1135 0
 1181 0034 7B68     		ldr	r3, [r7, #4]
 1182 0036 DA68     		ldr	r2, [r3, #12]
 1183 0038 7B68     		ldr	r3, [r7, #4]
 1184 003a 1B6C     		ldr	r3, [r3, #64]
 1185 003c 3868     		ldr	r0, [r7, #0]
 1186 003e 1146     		mov	r1, r2
 1187 0040 1A46     		mov	r2, r3
 1188 0042 FFF7FEFF 		bl	memcpy
 1189              	.L52:
1136:FreeRTOS/Source/queue.c **** 	}
1137:FreeRTOS/Source/queue.c **** }
 1190              		.loc 1 1137 0
 1191 0046 07F10807 		add	r7, r7, #8
 1192 004a BD46     		mov	sp, r7
 1193 004c 80BD     		pop	{r7, pc}
 1194              		.cfi_endproc
 1195              	.LFE120:
 1197 004e 00BF     		.section	.text.prvUnlockQueue,"ax",%progbits
 1198              		.align	2
 1199              		.thumb
 1200              		.thumb_func
 1202              	prvUnlockQueue:
 1203              	.LFB121:
1138:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1139:FreeRTOS/Source/queue.c **** 
1140:FreeRTOS/Source/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1141:FreeRTOS/Source/queue.c **** {
 1204              		.loc 1 1141 0
 1205              		.cfi_startproc
 1206              		@ args = 0, pretend = 0, frame = 8
 1207              		@ frame_needed = 1, uses_anonymous_args = 0
 1208 0000 80B5     		push	{r7, lr}
 1209              	.LCFI33:
 1210              		.cfi_def_cfa_offset 8
 1211 0002 82B0     		sub	sp, sp, #8
 1212              	.LCFI34:
 1213              		.cfi_def_cfa_offset 16
 1214 0004 00AF     		add	r7, sp, #0
 1215              		.cfi_offset 14, -4
 1216              		.cfi_offset 7, -8
 1217              	.LCFI35:
 1218              		.cfi_def_cfa_register 7
 1219 0006 7860     		str	r0, [r7, #4]
1142:FreeRTOS/Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1143:FreeRTOS/Source/queue.c **** 
1144:FreeRTOS/Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1145:FreeRTOS/Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1146:FreeRTOS/Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1147:FreeRTOS/Source/queue.c **** 	updated. */
1148:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1220              		.loc 1 1148 0
 1221 0008 FFF7FEFF 		bl	vPortEnterCritical
1149:FreeRTOS/Source/queue.c **** 	{
1150:FreeRTOS/Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1151:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1222              		.loc 1 1151 0
 1223 000c 14E0     		b	.L56
 1224              	.L60:
1152:FreeRTOS/Source/queue.c **** 		{
1153:FreeRTOS/Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1154:FreeRTOS/Source/queue.c **** 			blocked waiting for data to become available? */
1155:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1225              		.loc 1 1155 0
 1226 000e 7B68     		ldr	r3, [r7, #4]
 1227 0010 5B6A     		ldr	r3, [r3, #36]
 1228 0012 002B     		cmp	r3, #0
 1229 0014 15D0     		beq	.L66
1156:FreeRTOS/Source/queue.c **** 			{
1157:FreeRTOS/Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1158:FreeRTOS/Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1159:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1230              		.loc 1 1159 0
 1231 0016 7B68     		ldr	r3, [r7, #4]
 1232 0018 03F12403 		add	r3, r3, #36
 1233 001c 1846     		mov	r0, r3
 1234 001e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1235 0022 0346     		mov	r3, r0
 1236 0024 002B     		cmp	r3, #0
 1237 0026 01D0     		beq	.L58
1160:FreeRTOS/Source/queue.c **** 				{
1161:FreeRTOS/Source/queue.c **** 					/* The task waiting has a higher priority so record that a
1162:FreeRTOS/Source/queue.c **** 					context	switch is required. */
1163:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1238              		.loc 1 1163 0
 1239 0028 FFF7FEFF 		bl	vTaskMissedYield
 1240              	.L58:
1164:FreeRTOS/Source/queue.c **** 				}
1165:FreeRTOS/Source/queue.c **** 
1166:FreeRTOS/Source/queue.c **** 				--( pxQueue->xTxLock );
 1241              		.loc 1 1166 0
 1242 002c 7B68     		ldr	r3, [r7, #4]
 1243 002e 9B6C     		ldr	r3, [r3, #72]
 1244 0030 03F1FF32 		add	r2, r3, #-1
 1245 0034 7B68     		ldr	r3, [r7, #4]
 1246 0036 9A64     		str	r2, [r3, #72]
 1247              	.L56:
1151:FreeRTOS/Source/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 1248              		.loc 1 1151 0 discriminator 1
 1249 0038 7B68     		ldr	r3, [r7, #4]
 1250 003a 9B6C     		ldr	r3, [r3, #72]
 1251 003c 002B     		cmp	r3, #0
 1252 003e E6DC     		bgt	.L60
 1253 0040 00E0     		b	.L59
 1254              	.L66:
1167:FreeRTOS/Source/queue.c **** 			}
1168:FreeRTOS/Source/queue.c **** 			else
1169:FreeRTOS/Source/queue.c **** 			{
1170:FreeRTOS/Source/queue.c **** 				break;
 1255              		.loc 1 1170 0
 1256 0042 00BF     		nop
 1257              	.L59:
1171:FreeRTOS/Source/queue.c **** 			}
1172:FreeRTOS/Source/queue.c **** 		}
1173:FreeRTOS/Source/queue.c **** 
1174:FreeRTOS/Source/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 1258              		.loc 1 1174 0
 1259 0044 7B68     		ldr	r3, [r7, #4]
 1260 0046 4FF0FF32 		mov	r2, #-1
 1261 004a 9A64     		str	r2, [r3, #72]
1175:FreeRTOS/Source/queue.c **** 	}
1176:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1262              		.loc 1 1176 0
 1263 004c FFF7FEFF 		bl	vPortExitCritical
1177:FreeRTOS/Source/queue.c **** 
1178:FreeRTOS/Source/queue.c **** 	/* Do the same for the Rx lock. */
1179:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1264              		.loc 1 1179 0
 1265 0050 FFF7FEFF 		bl	vPortEnterCritical
1180:FreeRTOS/Source/queue.c **** 	{
1181:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1266              		.loc 1 1181 0
 1267 0054 14E0     		b	.L61
 1268              	.L65:
1182:FreeRTOS/Source/queue.c **** 		{
1183:FreeRTOS/Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1269              		.loc 1 1183 0
 1270 0056 7B68     		ldr	r3, [r7, #4]
 1271 0058 1B69     		ldr	r3, [r3, #16]
 1272 005a 002B     		cmp	r3, #0
 1273 005c 15D0     		beq	.L67
1184:FreeRTOS/Source/queue.c **** 			{
1185:FreeRTOS/Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1274              		.loc 1 1185 0
 1275 005e 7B68     		ldr	r3, [r7, #4]
 1276 0060 03F11003 		add	r3, r3, #16
 1277 0064 1846     		mov	r0, r3
 1278 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1279 006a 0346     		mov	r3, r0
 1280 006c 002B     		cmp	r3, #0
 1281 006e 01D0     		beq	.L63
1186:FreeRTOS/Source/queue.c **** 				{
1187:FreeRTOS/Source/queue.c **** 					vTaskMissedYield();
 1282              		.loc 1 1187 0
 1283 0070 FFF7FEFF 		bl	vTaskMissedYield
 1284              	.L63:
1188:FreeRTOS/Source/queue.c **** 				}
1189:FreeRTOS/Source/queue.c **** 
1190:FreeRTOS/Source/queue.c **** 				--( pxQueue->xRxLock );
 1285              		.loc 1 1190 0
 1286 0074 7B68     		ldr	r3, [r7, #4]
 1287 0076 5B6C     		ldr	r3, [r3, #68]
 1288 0078 03F1FF32 		add	r2, r3, #-1
 1289 007c 7B68     		ldr	r3, [r7, #4]
 1290 007e 5A64     		str	r2, [r3, #68]
 1291              	.L61:
1181:FreeRTOS/Source/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 1292              		.loc 1 1181 0 discriminator 1
 1293 0080 7B68     		ldr	r3, [r7, #4]
 1294 0082 5B6C     		ldr	r3, [r3, #68]
 1295 0084 002B     		cmp	r3, #0
 1296 0086 E6DC     		bgt	.L65
 1297 0088 00E0     		b	.L64
 1298              	.L67:
1191:FreeRTOS/Source/queue.c **** 			}
1192:FreeRTOS/Source/queue.c **** 			else
1193:FreeRTOS/Source/queue.c **** 			{
1194:FreeRTOS/Source/queue.c **** 				break;
 1299              		.loc 1 1194 0
 1300 008a 00BF     		nop
 1301              	.L64:
1195:FreeRTOS/Source/queue.c **** 			}
1196:FreeRTOS/Source/queue.c **** 		}
1197:FreeRTOS/Source/queue.c **** 
1198:FreeRTOS/Source/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 1302              		.loc 1 1198 0
 1303 008c 7B68     		ldr	r3, [r7, #4]
 1304 008e 4FF0FF32 		mov	r2, #-1
 1305 0092 5A64     		str	r2, [r3, #68]
1199:FreeRTOS/Source/queue.c **** 	}
1200:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1306              		.loc 1 1200 0
 1307 0094 FFF7FEFF 		bl	vPortExitCritical
1201:FreeRTOS/Source/queue.c **** }
 1308              		.loc 1 1201 0
 1309 0098 07F10807 		add	r7, r7, #8
 1310 009c BD46     		mov	sp, r7
 1311 009e 80BD     		pop	{r7, pc}
 1312              		.cfi_endproc
 1313              	.LFE121:
 1315              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 1316              		.align	2
 1317              		.thumb
 1318              		.thumb_func
 1320              	prvIsQueueEmpty:
 1321              	.LFB122:
1202:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1203:FreeRTOS/Source/queue.c **** 
1204:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1205:FreeRTOS/Source/queue.c **** {
 1322              		.loc 1 1205 0
 1323              		.cfi_startproc
 1324              		@ args = 0, pretend = 0, frame = 16
 1325              		@ frame_needed = 1, uses_anonymous_args = 0
 1326 0000 80B5     		push	{r7, lr}
 1327              	.LCFI36:
 1328              		.cfi_def_cfa_offset 8
 1329 0002 84B0     		sub	sp, sp, #16
 1330              	.LCFI37:
 1331              		.cfi_def_cfa_offset 24
 1332 0004 00AF     		add	r7, sp, #0
 1333              		.cfi_offset 14, -4
 1334              		.cfi_offset 7, -8
 1335              	.LCFI38:
 1336              		.cfi_def_cfa_register 7
 1337 0006 7860     		str	r0, [r7, #4]
1206:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1207:FreeRTOS/Source/queue.c **** 
1208:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1338              		.loc 1 1208 0
 1339 0008 FFF7FEFF 		bl	vPortEnterCritical
1209:FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1340              		.loc 1 1209 0
 1341 000c 7B68     		ldr	r3, [r7, #4]
 1342 000e 9B6B     		ldr	r3, [r3, #56]
 1343 0010 002B     		cmp	r3, #0
 1344 0012 14BF     		ite	ne
 1345 0014 0023     		movne	r3, #0
 1346 0016 0123     		moveq	r3, #1
 1347 0018 FB60     		str	r3, [r7, #12]
1210:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1348              		.loc 1 1210 0
 1349 001a FFF7FEFF 		bl	vPortExitCritical
1211:FreeRTOS/Source/queue.c **** 
1212:FreeRTOS/Source/queue.c **** 	return xReturn;
 1350              		.loc 1 1212 0
 1351 001e FB68     		ldr	r3, [r7, #12]
1213:FreeRTOS/Source/queue.c **** }
 1352              		.loc 1 1213 0
 1353 0020 1846     		mov	r0, r3
 1354 0022 07F11007 		add	r7, r7, #16
 1355 0026 BD46     		mov	sp, r7
 1356 0028 80BD     		pop	{r7, pc}
 1357              		.cfi_endproc
 1358              	.LFE122:
 1360 002a 00BF     		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 1361              		.align	2
 1362              		.global	xQueueIsQueueEmptyFromISR
 1363              		.thumb
 1364              		.thumb_func
 1366              	xQueueIsQueueEmptyFromISR:
 1367              	.LFB123:
1214:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1215:FreeRTOS/Source/queue.c **** 
1216:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1217:FreeRTOS/Source/queue.c **** {
 1368              		.loc 1 1217 0
 1369              		.cfi_startproc
 1370              		@ args = 0, pretend = 0, frame = 16
 1371              		@ frame_needed = 1, uses_anonymous_args = 0
 1372              		@ link register save eliminated.
 1373 0000 80B4     		push	{r7}
 1374              	.LCFI39:
 1375              		.cfi_def_cfa_offset 4
 1376 0002 85B0     		sub	sp, sp, #20
 1377              	.LCFI40:
 1378              		.cfi_def_cfa_offset 24
 1379 0004 00AF     		add	r7, sp, #0
 1380              		.cfi_offset 7, -4
 1381              	.LCFI41:
 1382              		.cfi_def_cfa_register 7
 1383 0006 7860     		str	r0, [r7, #4]
1218:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1219:FreeRTOS/Source/queue.c **** 
1220:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1221:FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 1384              		.loc 1 1221 0
 1385 0008 7B68     		ldr	r3, [r7, #4]
 1386 000a 9B6B     		ldr	r3, [r3, #56]
 1387 000c 002B     		cmp	r3, #0
 1388 000e 14BF     		ite	ne
 1389 0010 0023     		movne	r3, #0
 1390 0012 0123     		moveq	r3, #1
 1391 0014 FB60     		str	r3, [r7, #12]
1222:FreeRTOS/Source/queue.c **** 
1223:FreeRTOS/Source/queue.c **** 	return xReturn;
 1392              		.loc 1 1223 0
 1393 0016 FB68     		ldr	r3, [r7, #12]
1224:FreeRTOS/Source/queue.c **** }
 1394              		.loc 1 1224 0
 1395 0018 1846     		mov	r0, r3
 1396 001a 07F11407 		add	r7, r7, #20
 1397 001e BD46     		mov	sp, r7
 1398 0020 80BC     		pop	{r7}
 1399 0022 7047     		bx	lr
 1400              		.cfi_endproc
 1401              	.LFE123:
 1403              		.section	.text.prvIsQueueFull,"ax",%progbits
 1404              		.align	2
 1405              		.thumb
 1406              		.thumb_func
 1408              	prvIsQueueFull:
 1409              	.LFB124:
1225:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1226:FreeRTOS/Source/queue.c **** 
1227:FreeRTOS/Source/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1228:FreeRTOS/Source/queue.c **** {
 1410              		.loc 1 1228 0
 1411              		.cfi_startproc
 1412              		@ args = 0, pretend = 0, frame = 16
 1413              		@ frame_needed = 1, uses_anonymous_args = 0
 1414 0000 80B5     		push	{r7, lr}
 1415              	.LCFI42:
 1416              		.cfi_def_cfa_offset 8
 1417 0002 84B0     		sub	sp, sp, #16
 1418              	.LCFI43:
 1419              		.cfi_def_cfa_offset 24
 1420 0004 00AF     		add	r7, sp, #0
 1421              		.cfi_offset 14, -4
 1422              		.cfi_offset 7, -8
 1423              	.LCFI44:
 1424              		.cfi_def_cfa_register 7
 1425 0006 7860     		str	r0, [r7, #4]
1229:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1230:FreeRTOS/Source/queue.c **** 
1231:FreeRTOS/Source/queue.c **** 	taskENTER_CRITICAL();
 1426              		.loc 1 1231 0
 1427 0008 FFF7FEFF 		bl	vPortEnterCritical
1232:FreeRTOS/Source/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1428              		.loc 1 1232 0
 1429 000c 7B68     		ldr	r3, [r7, #4]
 1430 000e 9A6B     		ldr	r2, [r3, #56]
 1431 0010 7B68     		ldr	r3, [r7, #4]
 1432 0012 DB6B     		ldr	r3, [r3, #60]
 1433 0014 9A42     		cmp	r2, r3
 1434 0016 14BF     		ite	ne
 1435 0018 0023     		movne	r3, #0
 1436 001a 0123     		moveq	r3, #1
 1437 001c FB60     		str	r3, [r7, #12]
1233:FreeRTOS/Source/queue.c **** 	taskEXIT_CRITICAL();
 1438              		.loc 1 1233 0
 1439 001e FFF7FEFF 		bl	vPortExitCritical
1234:FreeRTOS/Source/queue.c **** 
1235:FreeRTOS/Source/queue.c **** 	return xReturn;
 1440              		.loc 1 1235 0
 1441 0022 FB68     		ldr	r3, [r7, #12]
1236:FreeRTOS/Source/queue.c **** }
 1442              		.loc 1 1236 0
 1443 0024 1846     		mov	r0, r3
 1444 0026 07F11007 		add	r7, r7, #16
 1445 002a BD46     		mov	sp, r7
 1446 002c 80BD     		pop	{r7, pc}
 1447              		.cfi_endproc
 1448              	.LFE124:
 1450 002e 00BF     		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 1451              		.align	2
 1452              		.global	xQueueIsQueueFullFromISR
 1453              		.thumb
 1454              		.thumb_func
 1456              	xQueueIsQueueFullFromISR:
 1457              	.LFB125:
1237:FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1238:FreeRTOS/Source/queue.c **** 
1239:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1240:FreeRTOS/Source/queue.c **** {
 1458              		.loc 1 1240 0
 1459              		.cfi_startproc
 1460              		@ args = 0, pretend = 0, frame = 16
 1461              		@ frame_needed = 1, uses_anonymous_args = 0
 1462              		@ link register save eliminated.
 1463 0000 80B4     		push	{r7}
 1464              	.LCFI45:
 1465              		.cfi_def_cfa_offset 4
 1466 0002 85B0     		sub	sp, sp, #20
 1467              	.LCFI46:
 1468              		.cfi_def_cfa_offset 24
 1469 0004 00AF     		add	r7, sp, #0
 1470              		.cfi_offset 7, -4
 1471              	.LCFI47:
 1472              		.cfi_def_cfa_register 7
 1473 0006 7860     		str	r0, [r7, #4]
1241:FreeRTOS/Source/queue.c **** signed portBASE_TYPE xReturn;
1242:FreeRTOS/Source/queue.c **** 
1243:FreeRTOS/Source/queue.c **** 	configASSERT( pxQueue );
1244:FreeRTOS/Source/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 1474              		.loc 1 1244 0
 1475 0008 7B68     		ldr	r3, [r7, #4]
 1476 000a 9A6B     		ldr	r2, [r3, #56]
 1477 000c 7B68     		ldr	r3, [r7, #4]
 1478 000e DB6B     		ldr	r3, [r3, #60]
 1479 0010 9A42     		cmp	r2, r3
 1480 0012 14BF     		ite	ne
 1481 0014 0023     		movne	r3, #0
 1482 0016 0123     		moveq	r3, #1
 1483 0018 FB60     		str	r3, [r7, #12]
1245:FreeRTOS/Source/queue.c **** 
1246:FreeRTOS/Source/queue.c **** 	return xReturn;
 1484              		.loc 1 1246 0
 1485 001a FB68     		ldr	r3, [r7, #12]
1247:FreeRTOS/Source/queue.c **** }
 1486              		.loc 1 1247 0
 1487 001c 1846     		mov	r0, r3
 1488 001e 07F11407 		add	r7, r7, #20
 1489 0022 BD46     		mov	sp, r7
 1490 0024 80BC     		pop	{r7}
 1491 0026 7047     		bx	lr
 1492              		.cfi_endproc
 1493              	.LFE125:
 1495              		.text
 1496              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/ccDBj05a.s:25     .text.xQueueCreate:00000000 $t
     /tmp/ccDBj05a.s:30     .text.xQueueCreate:00000000 xQueueCreate
     /tmp/ccDBj05a.s:158    .text.xQueueCreateMutex:00000000 $t
     /tmp/ccDBj05a.s:163    .text.xQueueCreateMutex:00000000 xQueueCreateMutex
     /tmp/ccDBj05a.s:258    .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/ccDBj05a.s:253    .text.xQueueGenericSend:00000000 $t
     /tmp/ccDBj05a.s:1006   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/ccDBj05a.s:1408   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/ccDBj05a.s:1202   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/ccDBj05a.s:432    .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/ccDBj05a.s:437    .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/ccDBj05a.s:537    .text.xQueueGenericReceive:00000000 $t
     /tmp/ccDBj05a.s:542    .text.xQueueGenericReceive:00000000 xQueueGenericReceive
     /tmp/ccDBj05a.s:1135   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/ccDBj05a.s:1320   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/ccDBj05a.s:775    .text.xQueueReceiveFromISR:00000000 $t
     /tmp/ccDBj05a.s:780    .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/ccDBj05a.s:882    .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/ccDBj05a.s:887    .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/ccDBj05a.s:924    .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/ccDBj05a.s:929    .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/ccDBj05a.s:963    .text.vQueueDelete:00000000 $t
     /tmp/ccDBj05a.s:968    .text.vQueueDelete:00000000 vQueueDelete
     /tmp/ccDBj05a.s:1002   .text.prvCopyDataToQueue:00000000 $t
     /tmp/ccDBj05a.s:1131   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/ccDBj05a.s:1198   .text.prvUnlockQueue:00000000 $t
     /tmp/ccDBj05a.s:1316   .text.prvIsQueueEmpty:00000000 $t
     /tmp/ccDBj05a.s:1361   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/ccDBj05a.s:1366   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/ccDBj05a.s:1404   .text.prvIsQueueFull:00000000 $t
     /tmp/ccDBj05a.s:1451   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/ccDBj05a.s:1456   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
malloc
vListInitialise
free
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
