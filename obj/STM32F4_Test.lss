
obj/STM32F4_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000025c8  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000004  08002750  08002750  0000a750  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  08002754  08002754  0000a754  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000544  20000000  08002758  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000264  20000548  08002c9c  00010548  2**3
                  ALLOC
  6 ._user_heap_stack 00000400  200007ac  08002c9c  000107ac  2**0
                  ALLOC
  7 .ARM.attributes 00000033  00000000  00000000  00010544  2**0
                  CONTENTS, READONLY
  8 .debug_abbrev 00003a35  00000000  00000000  00010577  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00015580  00000000  00000000  00013fac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00008888  00000000  00000000  0002952c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000971a  00000000  00000000  00031db4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00003df1  00000000  00000000  0003b4ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00001ecc  00000000  00000000  0003f2bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000019f8  00000000  00000000  0004118b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00001768  00000000  00000000  00042b83  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007bcd  00000000  00000000  000442eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000002a  00000000  00000000  0004beb8  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00005a30  00000000  00000000  0004bee4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	f240 5348 	movw	r3, #1352	; 0x548
 800018c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000190:	781a      	ldrb	r2, [r3, #0]
 8000192:	b90a      	cbnz	r2, 8000198 <__do_global_dtors_aux+0x10>
 8000194:	2001      	movs	r0, #1
 8000196:	7018      	strb	r0, [r3, #0]
 8000198:	4770      	bx	lr
 800019a:	bf00      	nop

0800019c <frame_dummy>:
 800019c:	f240 5044 	movw	r0, #1348	; 0x544
 80001a0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80001a4:	b508      	push	{r3, lr}
 80001a6:	6803      	ldr	r3, [r0, #0]
 80001a8:	b12b      	cbz	r3, 80001b6 <frame_dummy+0x1a>
 80001aa:	f240 0300 	movw	r3, #0
 80001ae:	f2c0 0300 	movt	r3, #0
 80001b2:	b103      	cbz	r3, 80001b6 <frame_dummy+0x1a>
 80001b4:	4798      	blx	r3
 80001b6:	bd08      	pop	{r3, pc}

080001b8 <__libc_init_array>:
 80001b8:	b570      	push	{r4, r5, r6, lr}
 80001ba:	f242 7650 	movw	r6, #10064	; 0x2750
 80001be:	f242 7550 	movw	r5, #10064	; 0x2750
 80001c2:	f6c0 0600 	movt	r6, #2048	; 0x800
 80001c6:	f6c0 0500 	movt	r5, #2048	; 0x800
 80001ca:	1b76      	subs	r6, r6, r5
 80001cc:	10b6      	asrs	r6, r6, #2
 80001ce:	d006      	beq.n	80001de <__libc_init_array+0x26>
 80001d0:	2400      	movs	r4, #0
 80001d2:	f855 3b04 	ldr.w	r3, [r5], #4
 80001d6:	3401      	adds	r4, #1
 80001d8:	4798      	blx	r3
 80001da:	42a6      	cmp	r6, r4
 80001dc:	d1f9      	bne.n	80001d2 <__libc_init_array+0x1a>
 80001de:	f242 7654 	movw	r6, #10068	; 0x2754
 80001e2:	f242 7550 	movw	r5, #10064	; 0x2750
 80001e6:	f6c0 0600 	movt	r6, #2048	; 0x800
 80001ea:	f6c0 0500 	movt	r5, #2048	; 0x800
 80001ee:	1b76      	subs	r6, r6, r5
 80001f0:	f002 faa2 	bl	8002738 <_init>
 80001f4:	10b6      	asrs	r6, r6, #2
 80001f6:	d006      	beq.n	8000206 <__libc_init_array+0x4e>
 80001f8:	2400      	movs	r4, #0
 80001fa:	f855 3b04 	ldr.w	r3, [r5], #4
 80001fe:	3401      	adds	r4, #1
 8000200:	4798      	blx	r3
 8000202:	42a6      	cmp	r6, r4
 8000204:	d1f9      	bne.n	80001fa <__libc_init_array+0x42>
 8000206:	bd70      	pop	{r4, r5, r6, pc}

08000208 <malloc>:
 8000208:	f240 4310 	movw	r3, #1040	; 0x410
 800020c:	4601      	mov	r1, r0
 800020e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000212:	6818      	ldr	r0, [r3, #0]
 8000214:	f000 b808 	b.w	8000228 <_malloc_r>

08000218 <free>:
 8000218:	f240 4310 	movw	r3, #1040	; 0x410
 800021c:	4601      	mov	r1, r0
 800021e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000222:	6818      	ldr	r0, [r3, #0]
 8000224:	f000 bba8 	b.w	8000978 <_free_r>

08000228 <_malloc_r>:
 8000228:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800022c:	f101 040b 	add.w	r4, r1, #11
 8000230:	2c16      	cmp	r4, #22
 8000232:	b083      	sub	sp, #12
 8000234:	4606      	mov	r6, r0
 8000236:	d931      	bls.n	800029c <_malloc_r+0x74>
 8000238:	f024 0407 	bic.w	r4, r4, #7
 800023c:	0fe3      	lsrs	r3, r4, #31
 800023e:	428c      	cmp	r4, r1
 8000240:	bf2c      	ite	cs
 8000242:	4619      	movcs	r1, r3
 8000244:	f043 0101 	orrcc.w	r1, r3, #1
 8000248:	2900      	cmp	r1, #0
 800024a:	d130      	bne.n	80002ae <_malloc_r+0x86>
 800024c:	4630      	mov	r0, r6
 800024e:	f000 ffc5 	bl	80011dc <__malloc_lock>
 8000252:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 8000256:	d22f      	bcs.n	80002b8 <_malloc_r+0x90>
 8000258:	ea4f 0cd4 	mov.w	ip, r4, lsr #3
 800025c:	f240 0500 	movw	r5, #0
 8000260:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8000264:	eb05 02cc 	add.w	r2, r5, ip, lsl #3
 8000268:	462f      	mov	r7, r5
 800026a:	68d3      	ldr	r3, [r2, #12]
 800026c:	4293      	cmp	r3, r2
 800026e:	f000 822d 	beq.w	80006cc <_malloc_r+0x4a4>
 8000272:	685c      	ldr	r4, [r3, #4]
 8000274:	f103 0808 	add.w	r8, r3, #8
 8000278:	68da      	ldr	r2, [r3, #12]
 800027a:	4630      	mov	r0, r6
 800027c:	f024 0403 	bic.w	r4, r4, #3
 8000280:	6899      	ldr	r1, [r3, #8]
 8000282:	191b      	adds	r3, r3, r4
 8000284:	685c      	ldr	r4, [r3, #4]
 8000286:	60ca      	str	r2, [r1, #12]
 8000288:	f044 0401 	orr.w	r4, r4, #1
 800028c:	6091      	str	r1, [r2, #8]
 800028e:	605c      	str	r4, [r3, #4]
 8000290:	f000 ffae 	bl	80011f0 <__malloc_unlock>
 8000294:	4640      	mov	r0, r8
 8000296:	b003      	add	sp, #12
 8000298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800029c:	2300      	movs	r3, #0
 800029e:	2410      	movs	r4, #16
 80002a0:	428c      	cmp	r4, r1
 80002a2:	bf2c      	ite	cs
 80002a4:	4619      	movcs	r1, r3
 80002a6:	f043 0101 	orrcc.w	r1, r3, #1
 80002aa:	2900      	cmp	r1, #0
 80002ac:	d0ce      	beq.n	800024c <_malloc_r+0x24>
 80002ae:	230c      	movs	r3, #12
 80002b0:	f04f 0800 	mov.w	r8, #0
 80002b4:	6033      	str	r3, [r6, #0]
 80002b6:	e7ed      	b.n	8000294 <_malloc_r+0x6c>
 80002b8:	ea5f 2c54 	movs.w	ip, r4, lsr #9
 80002bc:	bf04      	itt	eq
 80002be:	ea4f 0cd4 	moveq.w	ip, r4, lsr #3
 80002c2:	ea4f 00cc 	moveq.w	r0, ip, lsl #3
 80002c6:	f040 8086 	bne.w	80003d6 <_malloc_r+0x1ae>
 80002ca:	f240 0500 	movw	r5, #0
 80002ce:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80002d2:	1828      	adds	r0, r5, r0
 80002d4:	462f      	mov	r7, r5
 80002d6:	68c3      	ldr	r3, [r0, #12]
 80002d8:	4298      	cmp	r0, r3
 80002da:	d106      	bne.n	80002ea <_malloc_r+0xc2>
 80002dc:	e00d      	b.n	80002fa <_malloc_r+0xd2>
 80002de:	2900      	cmp	r1, #0
 80002e0:	f280 8179 	bge.w	80005d6 <_malloc_r+0x3ae>
 80002e4:	68db      	ldr	r3, [r3, #12]
 80002e6:	4298      	cmp	r0, r3
 80002e8:	d007      	beq.n	80002fa <_malloc_r+0xd2>
 80002ea:	685a      	ldr	r2, [r3, #4]
 80002ec:	f022 0203 	bic.w	r2, r2, #3
 80002f0:	1b11      	subs	r1, r2, r4
 80002f2:	290f      	cmp	r1, #15
 80002f4:	ddf3      	ble.n	80002de <_malloc_r+0xb6>
 80002f6:	f10c 3cff 	add.w	ip, ip, #4294967295
 80002fa:	f10c 0c01 	add.w	ip, ip, #1
 80002fe:	4abd      	ldr	r2, [pc, #756]	; (80005f4 <_malloc_r+0x3cc>)
 8000300:	6893      	ldr	r3, [r2, #8]
 8000302:	429a      	cmp	r2, r3
 8000304:	bf08      	it	eq
 8000306:	6878      	ldreq	r0, [r7, #4]
 8000308:	d024      	beq.n	8000354 <_malloc_r+0x12c>
 800030a:	6858      	ldr	r0, [r3, #4]
 800030c:	f020 0003 	bic.w	r0, r0, #3
 8000310:	1b01      	subs	r1, r0, r4
 8000312:	290f      	cmp	r1, #15
 8000314:	f300 81c0 	bgt.w	8000698 <_malloc_r+0x470>
 8000318:	2900      	cmp	r1, #0
 800031a:	60d2      	str	r2, [r2, #12]
 800031c:	6092      	str	r2, [r2, #8]
 800031e:	f280 8094 	bge.w	800044a <_malloc_r+0x222>
 8000322:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8000326:	f080 8177 	bcs.w	8000618 <_malloc_r+0x3f0>
 800032a:	08c0      	lsrs	r0, r0, #3
 800032c:	f04f 0e01 	mov.w	lr, #1
 8000330:	f8d7 8004 	ldr.w	r8, [r7, #4]
 8000334:	eb07 01c0 	add.w	r1, r7, r0, lsl #3
 8000338:	1080      	asrs	r0, r0, #2
 800033a:	fa0e f000 	lsl.w	r0, lr, r0
 800033e:	60d9      	str	r1, [r3, #12]
 8000340:	f8d1 e008 	ldr.w	lr, [r1, #8]
 8000344:	ea40 0008 	orr.w	r0, r0, r8
 8000348:	6078      	str	r0, [r7, #4]
 800034a:	f8c3 e008 	str.w	lr, [r3, #8]
 800034e:	f8ce 300c 	str.w	r3, [lr, #12]
 8000352:	608b      	str	r3, [r1, #8]
 8000354:	f04f 0e01 	mov.w	lr, #1
 8000358:	ea4f 03ac 	mov.w	r3, ip, asr #2
 800035c:	fa0e fe03 	lsl.w	lr, lr, r3
 8000360:	4586      	cmp	lr, r0
 8000362:	d87d      	bhi.n	8000460 <_malloc_r+0x238>
 8000364:	ea10 0f0e 	tst.w	r0, lr
 8000368:	d108      	bne.n	800037c <_malloc_r+0x154>
 800036a:	f02c 0c03 	bic.w	ip, ip, #3
 800036e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8000372:	f10c 0c04 	add.w	ip, ip, #4
 8000376:	ea10 0f0e 	tst.w	r0, lr
 800037a:	d0f8      	beq.n	800036e <_malloc_r+0x146>
 800037c:	eb07 0acc 	add.w	sl, r7, ip, lsl #3
 8000380:	46e1      	mov	r9, ip
 8000382:	46d0      	mov	r8, sl
 8000384:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8000388:	4580      	cmp	r8, r0
 800038a:	d107      	bne.n	800039c <_malloc_r+0x174>
 800038c:	e196      	b.n	80006bc <_malloc_r+0x494>
 800038e:	2b00      	cmp	r3, #0
 8000390:	f280 81a6 	bge.w	80006e0 <_malloc_r+0x4b8>
 8000394:	68c0      	ldr	r0, [r0, #12]
 8000396:	4580      	cmp	r8, r0
 8000398:	f000 8190 	beq.w	80006bc <_malloc_r+0x494>
 800039c:	6841      	ldr	r1, [r0, #4]
 800039e:	f021 0103 	bic.w	r1, r1, #3
 80003a2:	1b0b      	subs	r3, r1, r4
 80003a4:	2b0f      	cmp	r3, #15
 80003a6:	ddf2      	ble.n	800038e <_malloc_r+0x166>
 80003a8:	4680      	mov	r8, r0
 80003aa:	68c5      	ldr	r5, [r0, #12]
 80003ac:	1901      	adds	r1, r0, r4
 80003ae:	f044 0e01 	orr.w	lr, r4, #1
 80003b2:	f858 7f08 	ldr.w	r7, [r8, #8]!
 80003b6:	f043 0401 	orr.w	r4, r3, #1
 80003ba:	f8c0 e004 	str.w	lr, [r0, #4]
 80003be:	4630      	mov	r0, r6
 80003c0:	604c      	str	r4, [r1, #4]
 80003c2:	60fd      	str	r5, [r7, #12]
 80003c4:	60af      	str	r7, [r5, #8]
 80003c6:	60d1      	str	r1, [r2, #12]
 80003c8:	6091      	str	r1, [r2, #8]
 80003ca:	60ca      	str	r2, [r1, #12]
 80003cc:	608a      	str	r2, [r1, #8]
 80003ce:	50cb      	str	r3, [r1, r3]
 80003d0:	f000 ff0e 	bl	80011f0 <__malloc_unlock>
 80003d4:	e75e      	b.n	8000294 <_malloc_r+0x6c>
 80003d6:	f1bc 0f04 	cmp.w	ip, #4
 80003da:	bf9e      	ittt	ls
 80003dc:	ea4f 1c94 	movls.w	ip, r4, lsr #6
 80003e0:	f10c 0c38 	addls.w	ip, ip, #56	; 0x38
 80003e4:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80003e8:	f67f af6f 	bls.w	80002ca <_malloc_r+0xa2>
 80003ec:	f1bc 0f14 	cmp.w	ip, #20
 80003f0:	bf9c      	itt	ls
 80003f2:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 80003f6:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 80003fa:	f67f af66 	bls.w	80002ca <_malloc_r+0xa2>
 80003fe:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8000402:	bf9e      	ittt	ls
 8000404:	ea4f 3c14 	movls.w	ip, r4, lsr #12
 8000408:	f10c 0c6e 	addls.w	ip, ip, #110	; 0x6e
 800040c:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000410:	f67f af5b 	bls.w	80002ca <_malloc_r+0xa2>
 8000414:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8000418:	bf9e      	ittt	ls
 800041a:	ea4f 3cd4 	movls.w	ip, r4, lsr #15
 800041e:	f10c 0c77 	addls.w	ip, ip, #119	; 0x77
 8000422:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000426:	f67f af50 	bls.w	80002ca <_malloc_r+0xa2>
 800042a:	f240 5354 	movw	r3, #1364	; 0x554
 800042e:	459c      	cmp	ip, r3
 8000430:	bf95      	itete	ls
 8000432:	ea4f 4c94 	movls.w	ip, r4, lsr #18
 8000436:	f44f 707c 	movhi.w	r0, #1008	; 0x3f0
 800043a:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 800043e:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 8000442:	bf98      	it	ls
 8000444:	ea4f 00cc 	movls.w	r0, ip, lsl #3
 8000448:	e73f      	b.n	80002ca <_malloc_r+0xa2>
 800044a:	181a      	adds	r2, r3, r0
 800044c:	f103 0808 	add.w	r8, r3, #8
 8000450:	4630      	mov	r0, r6
 8000452:	6853      	ldr	r3, [r2, #4]
 8000454:	f043 0301 	orr.w	r3, r3, #1
 8000458:	6053      	str	r3, [r2, #4]
 800045a:	f000 fec9 	bl	80011f0 <__malloc_unlock>
 800045e:	e719      	b.n	8000294 <_malloc_r+0x6c>
 8000460:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8000464:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8000468:	f023 0903 	bic.w	r9, r3, #3
 800046c:	454c      	cmp	r4, r9
 800046e:	ebc4 0209 	rsb	r2, r4, r9
 8000472:	bf94      	ite	ls
 8000474:	2300      	movls	r3, #0
 8000476:	2301      	movhi	r3, #1
 8000478:	2a0f      	cmp	r2, #15
 800047a:	bfd8      	it	le
 800047c:	f043 0301 	orrle.w	r3, r3, #1
 8000480:	2b00      	cmp	r3, #0
 8000482:	f000 80b9 	beq.w	80005f8 <_malloc_r+0x3d0>
 8000486:	f240 5a4c 	movw	sl, #1356	; 0x54c
 800048a:	f8d5 3408 	ldr.w	r3, [r5, #1032]	; 0x408
 800048e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8000492:	4630      	mov	r0, r6
 8000494:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000498:	f8da 2000 	ldr.w	r2, [sl]
 800049c:	f102 0b10 	add.w	fp, r2, #16
 80004a0:	44a3      	add	fp, r4
 80004a2:	bf1f      	itttt	ne
 80004a4:	f50b 6b7e 	addne.w	fp, fp, #4064	; 0xfe0
 80004a8:	f10b 0b1f 	addne.w	fp, fp, #31
 80004ac:	f42b 6b7e 	bicne.w	fp, fp, #4064	; 0xfe0
 80004b0:	f02b 0b1f 	bicne.w	fp, fp, #31
 80004b4:	4659      	mov	r1, fp
 80004b6:	f000 fe5b 	bl	8001170 <_sbrk_r>
 80004ba:	f1b0 3fff 	cmp.w	r0, #4294967295
 80004be:	4603      	mov	r3, r0
 80004c0:	f000 8118 	beq.w	80006f4 <_malloc_r+0x4cc>
 80004c4:	eb08 0109 	add.w	r1, r8, r9
 80004c8:	4281      	cmp	r1, r0
 80004ca:	f200 8110 	bhi.w	80006ee <_malloc_r+0x4c6>
 80004ce:	f8da 2004 	ldr.w	r2, [sl, #4]
 80004d2:	4281      	cmp	r1, r0
 80004d4:	445a      	add	r2, fp
 80004d6:	f8ca 2004 	str.w	r2, [sl, #4]
 80004da:	f000 813e 	beq.w	800075a <_malloc_r+0x532>
 80004de:	f8d5 e408 	ldr.w	lr, [r5, #1032]	; 0x408
 80004e2:	f240 0500 	movw	r5, #0
 80004e6:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80004ea:	f1be 3fff 	cmp.w	lr, #4294967295
 80004ee:	bf17      	itett	ne
 80004f0:	1882      	addne	r2, r0, r2
 80004f2:	f8c5 0408 	streq.w	r0, [r5, #1032]	; 0x408
 80004f6:	ebc1 0102 	rsbne	r1, r1, r2
 80004fa:	f8ca 1004 	strne.w	r1, [sl, #4]
 80004fe:	f010 0507 	ands.w	r5, r0, #7
 8000502:	bf17      	itett	ne
 8000504:	f1c5 0508 	rsbne	r5, r5, #8
 8000508:	f44f 5580 	moveq.w	r5, #4096	; 0x1000
 800050c:	1943      	addne	r3, r0, r5
 800050e:	f505 5580 	addne.w	r5, r5, #4096	; 0x1000
 8000512:	eb03 020b 	add.w	r2, r3, fp
 8000516:	4630      	mov	r0, r6
 8000518:	9301      	str	r3, [sp, #4]
 800051a:	0512      	lsls	r2, r2, #20
 800051c:	0d12      	lsrs	r2, r2, #20
 800051e:	1aad      	subs	r5, r5, r2
 8000520:	4629      	mov	r1, r5
 8000522:	f000 fe25 	bl	8001170 <_sbrk_r>
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f1b0 3fff 	cmp.w	r0, #4294967295
 800052c:	f000 812c 	beq.w	8000788 <_malloc_r+0x560>
 8000530:	1ac1      	subs	r1, r0, r3
 8000532:	1949      	adds	r1, r1, r5
 8000534:	f041 0101 	orr.w	r1, r1, #1
 8000538:	f8da 2004 	ldr.w	r2, [sl, #4]
 800053c:	45b8      	cmp	r8, r7
 800053e:	f240 5b4c 	movw	fp, #1356	; 0x54c
 8000542:	60bb      	str	r3, [r7, #8]
 8000544:	442a      	add	r2, r5
 8000546:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 800054a:	6059      	str	r1, [r3, #4]
 800054c:	f8ca 2004 	str.w	r2, [sl, #4]
 8000550:	d017      	beq.n	8000582 <_malloc_r+0x35a>
 8000552:	f1b9 0f0f 	cmp.w	r9, #15
 8000556:	f240 80e1 	bls.w	800071c <_malloc_r+0x4f4>
 800055a:	f1a9 030c 	sub.w	r3, r9, #12
 800055e:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8000562:	f023 0307 	bic.w	r3, r3, #7
 8000566:	2005      	movs	r0, #5
 8000568:	eb08 0103 	add.w	r1, r8, r3
 800056c:	2b0f      	cmp	r3, #15
 800056e:	f005 0501 	and.w	r5, r5, #1
 8000572:	ea43 0505 	orr.w	r5, r3, r5
 8000576:	f8c8 5004 	str.w	r5, [r8, #4]
 800057a:	6048      	str	r0, [r1, #4]
 800057c:	6088      	str	r0, [r1, #8]
 800057e:	f200 80fb 	bhi.w	8000778 <_malloc_r+0x550>
 8000582:	f8da 102c 	ldr.w	r1, [sl, #44]	; 0x2c
 8000586:	f240 534c 	movw	r3, #1356	; 0x54c
 800058a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800058e:	428a      	cmp	r2, r1
 8000590:	f8da 1030 	ldr.w	r1, [sl, #48]	; 0x30
 8000594:	bf88      	it	hi
 8000596:	62da      	strhi	r2, [r3, #44]	; 0x2c
 8000598:	f240 534c 	movw	r3, #1356	; 0x54c
 800059c:	428a      	cmp	r2, r1
 800059e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005a2:	f240 80a7 	bls.w	80006f4 <_malloc_r+0x4cc>
 80005a6:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80005aa:	631a      	str	r2, [r3, #48]	; 0x30
 80005ac:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80005b0:	f023 0303 	bic.w	r3, r3, #3
 80005b4:	429c      	cmp	r4, r3
 80005b6:	ebc4 0203 	rsb	r2, r4, r3
 80005ba:	bf94      	ite	ls
 80005bc:	2300      	movls	r3, #0
 80005be:	2301      	movhi	r3, #1
 80005c0:	2a0f      	cmp	r2, #15
 80005c2:	bfd8      	it	le
 80005c4:	f043 0301 	orrle.w	r3, r3, #1
 80005c8:	b1b3      	cbz	r3, 80005f8 <_malloc_r+0x3d0>
 80005ca:	4630      	mov	r0, r6
 80005cc:	f04f 0800 	mov.w	r8, #0
 80005d0:	f000 fe0e 	bl	80011f0 <__malloc_unlock>
 80005d4:	e65e      	b.n	8000294 <_malloc_r+0x6c>
 80005d6:	189a      	adds	r2, r3, r2
 80005d8:	68d9      	ldr	r1, [r3, #12]
 80005da:	689c      	ldr	r4, [r3, #8]
 80005dc:	f103 0808 	add.w	r8, r3, #8
 80005e0:	6855      	ldr	r5, [r2, #4]
 80005e2:	4630      	mov	r0, r6
 80005e4:	f045 0301 	orr.w	r3, r5, #1
 80005e8:	60e1      	str	r1, [r4, #12]
 80005ea:	608c      	str	r4, [r1, #8]
 80005ec:	6053      	str	r3, [r2, #4]
 80005ee:	f000 fdff 	bl	80011f0 <__malloc_unlock>
 80005f2:	e64f      	b.n	8000294 <_malloc_r+0x6c>
 80005f4:	20000008 	.word	0x20000008
 80005f8:	eb08 0304 	add.w	r3, r8, r4
 80005fc:	f042 0201 	orr.w	r2, r2, #1
 8000600:	f044 0401 	orr.w	r4, r4, #1
 8000604:	4630      	mov	r0, r6
 8000606:	f8c8 4004 	str.w	r4, [r8, #4]
 800060a:	f108 0808 	add.w	r8, r8, #8
 800060e:	605a      	str	r2, [r3, #4]
 8000610:	60bb      	str	r3, [r7, #8]
 8000612:	f000 fded 	bl	80011f0 <__malloc_unlock>
 8000616:	e63d      	b.n	8000294 <_malloc_r+0x6c>
 8000618:	0a41      	lsrs	r1, r0, #9
 800061a:	2904      	cmp	r1, #4
 800061c:	bf9c      	itt	ls
 800061e:	ea4f 1e90 	movls.w	lr, r0, lsr #6
 8000622:	f10e 0e38 	addls.w	lr, lr, #56	; 0x38
 8000626:	d91d      	bls.n	8000664 <_malloc_r+0x43c>
 8000628:	2914      	cmp	r1, #20
 800062a:	bf98      	it	ls
 800062c:	f101 0e5b 	addls.w	lr, r1, #91	; 0x5b
 8000630:	d918      	bls.n	8000664 <_malloc_r+0x43c>
 8000632:	2954      	cmp	r1, #84	; 0x54
 8000634:	bf9c      	itt	ls
 8000636:	ea4f 3e10 	movls.w	lr, r0, lsr #12
 800063a:	f10e 0e6e 	addls.w	lr, lr, #110	; 0x6e
 800063e:	d911      	bls.n	8000664 <_malloc_r+0x43c>
 8000640:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8000644:	bf9c      	itt	ls
 8000646:	ea4f 3ed0 	movls.w	lr, r0, lsr #15
 800064a:	f10e 0e77 	addls.w	lr, lr, #119	; 0x77
 800064e:	d909      	bls.n	8000664 <_malloc_r+0x43c>
 8000650:	f240 5e54 	movw	lr, #1364	; 0x554
 8000654:	4571      	cmp	r1, lr
 8000656:	bf96      	itet	ls
 8000658:	ea4f 4e90 	movls.w	lr, r0, lsr #18
 800065c:	f04f 0e7e 	movhi.w	lr, #126	; 0x7e
 8000660:	f10e 0e7c 	addls.w	lr, lr, #124	; 0x7c
 8000664:	eb07 08ce 	add.w	r8, r7, lr, lsl #3
 8000668:	f8d8 1008 	ldr.w	r1, [r8, #8]
 800066c:	4541      	cmp	r1, r8
 800066e:	d103      	bne.n	8000678 <_malloc_r+0x450>
 8000670:	e047      	b.n	8000702 <_malloc_r+0x4da>
 8000672:	6889      	ldr	r1, [r1, #8]
 8000674:	4588      	cmp	r8, r1
 8000676:	d005      	beq.n	8000684 <_malloc_r+0x45c>
 8000678:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800067c:	f02e 0e03 	bic.w	lr, lr, #3
 8000680:	4570      	cmp	r0, lr
 8000682:	d3f6      	bcc.n	8000672 <_malloc_r+0x44a>
 8000684:	f8d1 e00c 	ldr.w	lr, [r1, #12]
 8000688:	f8c3 e00c 	str.w	lr, [r3, #12]
 800068c:	6099      	str	r1, [r3, #8]
 800068e:	6878      	ldr	r0, [r7, #4]
 8000690:	60cb      	str	r3, [r1, #12]
 8000692:	f8ce 3008 	str.w	r3, [lr, #8]
 8000696:	e65d      	b.n	8000354 <_malloc_r+0x12c>
 8000698:	191d      	adds	r5, r3, r4
 800069a:	f041 0701 	orr.w	r7, r1, #1
 800069e:	60d5      	str	r5, [r2, #12]
 80006a0:	f044 0401 	orr.w	r4, r4, #1
 80006a4:	6095      	str	r5, [r2, #8]
 80006a6:	4630      	mov	r0, r6
 80006a8:	605c      	str	r4, [r3, #4]
 80006aa:	f103 0808 	add.w	r8, r3, #8
 80006ae:	60ea      	str	r2, [r5, #12]
 80006b0:	60aa      	str	r2, [r5, #8]
 80006b2:	606f      	str	r7, [r5, #4]
 80006b4:	5069      	str	r1, [r5, r1]
 80006b6:	f000 fd9b 	bl	80011f0 <__malloc_unlock>
 80006ba:	e5eb      	b.n	8000294 <_malloc_r+0x6c>
 80006bc:	f109 0901 	add.w	r9, r9, #1
 80006c0:	f019 0f03 	tst.w	r9, #3
 80006c4:	d02f      	beq.n	8000726 <_malloc_r+0x4fe>
 80006c6:	f108 0808 	add.w	r8, r8, #8
 80006ca:	e65b      	b.n	8000384 <_malloc_r+0x15c>
 80006cc:	f103 0208 	add.w	r2, r3, #8
 80006d0:	695b      	ldr	r3, [r3, #20]
 80006d2:	429a      	cmp	r2, r3
 80006d4:	bf08      	it	eq
 80006d6:	f10c 0c02 	addeq.w	ip, ip, #2
 80006da:	f43f ae10 	beq.w	80002fe <_malloc_r+0xd6>
 80006de:	e5c8      	b.n	8000272 <_malloc_r+0x4a>
 80006e0:	4680      	mov	r8, r0
 80006e2:	1843      	adds	r3, r0, r1
 80006e4:	68c2      	ldr	r2, [r0, #12]
 80006e6:	4630      	mov	r0, r6
 80006e8:	f858 1f08 	ldr.w	r1, [r8, #8]!
 80006ec:	e5ca      	b.n	8000284 <_malloc_r+0x5c>
 80006ee:	45b8      	cmp	r8, r7
 80006f0:	f43f aeed 	beq.w	80004ce <_malloc_r+0x2a6>
 80006f4:	f8d7 8008 	ldr.w	r8, [r7, #8]
 80006f8:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80006fc:	f023 0303 	bic.w	r3, r3, #3
 8000700:	e758      	b.n	80005b4 <_malloc_r+0x38c>
 8000702:	f04f 0901 	mov.w	r9, #1
 8000706:	f8d7 8004 	ldr.w	r8, [r7, #4]
 800070a:	ea4f 00ae 	mov.w	r0, lr, asr #2
 800070e:	468e      	mov	lr, r1
 8000710:	fa09 f000 	lsl.w	r0, r9, r0
 8000714:	ea48 0000 	orr.w	r0, r8, r0
 8000718:	6078      	str	r0, [r7, #4]
 800071a:	e7b5      	b.n	8000688 <_malloc_r+0x460>
 800071c:	4698      	mov	r8, r3
 800071e:	2201      	movs	r2, #1
 8000720:	605a      	str	r2, [r3, #4]
 8000722:	2300      	movs	r3, #0
 8000724:	e746      	b.n	80005b4 <_malloc_r+0x38c>
 8000726:	4651      	mov	r1, sl
 8000728:	f01c 0f03 	tst.w	ip, #3
 800072c:	460b      	mov	r3, r1
 800072e:	f10c 3cff 	add.w	ip, ip, #4294967295
 8000732:	d02c      	beq.n	800078e <_malloc_r+0x566>
 8000734:	f853 1908 	ldr.w	r1, [r3], #-8
 8000738:	4299      	cmp	r1, r3
 800073a:	d0f5      	beq.n	8000728 <_malloc_r+0x500>
 800073c:	687b      	ldr	r3, [r7, #4]
 800073e:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 8000742:	459e      	cmp	lr, r3
 8000744:	f63f ae8c 	bhi.w	8000460 <_malloc_r+0x238>
 8000748:	f1be 0f00 	cmp.w	lr, #0
 800074c:	f43f ae88 	beq.w	8000460 <_malloc_r+0x238>
 8000750:	ea1e 0f03 	tst.w	lr, r3
 8000754:	d020      	beq.n	8000798 <_malloc_r+0x570>
 8000756:	46cc      	mov	ip, r9
 8000758:	e610      	b.n	800037c <_malloc_r+0x154>
 800075a:	ea4f 5e01 	mov.w	lr, r1, lsl #20
 800075e:	ea4f 5e1e 	mov.w	lr, lr, lsr #20
 8000762:	f1be 0f00 	cmp.w	lr, #0
 8000766:	f47f aeba 	bne.w	80004de <_malloc_r+0x2b6>
 800076a:	68bb      	ldr	r3, [r7, #8]
 800076c:	eb0b 0109 	add.w	r1, fp, r9
 8000770:	f041 0101 	orr.w	r1, r1, #1
 8000774:	6059      	str	r1, [r3, #4]
 8000776:	e704      	b.n	8000582 <_malloc_r+0x35a>
 8000778:	4630      	mov	r0, r6
 800077a:	f108 0108 	add.w	r1, r8, #8
 800077e:	f000 f8fb 	bl	8000978 <_free_r>
 8000782:	f8db 2004 	ldr.w	r2, [fp, #4]
 8000786:	e6fc      	b.n	8000582 <_malloc_r+0x35a>
 8000788:	2101      	movs	r1, #1
 800078a:	2500      	movs	r5, #0
 800078c:	e6d4      	b.n	8000538 <_malloc_r+0x310>
 800078e:	687b      	ldr	r3, [r7, #4]
 8000790:	ea23 030e 	bic.w	r3, r3, lr
 8000794:	607b      	str	r3, [r7, #4]
 8000796:	e7d1      	b.n	800073c <_malloc_r+0x514>
 8000798:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
 800079c:	f109 0904 	add.w	r9, r9, #4
 80007a0:	e7d6      	b.n	8000750 <_malloc_r+0x528>
 80007a2:	bf00      	nop

080007a4 <memset>:
 80007a4:	2a03      	cmp	r2, #3
 80007a6:	b2c9      	uxtb	r1, r1
 80007a8:	b470      	push	{r4, r5, r6}
 80007aa:	d808      	bhi.n	80007be <memset+0x1a>
 80007ac:	b12a      	cbz	r2, 80007ba <memset+0x16>
 80007ae:	4603      	mov	r3, r0
 80007b0:	1812      	adds	r2, r2, r0
 80007b2:	f803 1b01 	strb.w	r1, [r3], #1
 80007b6:	4293      	cmp	r3, r2
 80007b8:	d1fb      	bne.n	80007b2 <memset+0xe>
 80007ba:	bc70      	pop	{r4, r5, r6}
 80007bc:	4770      	bx	lr
 80007be:	1882      	adds	r2, r0, r2
 80007c0:	4604      	mov	r4, r0
 80007c2:	e001      	b.n	80007c8 <memset+0x24>
 80007c4:	f804 1b01 	strb.w	r1, [r4], #1
 80007c8:	f014 0f03 	tst.w	r4, #3
 80007cc:	d1fa      	bne.n	80007c4 <memset+0x20>
 80007ce:	f04f 3301 	mov.w	r3, #16843009	; 0x1010101
 80007d2:	fb03 f301 	mul.w	r3, r3, r1
 80007d6:	e01f      	b.n	8000818 <memset+0x74>
 80007d8:	f844 3c40 	str.w	r3, [r4, #-64]
 80007dc:	f844 3c3c 	str.w	r3, [r4, #-60]
 80007e0:	f844 3c38 	str.w	r3, [r4, #-56]
 80007e4:	f844 3c34 	str.w	r3, [r4, #-52]
 80007e8:	f844 3c30 	str.w	r3, [r4, #-48]
 80007ec:	f844 3c2c 	str.w	r3, [r4, #-44]
 80007f0:	f844 3c28 	str.w	r3, [r4, #-40]
 80007f4:	f844 3c24 	str.w	r3, [r4, #-36]
 80007f8:	f844 3c20 	str.w	r3, [r4, #-32]
 80007fc:	f844 3c1c 	str.w	r3, [r4, #-28]
 8000800:	f844 3c18 	str.w	r3, [r4, #-24]
 8000804:	f844 3c14 	str.w	r3, [r4, #-20]
 8000808:	f844 3c10 	str.w	r3, [r4, #-16]
 800080c:	f844 3c0c 	str.w	r3, [r4, #-12]
 8000810:	f844 3c08 	str.w	r3, [r4, #-8]
 8000814:	f844 3c04 	str.w	r3, [r4, #-4]
 8000818:	1b16      	subs	r6, r2, r4
 800081a:	4625      	mov	r5, r4
 800081c:	3440      	adds	r4, #64	; 0x40
 800081e:	2e3f      	cmp	r6, #63	; 0x3f
 8000820:	dcda      	bgt.n	80007d8 <memset+0x34>
 8000822:	462c      	mov	r4, r5
 8000824:	e007      	b.n	8000836 <memset+0x92>
 8000826:	f844 3c10 	str.w	r3, [r4, #-16]
 800082a:	f844 3c0c 	str.w	r3, [r4, #-12]
 800082e:	f844 3c08 	str.w	r3, [r4, #-8]
 8000832:	f844 3c04 	str.w	r3, [r4, #-4]
 8000836:	1b16      	subs	r6, r2, r4
 8000838:	4625      	mov	r5, r4
 800083a:	3410      	adds	r4, #16
 800083c:	2e0f      	cmp	r6, #15
 800083e:	dcf2      	bgt.n	8000826 <memset+0x82>
 8000840:	e001      	b.n	8000846 <memset+0xa2>
 8000842:	f845 3b04 	str.w	r3, [r5], #4
 8000846:	1b54      	subs	r4, r2, r5
 8000848:	2c03      	cmp	r4, #3
 800084a:	dcfa      	bgt.n	8000842 <memset+0x9e>
 800084c:	e001      	b.n	8000852 <memset+0xae>
 800084e:	f805 1b01 	strb.w	r1, [r5], #1
 8000852:	4295      	cmp	r5, r2
 8000854:	d3fb      	bcc.n	800084e <memset+0xaa>
 8000856:	e7b0      	b.n	80007ba <memset+0x16>

08000858 <strncpy>:
 8000858:	ea41 0300 	orr.w	r3, r1, r0
 800085c:	f013 0f03 	tst.w	r3, #3
 8000860:	460b      	mov	r3, r1
 8000862:	b470      	push	{r4, r5, r6}
 8000864:	bf14      	ite	ne
 8000866:	2400      	movne	r4, #0
 8000868:	2401      	moveq	r4, #1
 800086a:	2a03      	cmp	r2, #3
 800086c:	bf94      	ite	ls
 800086e:	2400      	movls	r4, #0
 8000870:	f004 0401 	andhi.w	r4, r4, #1
 8000874:	4605      	mov	r5, r0
 8000876:	b9d4      	cbnz	r4, 80008ae <strncpy+0x56>
 8000878:	b1ba      	cbz	r2, 80008aa <strncpy+0x52>
 800087a:	780e      	ldrb	r6, [r1, #0]
 800087c:	462b      	mov	r3, r5
 800087e:	3a01      	subs	r2, #1
 8000880:	f803 6b01 	strb.w	r6, [r3], #1
 8000884:	b156      	cbz	r6, 800089c <strncpy+0x44>
 8000886:	1cac      	adds	r4, r5, #2
 8000888:	b17a      	cbz	r2, 80008aa <strncpy+0x52>
 800088a:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 800088e:	4623      	mov	r3, r4
 8000890:	3a01      	subs	r2, #1
 8000892:	f804 5c01 	strb.w	r5, [r4, #-1]
 8000896:	3401      	adds	r4, #1
 8000898:	2d00      	cmp	r5, #0
 800089a:	d1f5      	bne.n	8000888 <strncpy+0x30>
 800089c:	b12a      	cbz	r2, 80008aa <strncpy+0x52>
 800089e:	189a      	adds	r2, r3, r2
 80008a0:	2100      	movs	r1, #0
 80008a2:	f803 1b01 	strb.w	r1, [r3], #1
 80008a6:	4293      	cmp	r3, r2
 80008a8:	d1fb      	bne.n	80008a2 <strncpy+0x4a>
 80008aa:	bc70      	pop	{r4, r5, r6}
 80008ac:	4770      	bx	lr
 80008ae:	4619      	mov	r1, r3
 80008b0:	f853 4b04 	ldr.w	r4, [r3], #4
 80008b4:	f1a4 3601 	sub.w	r6, r4, #16843009	; 0x1010101
 80008b8:	ea26 0604 	bic.w	r6, r6, r4
 80008bc:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 80008c0:	d1da      	bne.n	8000878 <strncpy+0x20>
 80008c2:	3a04      	subs	r2, #4
 80008c4:	f845 4b04 	str.w	r4, [r5], #4
 80008c8:	2a03      	cmp	r2, #3
 80008ca:	4619      	mov	r1, r3
 80008cc:	d8ef      	bhi.n	80008ae <strncpy+0x56>
 80008ce:	e7d3      	b.n	8000878 <strncpy+0x20>

080008d0 <_malloc_trim_r>:
 80008d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80008d2:	f240 0400 	movw	r4, #0
 80008d6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80008da:	460f      	mov	r7, r1
 80008dc:	4605      	mov	r5, r0
 80008de:	f000 fc7d 	bl	80011dc <__malloc_lock>
 80008e2:	68a3      	ldr	r3, [r4, #8]
 80008e4:	685e      	ldr	r6, [r3, #4]
 80008e6:	f026 0603 	bic.w	r6, r6, #3
 80008ea:	f506 637e 	add.w	r3, r6, #4064	; 0xfe0
 80008ee:	330f      	adds	r3, #15
 80008f0:	1bdf      	subs	r7, r3, r7
 80008f2:	0b3f      	lsrs	r7, r7, #12
 80008f4:	3f01      	subs	r7, #1
 80008f6:	033f      	lsls	r7, r7, #12
 80008f8:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 80008fc:	db07      	blt.n	800090e <_malloc_trim_r+0x3e>
 80008fe:	2100      	movs	r1, #0
 8000900:	4628      	mov	r0, r5
 8000902:	f000 fc35 	bl	8001170 <_sbrk_r>
 8000906:	68a3      	ldr	r3, [r4, #8]
 8000908:	199b      	adds	r3, r3, r6
 800090a:	4298      	cmp	r0, r3
 800090c:	d004      	beq.n	8000918 <_malloc_trim_r+0x48>
 800090e:	4628      	mov	r0, r5
 8000910:	f000 fc6e 	bl	80011f0 <__malloc_unlock>
 8000914:	2000      	movs	r0, #0
 8000916:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000918:	4279      	negs	r1, r7
 800091a:	4628      	mov	r0, r5
 800091c:	f000 fc28 	bl	8001170 <_sbrk_r>
 8000920:	f1b0 3fff 	cmp.w	r0, #4294967295
 8000924:	d010      	beq.n	8000948 <_malloc_trim_r+0x78>
 8000926:	f240 5350 	movw	r3, #1360	; 0x550
 800092a:	68a1      	ldr	r1, [r4, #8]
 800092c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000930:	1bf6      	subs	r6, r6, r7
 8000932:	4628      	mov	r0, r5
 8000934:	f046 0601 	orr.w	r6, r6, #1
 8000938:	681a      	ldr	r2, [r3, #0]
 800093a:	604e      	str	r6, [r1, #4]
 800093c:	1bd7      	subs	r7, r2, r7
 800093e:	601f      	str	r7, [r3, #0]
 8000940:	f000 fc56 	bl	80011f0 <__malloc_unlock>
 8000944:	2001      	movs	r0, #1
 8000946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000948:	2100      	movs	r1, #0
 800094a:	4628      	mov	r0, r5
 800094c:	f000 fc10 	bl	8001170 <_sbrk_r>
 8000950:	68a3      	ldr	r3, [r4, #8]
 8000952:	1ac2      	subs	r2, r0, r3
 8000954:	2a0f      	cmp	r2, #15
 8000956:	ddda      	ble.n	800090e <_malloc_trim_r+0x3e>
 8000958:	f240 4408 	movw	r4, #1032	; 0x408
 800095c:	f240 5150 	movw	r1, #1360	; 0x550
 8000960:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000964:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000968:	f042 0201 	orr.w	r2, r2, #1
 800096c:	605a      	str	r2, [r3, #4]
 800096e:	6823      	ldr	r3, [r4, #0]
 8000970:	1ac0      	subs	r0, r0, r3
 8000972:	6008      	str	r0, [r1, #0]
 8000974:	e7cb      	b.n	800090e <_malloc_trim_r+0x3e>
 8000976:	bf00      	nop

08000978 <_free_r>:
 8000978:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800097c:	460d      	mov	r5, r1
 800097e:	4604      	mov	r4, r0
 8000980:	2900      	cmp	r1, #0
 8000982:	d058      	beq.n	8000a36 <_free_r+0xbe>
 8000984:	f000 fc2a 	bl	80011dc <__malloc_lock>
 8000988:	f1a5 0208 	sub.w	r2, r5, #8
 800098c:	f240 0000 	movw	r0, #0
 8000990:	6856      	ldr	r6, [r2, #4]
 8000992:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000996:	f026 0301 	bic.w	r3, r6, #1
 800099a:	f8d0 c008 	ldr.w	ip, [r0, #8]
 800099e:	18d1      	adds	r1, r2, r3
 80009a0:	458c      	cmp	ip, r1
 80009a2:	684f      	ldr	r7, [r1, #4]
 80009a4:	f027 0703 	bic.w	r7, r7, #3
 80009a8:	d065      	beq.n	8000a76 <_free_r+0xfe>
 80009aa:	f016 0601 	ands.w	r6, r6, #1
 80009ae:	604f      	str	r7, [r1, #4]
 80009b0:	d031      	beq.n	8000a16 <_free_r+0x9e>
 80009b2:	2600      	movs	r6, #0
 80009b4:	19cd      	adds	r5, r1, r7
 80009b6:	686d      	ldr	r5, [r5, #4]
 80009b8:	f015 0f01 	tst.w	r5, #1
 80009bc:	d106      	bne.n	80009cc <_free_r+0x54>
 80009be:	19db      	adds	r3, r3, r7
 80009c0:	2e00      	cmp	r6, #0
 80009c2:	d04b      	beq.n	8000a5c <_free_r+0xe4>
 80009c4:	688d      	ldr	r5, [r1, #8]
 80009c6:	68c9      	ldr	r1, [r1, #12]
 80009c8:	60e9      	str	r1, [r5, #12]
 80009ca:	608d      	str	r5, [r1, #8]
 80009cc:	f043 0101 	orr.w	r1, r3, #1
 80009d0:	50d3      	str	r3, [r2, r3]
 80009d2:	6051      	str	r1, [r2, #4]
 80009d4:	b9d6      	cbnz	r6, 8000a0c <_free_r+0x94>
 80009d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80009da:	d32e      	bcc.n	8000a3a <_free_r+0xc2>
 80009dc:	0a59      	lsrs	r1, r3, #9
 80009de:	2904      	cmp	r1, #4
 80009e0:	d86b      	bhi.n	8000aba <_free_r+0x142>
 80009e2:	099e      	lsrs	r6, r3, #6
 80009e4:	3638      	adds	r6, #56	; 0x38
 80009e6:	00f5      	lsls	r5, r6, #3
 80009e8:	1945      	adds	r5, r0, r5
 80009ea:	68a9      	ldr	r1, [r5, #8]
 80009ec:	42a9      	cmp	r1, r5
 80009ee:	d103      	bne.n	80009f8 <_free_r+0x80>
 80009f0:	e069      	b.n	8000ac6 <_free_r+0x14e>
 80009f2:	6889      	ldr	r1, [r1, #8]
 80009f4:	428d      	cmp	r5, r1
 80009f6:	d004      	beq.n	8000a02 <_free_r+0x8a>
 80009f8:	6848      	ldr	r0, [r1, #4]
 80009fa:	f020 0003 	bic.w	r0, r0, #3
 80009fe:	4283      	cmp	r3, r0
 8000a00:	d3f7      	bcc.n	80009f2 <_free_r+0x7a>
 8000a02:	68cb      	ldr	r3, [r1, #12]
 8000a04:	60d3      	str	r3, [r2, #12]
 8000a06:	6091      	str	r1, [r2, #8]
 8000a08:	60ca      	str	r2, [r1, #12]
 8000a0a:	609a      	str	r2, [r3, #8]
 8000a0c:	4620      	mov	r0, r4
 8000a0e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8000a12:	f000 bbed 	b.w	80011f0 <__malloc_unlock>
 8000a16:	f855 5c08 	ldr.w	r5, [r5, #-8]
 8000a1a:	f100 0c08 	add.w	ip, r0, #8
 8000a1e:	1b52      	subs	r2, r2, r5
 8000a20:	195b      	adds	r3, r3, r5
 8000a22:	6895      	ldr	r5, [r2, #8]
 8000a24:	4565      	cmp	r5, ip
 8000a26:	d046      	beq.n	8000ab6 <_free_r+0x13e>
 8000a28:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8000a2c:	f8c5 c00c 	str.w	ip, [r5, #12]
 8000a30:	f8cc 5008 	str.w	r5, [ip, #8]
 8000a34:	e7be      	b.n	80009b4 <_free_r+0x3c>
 8000a36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000a3a:	08db      	lsrs	r3, r3, #3
 8000a3c:	2501      	movs	r5, #1
 8000a3e:	6846      	ldr	r6, [r0, #4]
 8000a40:	eb00 01c3 	add.w	r1, r0, r3, lsl #3
 8000a44:	109b      	asrs	r3, r3, #2
 8000a46:	fa15 f303 	lsls.w	r3, r5, r3
 8000a4a:	60d1      	str	r1, [r2, #12]
 8000a4c:	688d      	ldr	r5, [r1, #8]
 8000a4e:	ea46 0303 	orr.w	r3, r6, r3
 8000a52:	6043      	str	r3, [r0, #4]
 8000a54:	6095      	str	r5, [r2, #8]
 8000a56:	60ea      	str	r2, [r5, #12]
 8000a58:	608a      	str	r2, [r1, #8]
 8000a5a:	e7d7      	b.n	8000a0c <_free_r+0x94>
 8000a5c:	688d      	ldr	r5, [r1, #8]
 8000a5e:	4f2b      	ldr	r7, [pc, #172]	; (8000b0c <_free_r+0x194>)
 8000a60:	42bd      	cmp	r5, r7
 8000a62:	d1b0      	bne.n	80009c6 <_free_r+0x4e>
 8000a64:	60ea      	str	r2, [r5, #12]
 8000a66:	f043 0101 	orr.w	r1, r3, #1
 8000a6a:	60aa      	str	r2, [r5, #8]
 8000a6c:	60d5      	str	r5, [r2, #12]
 8000a6e:	6095      	str	r5, [r2, #8]
 8000a70:	6051      	str	r1, [r2, #4]
 8000a72:	50d3      	str	r3, [r2, r3]
 8000a74:	e7ca      	b.n	8000a0c <_free_r+0x94>
 8000a76:	f016 0f01 	tst.w	r6, #1
 8000a7a:	443b      	add	r3, r7
 8000a7c:	d107      	bne.n	8000a8e <_free_r+0x116>
 8000a7e:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8000a82:	1a52      	subs	r2, r2, r1
 8000a84:	185b      	adds	r3, r3, r1
 8000a86:	6895      	ldr	r5, [r2, #8]
 8000a88:	68d1      	ldr	r1, [r2, #12]
 8000a8a:	60e9      	str	r1, [r5, #12]
 8000a8c:	608d      	str	r5, [r1, #8]
 8000a8e:	f240 410c 	movw	r1, #1036	; 0x40c
 8000a92:	f043 0501 	orr.w	r5, r3, #1
 8000a96:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000a9a:	6055      	str	r5, [r2, #4]
 8000a9c:	6082      	str	r2, [r0, #8]
 8000a9e:	680a      	ldr	r2, [r1, #0]
 8000aa0:	4293      	cmp	r3, r2
 8000aa2:	d3b3      	bcc.n	8000a0c <_free_r+0x94>
 8000aa4:	f240 534c 	movw	r3, #1356	; 0x54c
 8000aa8:	4620      	mov	r0, r4
 8000aaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000aae:	6819      	ldr	r1, [r3, #0]
 8000ab0:	f7ff ff0e 	bl	80008d0 <_malloc_trim_r>
 8000ab4:	e7aa      	b.n	8000a0c <_free_r+0x94>
 8000ab6:	2601      	movs	r6, #1
 8000ab8:	e77c      	b.n	80009b4 <_free_r+0x3c>
 8000aba:	2914      	cmp	r1, #20
 8000abc:	d80c      	bhi.n	8000ad8 <_free_r+0x160>
 8000abe:	f101 065b 	add.w	r6, r1, #91	; 0x5b
 8000ac2:	00f5      	lsls	r5, r6, #3
 8000ac4:	e790      	b.n	80009e8 <_free_r+0x70>
 8000ac6:	2501      	movs	r5, #1
 8000ac8:	6847      	ldr	r7, [r0, #4]
 8000aca:	10b6      	asrs	r6, r6, #2
 8000acc:	460b      	mov	r3, r1
 8000ace:	40b5      	lsls	r5, r6
 8000ad0:	ea47 0505 	orr.w	r5, r7, r5
 8000ad4:	6045      	str	r5, [r0, #4]
 8000ad6:	e795      	b.n	8000a04 <_free_r+0x8c>
 8000ad8:	2954      	cmp	r1, #84	; 0x54
 8000ada:	d803      	bhi.n	8000ae4 <_free_r+0x16c>
 8000adc:	0b1e      	lsrs	r6, r3, #12
 8000ade:	366e      	adds	r6, #110	; 0x6e
 8000ae0:	00f5      	lsls	r5, r6, #3
 8000ae2:	e781      	b.n	80009e8 <_free_r+0x70>
 8000ae4:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 8000ae8:	d803      	bhi.n	8000af2 <_free_r+0x17a>
 8000aea:	0bde      	lsrs	r6, r3, #15
 8000aec:	3677      	adds	r6, #119	; 0x77
 8000aee:	00f5      	lsls	r5, r6, #3
 8000af0:	e77a      	b.n	80009e8 <_free_r+0x70>
 8000af2:	f240 5554 	movw	r5, #1364	; 0x554
 8000af6:	42a9      	cmp	r1, r5
 8000af8:	d803      	bhi.n	8000b02 <_free_r+0x18a>
 8000afa:	0c9e      	lsrs	r6, r3, #18
 8000afc:	367c      	adds	r6, #124	; 0x7c
 8000afe:	00f5      	lsls	r5, r6, #3
 8000b00:	e772      	b.n	80009e8 <_free_r+0x70>
 8000b02:	f44f 757c 	mov.w	r5, #1008	; 0x3f0
 8000b06:	267e      	movs	r6, #126	; 0x7e
 8000b08:	e76e      	b.n	80009e8 <_free_r+0x70>
 8000b0a:	bf00      	nop
 8000b0c:	20000008 	.word	0x20000008

08000b10 <rb_getc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes read (0 if buffer was empty)
 */
static inline int rb_getc(struct ringbuf *rb, char *data)
{
 8000b10:	b580      	push	{r7, lr}
 8000b12:	b082      	sub	sp, #8
 8000b14:	af00      	add	r7, sp, #0
 8000b16:	6078      	str	r0, [r7, #4]
 8000b18:	6039      	str	r1, [r7, #0]
    if (!rb->len)
 8000b1a:	687b      	ldr	r3, [r7, #4]
 8000b1c:	68db      	ldr	r3, [r3, #12]
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d102      	bne.n	8000b28 <rb_getc+0x18>
        return 0;
 8000b22:	f04f 0300 	mov.w	r3, #0
 8000b26:	e025      	b.n	8000b74 <rb_getc+0x64>

    vPortEnterCritical();
 8000b28:	f001 f824 	bl	8001b74 <vPortEnterCritical>

    *data = rb->buf[rb->pos++];
 8000b2c:	687b      	ldr	r3, [r7, #4]
 8000b2e:	6819      	ldr	r1, [r3, #0]
 8000b30:	687b      	ldr	r3, [r7, #4]
 8000b32:	689b      	ldr	r3, [r3, #8]
 8000b34:	461a      	mov	r2, r3
 8000b36:	188a      	adds	r2, r1, r2
 8000b38:	7811      	ldrb	r1, [r2, #0]
 8000b3a:	683a      	ldr	r2, [r7, #0]
 8000b3c:	7011      	strb	r1, [r2, #0]
 8000b3e:	f103 0201 	add.w	r2, r3, #1
 8000b42:	687b      	ldr	r3, [r7, #4]
 8000b44:	609a      	str	r2, [r3, #8]
	if (rb->pos >= rb->bufsize)
 8000b46:	687b      	ldr	r3, [r7, #4]
 8000b48:	689a      	ldr	r2, [r3, #8]
 8000b4a:	687b      	ldr	r3, [r7, #4]
 8000b4c:	685b      	ldr	r3, [r3, #4]
 8000b4e:	429a      	cmp	r2, r3
 8000b50:	db06      	blt.n	8000b60 <rb_getc+0x50>
		rb->pos -= rb->bufsize;
 8000b52:	687b      	ldr	r3, [r7, #4]
 8000b54:	689a      	ldr	r2, [r3, #8]
 8000b56:	687b      	ldr	r3, [r7, #4]
 8000b58:	685b      	ldr	r3, [r3, #4]
 8000b5a:	1ad2      	subs	r2, r2, r3
 8000b5c:	687b      	ldr	r3, [r7, #4]
 8000b5e:	609a      	str	r2, [r3, #8]
	rb->len--;
 8000b60:	687b      	ldr	r3, [r7, #4]
 8000b62:	68db      	ldr	r3, [r3, #12]
 8000b64:	f103 32ff 	add.w	r2, r3, #4294967295
 8000b68:	687b      	ldr	r3, [r7, #4]
 8000b6a:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 8000b6c:	f001 f814 	bl	8001b98 <vPortExitCritical>
    return 1;
 8000b70:	f04f 0301 	mov.w	r3, #1
}
 8000b74:	4618      	mov	r0, r3
 8000b76:	f107 0708 	add.w	r7, r7, #8
 8000b7a:	46bd      	mov	sp, r7
 8000b7c:	bd80      	pop	{r7, pc}
 8000b7e:	bf00      	nop

08000b80 <rb_putc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes written (0 if buffer was full)
 */
static inline int rb_putc(struct ringbuf *rb, const char data)
{
 8000b80:	b580      	push	{r7, lr}
 8000b82:	b084      	sub	sp, #16
 8000b84:	af00      	add	r7, sp, #0
 8000b86:	6078      	str	r0, [r7, #4]
 8000b88:	460b      	mov	r3, r1
 8000b8a:	70fb      	strb	r3, [r7, #3]
    if (rb->len >= rb->bufsize)
 8000b8c:	687b      	ldr	r3, [r7, #4]
 8000b8e:	68da      	ldr	r2, [r3, #12]
 8000b90:	687b      	ldr	r3, [r7, #4]
 8000b92:	685b      	ldr	r3, [r3, #4]
 8000b94:	429a      	cmp	r2, r3
 8000b96:	db02      	blt.n	8000b9e <rb_putc+0x1e>
        return 0;
 8000b98:	f04f 0300 	mov.w	r3, #0
 8000b9c:	e021      	b.n	8000be2 <rb_putc+0x62>

    vPortEnterCritical();
 8000b9e:	f000 ffe9 	bl	8001b74 <vPortEnterCritical>

	int i = rb->pos + rb->len;
 8000ba2:	687b      	ldr	r3, [r7, #4]
 8000ba4:	689a      	ldr	r2, [r3, #8]
 8000ba6:	687b      	ldr	r3, [r7, #4]
 8000ba8:	68db      	ldr	r3, [r3, #12]
 8000baa:	18d3      	adds	r3, r2, r3
 8000bac:	60fb      	str	r3, [r7, #12]
	if (i >= rb->bufsize)
 8000bae:	687b      	ldr	r3, [r7, #4]
 8000bb0:	685a      	ldr	r2, [r3, #4]
 8000bb2:	68fb      	ldr	r3, [r7, #12]
 8000bb4:	429a      	cmp	r2, r3
 8000bb6:	dc04      	bgt.n	8000bc2 <rb_putc+0x42>
		i -= rb->bufsize;
 8000bb8:	687b      	ldr	r3, [r7, #4]
 8000bba:	685b      	ldr	r3, [r3, #4]
 8000bbc:	68fa      	ldr	r2, [r7, #12]
 8000bbe:	1ad3      	subs	r3, r2, r3
 8000bc0:	60fb      	str	r3, [r7, #12]

	rb->buf[i] = data;
 8000bc2:	687b      	ldr	r3, [r7, #4]
 8000bc4:	681a      	ldr	r2, [r3, #0]
 8000bc6:	68fb      	ldr	r3, [r7, #12]
 8000bc8:	18d3      	adds	r3, r2, r3
 8000bca:	78fa      	ldrb	r2, [r7, #3]
 8000bcc:	701a      	strb	r2, [r3, #0]
	rb->len++;
 8000bce:	687b      	ldr	r3, [r7, #4]
 8000bd0:	68db      	ldr	r3, [r3, #12]
 8000bd2:	f103 0201 	add.w	r2, r3, #1
 8000bd6:	687b      	ldr	r3, [r7, #4]
 8000bd8:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 8000bda:	f000 ffdd 	bl	8001b98 <vPortExitCritical>
    return 1;
 8000bde:	f04f 0301 	mov.w	r3, #1
}
 8000be2:	4618      	mov	r0, r3
 8000be4:	f107 0710 	add.w	r7, r7, #16
 8000be8:	46bd      	mov	sp, r7
 8000bea:	bd80      	pop	{r7, pc}

08000bec <USART1_IRQHandler>:
    uint32_t    tx_bytes;
} uart_stats;


void USART1_IRQHandler(void)
{
 8000bec:	b580      	push	{r7, lr}
 8000bee:	b082      	sub	sp, #8
 8000bf0:	af00      	add	r7, sp, #0
    if (USART1->SR & USART_SR_RXNE) {
 8000bf2:	4b22      	ldr	r3, [pc, #136]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000bf4:	881b      	ldrh	r3, [r3, #0]
 8000bf6:	b29b      	uxth	r3, r3
 8000bf8:	f003 0320 	and.w	r3, r3, #32
 8000bfc:	2b00      	cmp	r3, #0
 8000bfe:	d017      	beq.n	8000c30 <USART1_IRQHandler+0x44>
        if (!rb_putc(&rx_buf, USART1->DR))
 8000c00:	4b1e      	ldr	r3, [pc, #120]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000c02:	889b      	ldrh	r3, [r3, #4]
 8000c04:	b29b      	uxth	r3, r3
 8000c06:	b2db      	uxtb	r3, r3
 8000c08:	481d      	ldr	r0, [pc, #116]	; (8000c80 <USART1_IRQHandler+0x94>)
 8000c0a:	4619      	mov	r1, r3
 8000c0c:	f7ff ffb8 	bl	8000b80 <rb_putc>
 8000c10:	4603      	mov	r3, r0
 8000c12:	2b00      	cmp	r3, #0
 8000c14:	d106      	bne.n	8000c24 <USART1_IRQHandler+0x38>
            uart_stats.rx_overrun++;
 8000c16:	4b1b      	ldr	r3, [pc, #108]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c18:	681b      	ldr	r3, [r3, #0]
 8000c1a:	f103 0201 	add.w	r2, r3, #1
 8000c1e:	4b19      	ldr	r3, [pc, #100]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c20:	601a      	str	r2, [r3, #0]
 8000c22:	e005      	b.n	8000c30 <USART1_IRQHandler+0x44>
        else
            uart_stats.rx_bytes++;
 8000c24:	4b17      	ldr	r3, [pc, #92]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c26:	685b      	ldr	r3, [r3, #4]
 8000c28:	f103 0201 	add.w	r2, r3, #1
 8000c2c:	4b15      	ldr	r3, [pc, #84]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c2e:	605a      	str	r2, [r3, #4]
    }

    if (USART1->SR & USART_SR_TXE) {
 8000c30:	4b12      	ldr	r3, [pc, #72]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000c32:	881b      	ldrh	r3, [r3, #0]
 8000c34:	b29b      	uxth	r3, r3
 8000c36:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000c3a:	2b00      	cmp	r3, #0
 8000c3c:	d01a      	beq.n	8000c74 <USART1_IRQHandler+0x88>
        char c;
        if (rb_getc(&tx_buf, &c)) {
 8000c3e:	f107 0307 	add.w	r3, r7, #7
 8000c42:	4811      	ldr	r0, [pc, #68]	; (8000c88 <USART1_IRQHandler+0x9c>)
 8000c44:	4619      	mov	r1, r3
 8000c46:	f7ff ff63 	bl	8000b10 <rb_getc>
 8000c4a:	4603      	mov	r3, r0
 8000c4c:	2b00      	cmp	r3, #0
 8000c4e:	d003      	beq.n	8000c58 <USART1_IRQHandler+0x6c>
            // send a queued byte
            //
            USART1->DR = c;
 8000c50:	4b0a      	ldr	r3, [pc, #40]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000c52:	79fa      	ldrb	r2, [r7, #7]
 8000c54:	809a      	strh	r2, [r3, #4]
 8000c56:	e007      	b.n	8000c68 <USART1_IRQHandler+0x7c>
        }
        else {
            // nothing to send, disable interrupt
            //
            USART1->CR1 &= ~USART_CR1_TXEIE;
 8000c58:	4b08      	ldr	r3, [pc, #32]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000c5a:	4a08      	ldr	r2, [pc, #32]	; (8000c7c <USART1_IRQHandler+0x90>)
 8000c5c:	8992      	ldrh	r2, [r2, #12]
 8000c5e:	b292      	uxth	r2, r2
 8000c60:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000c64:	b292      	uxth	r2, r2
 8000c66:	819a      	strh	r2, [r3, #12]
        }
        uart_stats.tx_bytes++;
 8000c68:	4b06      	ldr	r3, [pc, #24]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c6a:	689b      	ldr	r3, [r3, #8]
 8000c6c:	f103 0201 	add.w	r2, r3, #1
 8000c70:	4b04      	ldr	r3, [pc, #16]	; (8000c84 <USART1_IRQHandler+0x98>)
 8000c72:	609a      	str	r2, [r3, #8]
    }
}
 8000c74:	f107 0708 	add.w	r7, r7, #8
 8000c78:	46bd      	mov	sp, r7
 8000c7a:	bd80      	pop	{r7, pc}
 8000c7c:	40011000 	.word	0x40011000
 8000c80:	20000504 	.word	0x20000504
 8000c84:	20000680 	.word	0x20000680
 8000c88:	20000514 	.word	0x20000514

08000c8c <get_us_time>:
 *   this function must be called at least
 *   once every 65ms to work correctly.
 *
 */
uint64_t get_us_time()
{
 8000c8c:	b580      	push	{r7, lr}
 8000c8e:	b082      	sub	sp, #8
 8000c90:	af00      	add	r7, sp, #0
    static uint16_t t0;
    static uint64_t tickcount;

    vPortEnterCritical();
 8000c92:	f000 ff6f 	bl	8001b74 <vPortEnterCritical>

    int t = TIM7->CNT;
 8000c96:	4b16      	ldr	r3, [pc, #88]	; (8000cf0 <get_us_time+0x64>)
 8000c98:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000c9a:	607b      	str	r3, [r7, #4]
    if (t < t0)
 8000c9c:	4b15      	ldr	r3, [pc, #84]	; (8000cf4 <get_us_time+0x68>)
 8000c9e:	881b      	ldrh	r3, [r3, #0]
 8000ca0:	461a      	mov	r2, r3
 8000ca2:	687b      	ldr	r3, [r7, #4]
 8000ca4:	429a      	cmp	r2, r3
 8000ca6:	dd03      	ble.n	8000cb0 <get_us_time+0x24>
        t += 0x10000;
 8000ca8:	687b      	ldr	r3, [r7, #4]
 8000caa:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8000cae:	607b      	str	r3, [r7, #4]

    tickcount += t - t0;
 8000cb0:	4b10      	ldr	r3, [pc, #64]	; (8000cf4 <get_us_time+0x68>)
 8000cb2:	881b      	ldrh	r3, [r3, #0]
 8000cb4:	687a      	ldr	r2, [r7, #4]
 8000cb6:	1ad3      	subs	r3, r2, r3
 8000cb8:	4618      	mov	r0, r3
 8000cba:	ea4f 71e3 	mov.w	r1, r3, asr #31
 8000cbe:	4b0e      	ldr	r3, [pc, #56]	; (8000cf8 <get_us_time+0x6c>)
 8000cc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000cc4:	1812      	adds	r2, r2, r0
 8000cc6:	eb43 0301 	adc.w	r3, r3, r1
 8000cca:	490b      	ldr	r1, [pc, #44]	; (8000cf8 <get_us_time+0x6c>)
 8000ccc:	e9c1 2300 	strd	r2, r3, [r1]
    t0 = t;
 8000cd0:	687b      	ldr	r3, [r7, #4]
 8000cd2:	b29a      	uxth	r2, r3
 8000cd4:	4b07      	ldr	r3, [pc, #28]	; (8000cf4 <get_us_time+0x68>)
 8000cd6:	801a      	strh	r2, [r3, #0]

    vPortExitCritical();
 8000cd8:	f000 ff5e 	bl	8001b98 <vPortExitCritical>

    return tickcount;
 8000cdc:	4b06      	ldr	r3, [pc, #24]	; (8000cf8 <get_us_time+0x6c>)
 8000cde:	e9d3 2300 	ldrd	r2, r3, [r3]
}
 8000ce2:	4610      	mov	r0, r2
 8000ce4:	4619      	mov	r1, r3
 8000ce6:	f107 0708 	add.w	r7, r7, #8
 8000cea:	46bd      	mov	sp, r7
 8000cec:	bd80      	pop	{r7, pc}
 8000cee:	bf00      	nop
 8000cf0:	40001400 	.word	0x40001400
 8000cf4:	2000068c 	.word	0x2000068c
 8000cf8:	20000690 	.word	0x20000690

08000cfc <init_us_timer>:
/**
 * Set up TIM7 as a 16bit, microsecond-timer.
 *
 */
void init_us_timer()
{
 8000cfc:	b580      	push	{r7, lr}
 8000cfe:	b084      	sub	sp, #16
 8000d00:	af00      	add	r7, sp, #0
    RCC_ClocksTypeDef RCC_Clocks;
    RCC_GetClocksFreq(&RCC_Clocks);
 8000d02:	463b      	mov	r3, r7
 8000d04:	4618      	mov	r0, r3
 8000d06:	f001 fa8b 	bl	8002220 <RCC_GetClocksFreq>

    RCC->APB1ENR |= RCC_APB1Periph_TIM7;
 8000d0a:	4b0f      	ldr	r3, [pc, #60]	; (8000d48 <init_us_timer+0x4c>)
 8000d0c:	4a0e      	ldr	r2, [pc, #56]	; (8000d48 <init_us_timer+0x4c>)
 8000d0e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000d10:	f042 0220 	orr.w	r2, r2, #32
 8000d14:	641a      	str	r2, [r3, #64]	; 0x40
    TIM7->PSC = (RCC_Clocks.PCLK2_Frequency / 1000000) - 1;
 8000d16:	4b0d      	ldr	r3, [pc, #52]	; (8000d4c <init_us_timer+0x50>)
 8000d18:	68f9      	ldr	r1, [r7, #12]
 8000d1a:	4a0d      	ldr	r2, [pc, #52]	; (8000d50 <init_us_timer+0x54>)
 8000d1c:	fba2 0201 	umull	r0, r2, r2, r1
 8000d20:	ea4f 4292 	mov.w	r2, r2, lsr #18
 8000d24:	b292      	uxth	r2, r2
 8000d26:	f102 32ff 	add.w	r2, r2, #4294967295
 8000d2a:	b292      	uxth	r2, r2
 8000d2c:	851a      	strh	r2, [r3, #40]	; 0x28
    TIM7->ARR = 0xFFFF;
 8000d2e:	4b07      	ldr	r3, [pc, #28]	; (8000d4c <init_us_timer+0x50>)
 8000d30:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000d34:	62da      	str	r2, [r3, #44]	; 0x2c
    TIM7->CR1 = TIM_CR1_CEN;
 8000d36:	4b05      	ldr	r3, [pc, #20]	; (8000d4c <init_us_timer+0x50>)
 8000d38:	f04f 0201 	mov.w	r2, #1
 8000d3c:	801a      	strh	r2, [r3, #0]
}
 8000d3e:	f107 0710 	add.w	r7, r7, #16
 8000d42:	46bd      	mov	sp, r7
 8000d44:	bd80      	pop	{r7, pc}
 8000d46:	bf00      	nop
 8000d48:	40023800 	.word	0x40023800
 8000d4c:	40001400 	.word	0x40001400
 8000d50:	431bde83 	.word	0x431bde83

08000d54 <AdcTask>:
//Decalare variables to capture ADC conversion,convert to required voltage level and store it
uint32_t adcValue=0;
uint32_t adcVoltage=0;

//Task to handle ADC conversion
static void AdcTask(void *pvParameters){
 8000d54:	b580      	push	{r7, lr}
 8000d56:	b082      	sub	sp, #8
 8000d58:	af00      	add	r7, sp, #0
 8000d5a:	6078      	str	r0, [r7, #4]

      	//ADC1 regular channel16 configuration
        ADC_RegularChannelConfig(ADC1, ADC_Channel_16, 1, ADC_SampleTime_3Cycles);
 8000d5c:	4819      	ldr	r0, [pc, #100]	; (8000dc4 <AdcTask+0x70>)
 8000d5e:	f04f 0110 	mov.w	r1, #16
 8000d62:	f04f 0201 	mov.w	r2, #1
 8000d66:	f04f 0300 	mov.w	r3, #0
 8000d6a:	f001 f859 	bl	8001e20 <ADC_RegularChannelConfig>

	while(1){

		//Start ADC1 Conversion
		ADC_SoftwareStartConv(ADC1);
 8000d6e:	4815      	ldr	r0, [pc, #84]	; (8000dc4 <AdcTask+0x70>)
 8000d70:	f001 f93e 	bl	8001ff0 <ADC_SoftwareStartConv>

		//NOTE :: Make sure that decimals value is being multipied with adcValue
		adcValue= ADC_GetConversionValue(ADC1);
 8000d74:	4813      	ldr	r0, [pc, #76]	; (8000dc4 <AdcTask+0x70>)
 8000d76:	f001 f94b 	bl	8002010 <ADC_GetConversionValue>
 8000d7a:	4603      	mov	r3, r0
 8000d7c:	461a      	mov	r2, r3
 8000d7e:	4b12      	ldr	r3, [pc, #72]	; (8000dc8 <AdcTask+0x74>)
 8000d80:	601a      	str	r2, [r3, #0]
		adcVoltage = adcValue * (5.0/4096.0);
 8000d82:	4b11      	ldr	r3, [pc, #68]	; (8000dc8 <AdcTask+0x74>)
 8000d84:	681b      	ldr	r3, [r3, #0]
 8000d86:	ee07 3a90 	vmov	s15, r3
 8000d8a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8000d8e:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8000dce <AdcTask+0x7a>
 8000d92:	ee67 7a27 	vmul.f32	s15, s14, s15
 8000d96:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8000d9a:	ee17 2a90 	vmov	r2, s15
 8000d9e:	4b0c      	ldr	r3, [pc, #48]	; (8000dd0 <AdcTask+0x7c>)
 8000da0:	601a      	str	r2, [r3, #0]

		//Wait Until Transmit Finishes
	        while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
 8000da2:	bf00      	nop
 8000da4:	480b      	ldr	r0, [pc, #44]	; (8000dd4 <AdcTask+0x80>)
 8000da6:	f04f 0180 	mov.w	r1, #128	; 0x80
 8000daa:	f001 fc65 	bl	8002678 <USART_GetFlagStatus>
 8000dae:	4603      	mov	r3, r0
 8000db0:	2b00      	cmp	r3, #0
 8000db2:	d0f7      	beq.n	8000da4 <AdcTask+0x50>
		//Send the data to USART2
			USART_SendData(USART2,adcVoltage);
 8000db4:	4b06      	ldr	r3, [pc, #24]	; (8000dd0 <AdcTask+0x7c>)
 8000db6:	681b      	ldr	r3, [r3, #0]
 8000db8:	b29b      	uxth	r3, r3
 8000dba:	4806      	ldr	r0, [pc, #24]	; (8000dd4 <AdcTask+0x80>)
 8000dbc:	4619      	mov	r1, r3
 8000dbe:	f001 fc47 	bl	8002650 <USART_SendData>

	}
 8000dc2:	e7d4      	b.n	8000d6e <AdcTask+0x1a>
 8000dc4:	40012000 	.word	0x40012000
 8000dc8:	20000698 	.word	0x20000698
 8000dcc:	3aa00000 	.word	0x3aa00000
 8000dd0:	2000069c 	.word	0x2000069c
 8000dd4:	40004400 	.word	0x40004400

08000dd8 <initx>:

}

//Initialise required ADC1, USART2 & GPIOS
void initx(void){
 8000dd8:	b580      	push	{r7, lr}
 8000dda:	b090      	sub	sp, #64	; 0x40
 8000ddc:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	
	
       	//Enable ADC1 
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 8000dde:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000de2:	f04f 0101 	mov.w	r1, #1
 8000de6:	f001 fb1d 	bl	8002424 <RCC_APB2PeriphClockCmd>

	//Enable the ADC1 GPIO Clock	
      	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 
 8000dea:	f04f 0001 	mov.w	r0, #1
 8000dee:	f04f 0101 	mov.w	r1, #1
 8000df2:	f001 fad3 	bl	800239c <RCC_AHB1PeriphClockCmd>

	//Initializing GPIO for ADC
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8000df6:	f04f 0320 	mov.w	r3, #32
 8000dfa:	623b      	str	r3, [r7, #32]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8000dfc:	f04f 0303 	mov.w	r3, #3
 8000e00:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000e04:	f04f 0300 	mov.w	r3, #0
 8000e08:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000e0c:	f04f 0303 	mov.w	r3, #3
 8000e10:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000e14:	f04f 0300 	mov.w	r3, #0
 8000e18:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	//Initializing GPIO 
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8000e1c:	f107 0320 	add.w	r3, r7, #32
 8000e20:	4842      	ldr	r0, [pc, #264]	; (8000f2c <initx+0x154>)
 8000e22:	4619      	mov	r1, r3
 8000e24:	f001 f902 	bl	800202c <GPIO_Init>

	//ADC Common Init

	//Use Independent mode
	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
 8000e28:	f04f 0300 	mov.w	r3, #0
 8000e2c:	613b      	str	r3, [r7, #16]
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 8000e2e:	f04f 0300 	mov.w	r3, #0
 8000e32:	617b      	str	r3, [r7, #20]
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8000e34:	f04f 0300 	mov.w	r3, #0
 8000e38:	61bb      	str	r3, [r7, #24]
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 8000e3a:	f04f 0300 	mov.w	r3, #0
 8000e3e:	61fb      	str	r3, [r7, #28]
	ADC_CommonInit(&ADC_CommonInitStructure);
 8000e40:	f107 0310 	add.w	r3, r7, #16
 8000e44:	4618      	mov	r0, r3
 8000e46:	f000 ff87 	bl	8001d58 <ADC_CommonInit>

	//ADC1 Init
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 8000e4a:	f04f 0300 	mov.w	r3, #0
 8000e4e:	62bb      	str	r3, [r7, #40]	; 0x28
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 8000e50:	f04f 0300 	mov.w	r3, #0
 8000e54:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 8000e58:	f04f 0300 	mov.w	r3, #0
 8000e5c:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8000e60:	f04f 0300 	mov.w	r3, #0
 8000e64:	633b      	str	r3, [r7, #48]	; 0x30
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8000e66:	f04f 0300 	mov.w	r3, #0
 8000e6a:	63bb      	str	r3, [r7, #56]	; 0x38
	ADC_InitStructure.ADC_NbrOfConversion = 1;
 8000e6c:	f04f 0301 	mov.w	r3, #1
 8000e70:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
	ADC_Init(ADC1, &ADC_InitStructure);
 8000e74:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8000e78:	482d      	ldr	r0, [pc, #180]	; (8000f30 <initx+0x158>)
 8000e7a:	4619      	mov	r1, r3
 8000e7c:	f000 ff0a 	bl	8001c94 <ADC_Init>

	//Enabling Temperature sensor
	ADC_TempSensorVrefintCmd(ENABLE);
 8000e80:	f04f 0001 	mov.w	r0, #1
 8000e84:	f000 ffb0 	bl	8001de8 <ADC_TempSensorVrefintCmd>

	//Enable ADC1
	ADC_Cmd(ADC1, ENABLE);
 8000e88:	4829      	ldr	r0, [pc, #164]	; (8000f30 <initx+0x158>)
 8000e8a:	f04f 0101 	mov.w	r1, #1
 8000e8e:	f000 ff8f 	bl	8001db0 <ADC_Cmd>

	//Structure With Data For USART Configuration
	USART_InitTypeDef USART_InitStructure;

	//Setup USART2 TX Pin As Alternate Function
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
 8000e92:	4828      	ldr	r0, [pc, #160]	; (8000f34 <initx+0x15c>)
 8000e94:	f04f 0102 	mov.w	r1, #2
 8000e98:	f04f 0207 	mov.w	r2, #7
 8000e9c:	f001 f96a 	bl	8002174 <GPIO_PinAFConfig>
        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8000ea0:	f04f 0304 	mov.w	r3, #4
 8000ea4:	623b      	str	r3, [r7, #32]
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8000ea6:	f04f 0302 	mov.w	r3, #2
 8000eaa:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000eae:	f04f 0300 	mov.w	r3, #0
 8000eb2:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8000eb6:	f04f 0301 	mov.w	r3, #1
 8000eba:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000ebe:	f04f 0302 	mov.w	r3, #2
 8000ec2:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000ec6:	f107 0320 	add.w	r3, r7, #32
 8000eca:	481a      	ldr	r0, [pc, #104]	; (8000f34 <initx+0x15c>)
 8000ecc:	4619      	mov	r1, r3
 8000ece:	f001 f8ad 	bl	800202c <GPIO_Init>

	//Enable GPIO Clocks For USART2
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8000ed2:	f04f 0001 	mov.w	r0, #1
 8000ed6:	f04f 0101 	mov.w	r1, #1
 8000eda:	f001 fa5f 	bl	800239c <RCC_AHB1PeriphClockCmd>

	//Enable Clocks for USART2
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 8000ede:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8000ee2:	f04f 0101 	mov.w	r1, #1
 8000ee6:	f001 fa7b 	bl	80023e0 <RCC_APB1PeriphClockCmd>

	//USART Parameters
	USART_InitStructure.USART_BaudRate = 38400;
 8000eea:	f44f 4316 	mov.w	r3, #38400	; 0x9600
 8000eee:	603b      	str	r3, [r7, #0]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8000ef0:	f04f 0300 	mov.w	r3, #0
 8000ef4:	80bb      	strh	r3, [r7, #4]
        USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8000ef6:	f04f 0300 	mov.w	r3, #0
 8000efa:	80fb      	strh	r3, [r7, #6]
        USART_InitStructure.USART_Parity = USART_Parity_No ;
 8000efc:	f04f 0300 	mov.w	r3, #0
 8000f00:	813b      	strh	r3, [r7, #8]
        USART_InitStructure.USART_Mode = USART_Mode_Tx;
 8000f02:	f04f 0308 	mov.w	r3, #8
 8000f06:	817b      	strh	r3, [r7, #10]
        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8000f08:	f04f 0300 	mov.w	r3, #0
 8000f0c:	81bb      	strh	r3, [r7, #12]

	//Configuring And Enabling USART2
	USART_Init(USART2,&USART_InitStructure);
 8000f0e:	463b      	mov	r3, r7
 8000f10:	4809      	ldr	r0, [pc, #36]	; (8000f38 <initx+0x160>)
 8000f12:	4619      	mov	r1, r3
 8000f14:	f001 faa8 	bl	8002468 <USART_Init>
        USART_Cmd(USART2, ENABLE);
 8000f18:	4807      	ldr	r0, [pc, #28]	; (8000f38 <initx+0x160>)
 8000f1a:	f04f 0101 	mov.w	r1, #1
 8000f1e:	f001 fb77 	bl	8002610 <USART_Cmd>

	//Comment out below line if you need full FPU support	
	//SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2)); 

}
 8000f22:	f107 0740 	add.w	r7, r7, #64	; 0x40
 8000f26:	46bd      	mov	sp, r7
 8000f28:	bd80      	pop	{r7, pc}
 8000f2a:	bf00      	nop
 8000f2c:	40020800 	.word	0x40020800
 8000f30:	40012000 	.word	0x40012000
 8000f34:	40020000 	.word	0x40020000
 8000f38:	40004400 	.word	0x40004400

08000f3c <main>:

int main(void){
 8000f3c:	b580      	push	{r7, lr}
 8000f3e:	b084      	sub	sp, #16
 8000f40:	af04      	add	r7, sp, #16

	//Call initialize
	initx();
 8000f42:	f7ff ff49 	bl	8000dd8 <initx>
	
	//AdcTask to capture data from Temperature Sensor and convert to Digital
	xTaskCreate(AdcTask, (signed char*)"AdcTask", 128, NULL, tskIDLE_PRIORITY+1, NULL);
 8000f46:	4b0e      	ldr	r3, [pc, #56]	; (8000f80 <main+0x44>)
 8000f48:	f04f 0201 	mov.w	r2, #1
 8000f4c:	9200      	str	r2, [sp, #0]
 8000f4e:	f04f 0200 	mov.w	r2, #0
 8000f52:	9201      	str	r2, [sp, #4]
 8000f54:	f04f 0200 	mov.w	r2, #0
 8000f58:	9202      	str	r2, [sp, #8]
 8000f5a:	f04f 0200 	mov.w	r2, #0
 8000f5e:	9203      	str	r2, [sp, #12]
 8000f60:	4808      	ldr	r0, [pc, #32]	; (8000f84 <main+0x48>)
 8000f62:	4619      	mov	r1, r3
 8000f64:	f04f 0280 	mov.w	r2, #128	; 0x80
 8000f68:	f04f 0300 	mov.w	r3, #0
 8000f6c:	f000 f94a 	bl	8001204 <xTaskGenericCreate>

	//Give control scheduler
	vTaskStartScheduler();
 8000f70:	f000 f9f8 	bl	8001364 <vTaskStartScheduler>
 8000f74:	f04f 0300 	mov.w	r3, #0

}
 8000f78:	4618      	mov	r0, r3
 8000f7a:	46bd      	mov	sp, r7
 8000f7c:	bd80      	pop	{r7, pc}
 8000f7e:	bf00      	nop
 8000f80:	080026b8 	.word	0x080026b8
 8000f84:	08000d55 	.word	0x08000d55

08000f88 <Reset_Handler>:
 8000f88:	2100      	movs	r1, #0
 8000f8a:	e003      	b.n	8000f94 <LoopCopyDataInit>

08000f8c <CopyDataInit>:
 8000f8c:	4b0e      	ldr	r3, [pc, #56]	; (8000fc8 <LoopFillZerobss+0x20>)
 8000f8e:	585b      	ldr	r3, [r3, r1]
 8000f90:	5043      	str	r3, [r0, r1]
 8000f92:	3104      	adds	r1, #4

08000f94 <LoopCopyDataInit>:
 8000f94:	480d      	ldr	r0, [pc, #52]	; (8000fcc <LoopFillZerobss+0x24>)
 8000f96:	4b0e      	ldr	r3, [pc, #56]	; (8000fd0 <LoopFillZerobss+0x28>)
 8000f98:	1842      	adds	r2, r0, r1
 8000f9a:	429a      	cmp	r2, r3
 8000f9c:	d3f6      	bcc.n	8000f8c <CopyDataInit>
 8000f9e:	4a0d      	ldr	r2, [pc, #52]	; (8000fd4 <LoopFillZerobss+0x2c>)
 8000fa0:	e002      	b.n	8000fa8 <LoopFillZerobss>

08000fa2 <FillZerobss>:
 8000fa2:	2300      	movs	r3, #0
 8000fa4:	f842 3b04 	str.w	r3, [r2], #4

08000fa8 <LoopFillZerobss>:
 8000fa8:	4b0b      	ldr	r3, [pc, #44]	; (8000fd8 <LoopFillZerobss+0x30>)
 8000faa:	429a      	cmp	r2, r3
 8000fac:	d3f9      	bcc.n	8000fa2 <FillZerobss>
 8000fae:	480b      	ldr	r0, [pc, #44]	; (8000fdc <LoopFillZerobss+0x34>)
 8000fb0:	6801      	ldr	r1, [r0, #0]
 8000fb2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000fb6:	6001      	str	r1, [r0, #0]
 8000fb8:	f000 f814 	bl	8000fe4 <SystemInit>
 8000fbc:	f7ff f8fc 	bl	80001b8 <__libc_init_array>
 8000fc0:	f7ff ffbc 	bl	8000f3c <main>
 8000fc4:	4770      	bx	lr
 8000fc6:	0000      	.short	0x0000
 8000fc8:	08002758 	.word	0x08002758
 8000fcc:	20000000 	.word	0x20000000
 8000fd0:	20000544 	.word	0x20000544
 8000fd4:	20000548 	.word	0x20000548
 8000fd8:	200007ac 	.word	0x200007ac
 8000fdc:	e000ed88 	.word	0xe000ed88

08000fe0 <ADC_IRQHandler>:
 8000fe0:	e7fe      	b.n	8000fe0 <ADC_IRQHandler>
 8000fe2:	0000      	movs	r0, r0

08000fe4 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000fe4:	b580      	push	{r7, lr}
 8000fe6:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000fe8:	4b12      	ldr	r3, [pc, #72]	; (8001034 <SystemInit+0x50>)
 8000fea:	4a12      	ldr	r2, [pc, #72]	; (8001034 <SystemInit+0x50>)
 8000fec:	6812      	ldr	r2, [r2, #0]
 8000fee:	f042 0201 	orr.w	r2, r2, #1
 8000ff2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8000ff4:	4b0f      	ldr	r3, [pc, #60]	; (8001034 <SystemInit+0x50>)
 8000ff6:	f04f 0200 	mov.w	r2, #0
 8000ffa:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8000ffc:	4a0d      	ldr	r2, [pc, #52]	; (8001034 <SystemInit+0x50>)
 8000ffe:	4b0d      	ldr	r3, [pc, #52]	; (8001034 <SystemInit+0x50>)
 8001000:	681b      	ldr	r3, [r3, #0]
 8001002:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 8001006:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800100a:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800100c:	4b09      	ldr	r3, [pc, #36]	; (8001034 <SystemInit+0x50>)
 800100e:	4a0a      	ldr	r2, [pc, #40]	; (8001038 <SystemInit+0x54>)
 8001010:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8001012:	4b08      	ldr	r3, [pc, #32]	; (8001034 <SystemInit+0x50>)
 8001014:	4a07      	ldr	r2, [pc, #28]	; (8001034 <SystemInit+0x50>)
 8001016:	6812      	ldr	r2, [r2, #0]
 8001018:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800101c:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800101e:	4b05      	ldr	r3, [pc, #20]	; (8001034 <SystemInit+0x50>)
 8001020:	f04f 0200 	mov.w	r2, #0
 8001024:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8001026:	f000 f80b 	bl	8001040 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800102a:	4b04      	ldr	r3, [pc, #16]	; (800103c <SystemInit+0x58>)
 800102c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001030:	609a      	str	r2, [r3, #8]
#endif
}
 8001032:	bd80      	pop	{r7, pc}
 8001034:	40023800 	.word	0x40023800
 8001038:	24003010 	.word	0x24003010
 800103c:	e000ed00 	.word	0xe000ed00

08001040 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8001040:	b480      	push	{r7}
 8001042:	b083      	sub	sp, #12
 8001044:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8001046:	f04f 0300 	mov.w	r3, #0
 800104a:	607b      	str	r3, [r7, #4]
 800104c:	f04f 0300 	mov.w	r3, #0
 8001050:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8001052:	4b42      	ldr	r3, [pc, #264]	; (800115c <SetSysClock+0x11c>)
 8001054:	4a41      	ldr	r2, [pc, #260]	; (800115c <SetSysClock+0x11c>)
 8001056:	6812      	ldr	r2, [r2, #0]
 8001058:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800105c:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800105e:	4b3f      	ldr	r3, [pc, #252]	; (800115c <SetSysClock+0x11c>)
 8001060:	681b      	ldr	r3, [r3, #0]
 8001062:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001066:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 8001068:	687b      	ldr	r3, [r7, #4]
 800106a:	f103 0301 	add.w	r3, r3, #1
 800106e:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8001070:	683b      	ldr	r3, [r7, #0]
 8001072:	2b00      	cmp	r3, #0
 8001074:	d103      	bne.n	800107e <SetSysClock+0x3e>
 8001076:	687b      	ldr	r3, [r7, #4]
 8001078:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800107c:	d1ef      	bne.n	800105e <SetSysClock+0x1e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800107e:	4b37      	ldr	r3, [pc, #220]	; (800115c <SetSysClock+0x11c>)
 8001080:	681b      	ldr	r3, [r3, #0]
 8001082:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001086:	2b00      	cmp	r3, #0
 8001088:	d003      	beq.n	8001092 <SetSysClock+0x52>
  {
    HSEStatus = (uint32_t)0x01;
 800108a:	f04f 0301 	mov.w	r3, #1
 800108e:	603b      	str	r3, [r7, #0]
 8001090:	e002      	b.n	8001098 <SetSysClock+0x58>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8001092:	f04f 0300 	mov.w	r3, #0
 8001096:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 8001098:	683b      	ldr	r3, [r7, #0]
 800109a:	2b01      	cmp	r3, #1
 800109c:	d142      	bne.n	8001124 <SetSysClock+0xe4>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800109e:	4b2f      	ldr	r3, [pc, #188]	; (800115c <SetSysClock+0x11c>)
 80010a0:	4a2e      	ldr	r2, [pc, #184]	; (800115c <SetSysClock+0x11c>)
 80010a2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80010a4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80010a8:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 80010aa:	4b2d      	ldr	r3, [pc, #180]	; (8001160 <SetSysClock+0x120>)
 80010ac:	4a2c      	ldr	r2, [pc, #176]	; (8001160 <SetSysClock+0x120>)
 80010ae:	6812      	ldr	r2, [r2, #0]
 80010b0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80010b4:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 80010b6:	4b29      	ldr	r3, [pc, #164]	; (800115c <SetSysClock+0x11c>)
 80010b8:	4a28      	ldr	r2, [pc, #160]	; (800115c <SetSysClock+0x11c>)
 80010ba:	6892      	ldr	r2, [r2, #8]
 80010bc:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 80010be:	4b27      	ldr	r3, [pc, #156]	; (800115c <SetSysClock+0x11c>)
 80010c0:	4a26      	ldr	r2, [pc, #152]	; (800115c <SetSysClock+0x11c>)
 80010c2:	6892      	ldr	r2, [r2, #8]
 80010c4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80010c8:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 80010ca:	4b24      	ldr	r3, [pc, #144]	; (800115c <SetSysClock+0x11c>)
 80010cc:	4a23      	ldr	r2, [pc, #140]	; (800115c <SetSysClock+0x11c>)
 80010ce:	6892      	ldr	r2, [r2, #8]
 80010d0:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 80010d4:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 80010d6:	4b21      	ldr	r3, [pc, #132]	; (800115c <SetSysClock+0x11c>)
 80010d8:	4a22      	ldr	r2, [pc, #136]	; (8001164 <SetSysClock+0x124>)
 80010da:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 80010dc:	4b1f      	ldr	r3, [pc, #124]	; (800115c <SetSysClock+0x11c>)
 80010de:	4a1f      	ldr	r2, [pc, #124]	; (800115c <SetSysClock+0x11c>)
 80010e0:	6812      	ldr	r2, [r2, #0]
 80010e2:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80010e6:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 80010e8:	bf00      	nop
 80010ea:	4b1c      	ldr	r3, [pc, #112]	; (800115c <SetSysClock+0x11c>)
 80010ec:	681b      	ldr	r3, [r3, #0]
 80010ee:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80010f2:	2b00      	cmp	r3, #0
 80010f4:	d0f9      	beq.n	80010ea <SetSysClock+0xaa>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80010f6:	4b1c      	ldr	r3, [pc, #112]	; (8001168 <SetSysClock+0x128>)
 80010f8:	f240 6205 	movw	r2, #1541	; 0x605
 80010fc:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80010fe:	4b17      	ldr	r3, [pc, #92]	; (800115c <SetSysClock+0x11c>)
 8001100:	4a16      	ldr	r2, [pc, #88]	; (800115c <SetSysClock+0x11c>)
 8001102:	6892      	ldr	r2, [r2, #8]
 8001104:	f022 0203 	bic.w	r2, r2, #3
 8001108:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 800110a:	4b14      	ldr	r3, [pc, #80]	; (800115c <SetSysClock+0x11c>)
 800110c:	4a13      	ldr	r2, [pc, #76]	; (800115c <SetSysClock+0x11c>)
 800110e:	6892      	ldr	r2, [r2, #8]
 8001110:	f042 0202 	orr.w	r2, r2, #2
 8001114:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8001116:	bf00      	nop
 8001118:	4b10      	ldr	r3, [pc, #64]	; (800115c <SetSysClock+0x11c>)
 800111a:	689b      	ldr	r3, [r3, #8]
 800111c:	f003 030c 	and.w	r3, r3, #12
 8001120:	2b08      	cmp	r3, #8
 8001122:	d1f9      	bne.n	8001118 <SetSysClock+0xd8>

/******************************************************************************/
/*                        I2S clock configuration                             */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 8001124:	4b0d      	ldr	r3, [pc, #52]	; (800115c <SetSysClock+0x11c>)
 8001126:	4a0d      	ldr	r2, [pc, #52]	; (800115c <SetSysClock+0x11c>)
 8001128:	6892      	ldr	r2, [r2, #8]
 800112a:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 800112e:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 8001130:	4b0a      	ldr	r3, [pc, #40]	; (800115c <SetSysClock+0x11c>)
 8001132:	4a0e      	ldr	r2, [pc, #56]	; (800116c <SetSysClock+0x12c>)
 8001134:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 8001138:	4b08      	ldr	r3, [pc, #32]	; (800115c <SetSysClock+0x11c>)
 800113a:	4a08      	ldr	r2, [pc, #32]	; (800115c <SetSysClock+0x11c>)
 800113c:	6812      	ldr	r2, [r2, #0]
 800113e:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001142:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 8001144:	bf00      	nop
 8001146:	4b05      	ldr	r3, [pc, #20]	; (800115c <SetSysClock+0x11c>)
 8001148:	681b      	ldr	r3, [r3, #0]
 800114a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800114e:	2b00      	cmp	r3, #0
 8001150:	d0f9      	beq.n	8001146 <SetSysClock+0x106>
  {
  }
}
 8001152:	f107 070c 	add.w	r7, r7, #12
 8001156:	46bd      	mov	sp, r7
 8001158:	bc80      	pop	{r7}
 800115a:	4770      	bx	lr
 800115c:	40023800 	.word	0x40023800
 8001160:	40007000 	.word	0x40007000
 8001164:	07405408 	.word	0x07405408
 8001168:	40023c00 	.word	0x40023c00
 800116c:	50003000 	.word	0x50003000

08001170 <_sbrk_r>:
    return 1;
}


void *_sbrk_r(struct _reent *r, ptrdiff_t incr)
{
 8001170:	b490      	push	{r4, r7}
 8001172:	b084      	sub	sp, #16
 8001174:	af00      	add	r7, sp, #0
 8001176:	6078      	str	r0, [r7, #4]
 8001178:	6039      	str	r1, [r7, #0]
    extern char end;   // provided by the linker script

    if (__brkval == 0)
 800117a:	4b15      	ldr	r3, [pc, #84]	; (80011d0 <_sbrk_r+0x60>)
 800117c:	681b      	ldr	r3, [r3, #0]
 800117e:	2b00      	cmp	r3, #0
 8001180:	d102      	bne.n	8001188 <_sbrk_r+0x18>
        __brkval = &end;
 8001182:	4b13      	ldr	r3, [pc, #76]	; (80011d0 <_sbrk_r+0x60>)
 8001184:	4a13      	ldr	r2, [pc, #76]	; (80011d4 <_sbrk_r+0x64>)
 8001186:	601a      	str	r2, [r3, #0]

    if (__brkval + incr > (char*)__get_MSP() - __malloc_margin) {
 8001188:	4b11      	ldr	r3, [pc, #68]	; (80011d0 <_sbrk_r+0x60>)
 800118a:	681a      	ldr	r2, [r3, #0]
 800118c:	683b      	ldr	r3, [r7, #0]
 800118e:	18d2      	adds	r2, r2, r3
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 8001190:	f3ef 8408 	mrs	r4, MSP
  return(result);
 8001194:	4623      	mov	r3, r4
 8001196:	4619      	mov	r1, r3
 8001198:	4b0f      	ldr	r3, [pc, #60]	; (80011d8 <_sbrk_r+0x68>)
 800119a:	681b      	ldr	r3, [r3, #0]
 800119c:	1acb      	subs	r3, r1, r3
 800119e:	429a      	cmp	r2, r3
 80011a0:	d906      	bls.n	80011b0 <_sbrk_r+0x40>
        r->_errno = ENOMEM;
 80011a2:	687b      	ldr	r3, [r7, #4]
 80011a4:	f04f 020c 	mov.w	r2, #12
 80011a8:	601a      	str	r2, [r3, #0]
        return (void*)-1;
 80011aa:	f04f 33ff 	mov.w	r3, #4294967295
 80011ae:	e009      	b.n	80011c4 <_sbrk_r+0x54>
    }

    void *ret = __brkval;
 80011b0:	4b07      	ldr	r3, [pc, #28]	; (80011d0 <_sbrk_r+0x60>)
 80011b2:	681b      	ldr	r3, [r3, #0]
 80011b4:	60fb      	str	r3, [r7, #12]
    __brkval += incr;
 80011b6:	4b06      	ldr	r3, [pc, #24]	; (80011d0 <_sbrk_r+0x60>)
 80011b8:	681a      	ldr	r2, [r3, #0]
 80011ba:	683b      	ldr	r3, [r7, #0]
 80011bc:	18d2      	adds	r2, r2, r3
 80011be:	4b04      	ldr	r3, [pc, #16]	; (80011d0 <_sbrk_r+0x60>)
 80011c0:	601a      	str	r2, [r3, #0]

    return ret;
 80011c2:	68fb      	ldr	r3, [r7, #12]
}
 80011c4:	4618      	mov	r0, r3
 80011c6:	f107 0710 	add.w	r7, r7, #16
 80011ca:	46bd      	mov	sp, r7
 80011cc:	bc90      	pop	{r4, r7}
 80011ce:	4770      	bx	lr
 80011d0:	200007a8 	.word	0x200007a8
 80011d4:	200007ac 	.word	0x200007ac
 80011d8:	20000528 	.word	0x20000528

080011dc <__malloc_lock>:
    return -1;
}


void __malloc_lock(struct _reent *r)
{
 80011dc:	b580      	push	{r7, lr}
 80011de:	b082      	sub	sp, #8
 80011e0:	af00      	add	r7, sp, #0
 80011e2:	6078      	str	r0, [r7, #4]
    vPortEnterCritical();
 80011e4:	f000 fcc6 	bl	8001b74 <vPortEnterCritical>
}
 80011e8:	f107 0708 	add.w	r7, r7, #8
 80011ec:	46bd      	mov	sp, r7
 80011ee:	bd80      	pop	{r7, pc}

080011f0 <__malloc_unlock>:


void __malloc_unlock(struct _reent *r)
{
 80011f0:	b580      	push	{r7, lr}
 80011f2:	b082      	sub	sp, #8
 80011f4:	af00      	add	r7, sp, #0
 80011f6:	6078      	str	r0, [r7, #4]
    vPortExitCritical();
 80011f8:	f000 fcce 	bl	8001b98 <vPortExitCritical>
}
 80011fc:	f107 0708 	add.w	r7, r7, #8
 8001200:	46bd      	mov	sp, r7
 8001202:	bd80      	pop	{r7, pc}

08001204 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8001204:	b580      	push	{r7, lr}
 8001206:	b08a      	sub	sp, #40	; 0x28
 8001208:	af02      	add	r7, sp, #8
 800120a:	60f8      	str	r0, [r7, #12]
 800120c:	60b9      	str	r1, [r7, #8]
 800120e:	603b      	str	r3, [r7, #0]
 8001210:	4613      	mov	r3, r2
 8001212:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 8001214:	88fb      	ldrh	r3, [r7, #6]
 8001216:	4618      	mov	r0, r3
 8001218:	6b39      	ldr	r1, [r7, #48]	; 0x30
 800121a:	f000 fb59 	bl	80018d0 <prvAllocateTCBAndStack>
 800121e:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 8001220:	69bb      	ldr	r3, [r7, #24]
 8001222:	2b00      	cmp	r3, #0
 8001224:	d078      	beq.n	8001318 <xTaskGenericCreate+0x114>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8001226:	69bb      	ldr	r3, [r7, #24]
 8001228:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800122a:	88fb      	ldrh	r3, [r7, #6]
 800122c:	f103 33ff 	add.w	r3, r3, #4294967295
 8001230:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001234:	18d3      	adds	r3, r2, r3
 8001236:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 8001238:	697b      	ldr	r3, [r7, #20]
 800123a:	f023 0307 	bic.w	r3, r3, #7
 800123e:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 8001240:	88fb      	ldrh	r3, [r7, #6]
 8001242:	9300      	str	r3, [sp, #0]
 8001244:	69b8      	ldr	r0, [r7, #24]
 8001246:	68b9      	ldr	r1, [r7, #8]
 8001248:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800124a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800124c:	f000 fa7a 	bl	8001744 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8001250:	6978      	ldr	r0, [r7, #20]
 8001252:	68f9      	ldr	r1, [r7, #12]
 8001254:	683a      	ldr	r2, [r7, #0]
 8001256:	f000 fc09 	bl	8001a6c <pxPortInitialiseStack>
 800125a:	4603      	mov	r3, r0
 800125c:	461a      	mov	r2, r3
 800125e:	69bb      	ldr	r3, [r7, #24]
 8001260:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 8001262:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001264:	2b00      	cmp	r3, #0
 8001266:	d002      	beq.n	800126e <xTaskGenericCreate+0x6a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8001268:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800126a:	69ba      	ldr	r2, [r7, #24]
 800126c:	601a      	str	r2, [r3, #0]
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 800126e:	f000 fc81 	bl	8001b74 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8001272:	4b35      	ldr	r3, [pc, #212]	; (8001348 <xTaskGenericCreate+0x144>)
 8001274:	681b      	ldr	r3, [r3, #0]
 8001276:	f103 0201 	add.w	r2, r3, #1
 800127a:	4b33      	ldr	r3, [pc, #204]	; (8001348 <xTaskGenericCreate+0x144>)
 800127c:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 800127e:	4b33      	ldr	r3, [pc, #204]	; (800134c <xTaskGenericCreate+0x148>)
 8001280:	681b      	ldr	r3, [r3, #0]
 8001282:	2b00      	cmp	r3, #0
 8001284:	d109      	bne.n	800129a <xTaskGenericCreate+0x96>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8001286:	4b31      	ldr	r3, [pc, #196]	; (800134c <xTaskGenericCreate+0x148>)
 8001288:	69ba      	ldr	r2, [r7, #24]
 800128a:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800128c:	4b2e      	ldr	r3, [pc, #184]	; (8001348 <xTaskGenericCreate+0x144>)
 800128e:	681b      	ldr	r3, [r3, #0]
 8001290:	2b01      	cmp	r3, #1
 8001292:	d10f      	bne.n	80012b4 <xTaskGenericCreate+0xb0>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8001294:	f000 fa9c 	bl	80017d0 <prvInitialiseTaskLists>
 8001298:	e00c      	b.n	80012b4 <xTaskGenericCreate+0xb0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800129a:	4b2d      	ldr	r3, [pc, #180]	; (8001350 <xTaskGenericCreate+0x14c>)
 800129c:	681b      	ldr	r3, [r3, #0]
 800129e:	2b00      	cmp	r3, #0
 80012a0:	d108      	bne.n	80012b4 <xTaskGenericCreate+0xb0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80012a2:	4b2a      	ldr	r3, [pc, #168]	; (800134c <xTaskGenericCreate+0x148>)
 80012a4:	681b      	ldr	r3, [r3, #0]
 80012a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80012aa:	429a      	cmp	r2, r3
 80012ac:	d802      	bhi.n	80012b4 <xTaskGenericCreate+0xb0>
					{
						pxCurrentTCB = pxNewTCB;
 80012ae:	4b27      	ldr	r3, [pc, #156]	; (800134c <xTaskGenericCreate+0x148>)
 80012b0:	69ba      	ldr	r2, [r7, #24]
 80012b2:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 80012b4:	69bb      	ldr	r3, [r7, #24]
 80012b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012b8:	4b26      	ldr	r3, [pc, #152]	; (8001354 <xTaskGenericCreate+0x150>)
 80012ba:	681b      	ldr	r3, [r3, #0]
 80012bc:	429a      	cmp	r2, r3
 80012be:	d903      	bls.n	80012c8 <xTaskGenericCreate+0xc4>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 80012c0:	69bb      	ldr	r3, [r7, #24]
 80012c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012c4:	4b23      	ldr	r3, [pc, #140]	; (8001354 <xTaskGenericCreate+0x150>)
 80012c6:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 80012c8:	4b23      	ldr	r3, [pc, #140]	; (8001358 <xTaskGenericCreate+0x154>)
 80012ca:	681b      	ldr	r3, [r3, #0]
 80012cc:	f103 0201 	add.w	r2, r3, #1
 80012d0:	4b21      	ldr	r3, [pc, #132]	; (8001358 <xTaskGenericCreate+0x154>)
 80012d2:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 80012d4:	69bb      	ldr	r3, [r7, #24]
 80012d6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012d8:	4b20      	ldr	r3, [pc, #128]	; (800135c <xTaskGenericCreate+0x158>)
 80012da:	681b      	ldr	r3, [r3, #0]
 80012dc:	429a      	cmp	r2, r3
 80012de:	d903      	bls.n	80012e8 <xTaskGenericCreate+0xe4>
 80012e0:	69bb      	ldr	r3, [r7, #24]
 80012e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012e4:	4b1d      	ldr	r3, [pc, #116]	; (800135c <xTaskGenericCreate+0x158>)
 80012e6:	601a      	str	r2, [r3, #0]
 80012e8:	69bb      	ldr	r3, [r7, #24]
 80012ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80012ec:	4613      	mov	r3, r2
 80012ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80012f2:	189b      	adds	r3, r3, r2
 80012f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80012f8:	461a      	mov	r2, r3
 80012fa:	4b19      	ldr	r3, [pc, #100]	; (8001360 <xTaskGenericCreate+0x15c>)
 80012fc:	18d2      	adds	r2, r2, r3
 80012fe:	69bb      	ldr	r3, [r7, #24]
 8001300:	f103 0304 	add.w	r3, r3, #4
 8001304:	4610      	mov	r0, r2
 8001306:	4619      	mov	r1, r3
 8001308:	f000 fb5e 	bl	80019c8 <vListInsertEnd>

			xReturn = pdPASS;
 800130c:	f04f 0301 	mov.w	r3, #1
 8001310:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8001312:	f000 fc41 	bl	8001b98 <vPortExitCritical>
 8001316:	e002      	b.n	800131e <xTaskGenericCreate+0x11a>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001318:	f04f 33ff 	mov.w	r3, #4294967295
 800131c:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 800131e:	69fb      	ldr	r3, [r7, #28]
 8001320:	2b01      	cmp	r3, #1
 8001322:	d10b      	bne.n	800133c <xTaskGenericCreate+0x138>
	{
		if( xSchedulerRunning != pdFALSE )
 8001324:	4b0a      	ldr	r3, [pc, #40]	; (8001350 <xTaskGenericCreate+0x14c>)
 8001326:	681b      	ldr	r3, [r3, #0]
 8001328:	2b00      	cmp	r3, #0
 800132a:	d007      	beq.n	800133c <xTaskGenericCreate+0x138>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800132c:	4b07      	ldr	r3, [pc, #28]	; (800134c <xTaskGenericCreate+0x148>)
 800132e:	681b      	ldr	r3, [r3, #0]
 8001330:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001332:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001334:	429a      	cmp	r2, r3
 8001336:	d201      	bcs.n	800133c <xTaskGenericCreate+0x138>
			{
				portYIELD_WITHIN_API();
 8001338:	f000 fc10 	bl	8001b5c <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 800133c:	69fb      	ldr	r3, [r7, #28]
}
 800133e:	4618      	mov	r0, r3
 8001340:	f107 0720 	add.w	r7, r7, #32
 8001344:	46bd      	mov	sp, r7
 8001346:	bd80      	pop	{r7, pc}
 8001348:	2000077c 	.word	0x2000077c
 800134c:	200006a0 	.word	0x200006a0
 8001350:	2000078c 	.word	0x2000078c
 8001354:	20000784 	.word	0x20000784
 8001358:	200007a0 	.word	0x200007a0
 800135c:	20000788 	.word	0x20000788
 8001360:	200006a4 	.word	0x200006a4

08001364 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8001364:	b580      	push	{r7, lr}
 8001366:	b086      	sub	sp, #24
 8001368:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
 800136a:	4b16      	ldr	r3, [pc, #88]	; (80013c4 <vTaskStartScheduler+0x60>)
 800136c:	f04f 0200 	mov.w	r2, #0
 8001370:	9200      	str	r2, [sp, #0]
 8001372:	4a15      	ldr	r2, [pc, #84]	; (80013c8 <vTaskStartScheduler+0x64>)
 8001374:	9201      	str	r2, [sp, #4]
 8001376:	f04f 0200 	mov.w	r2, #0
 800137a:	9202      	str	r2, [sp, #8]
 800137c:	f04f 0200 	mov.w	r2, #0
 8001380:	9203      	str	r2, [sp, #12]
 8001382:	4812      	ldr	r0, [pc, #72]	; (80013cc <vTaskStartScheduler+0x68>)
 8001384:	4619      	mov	r1, r3
 8001386:	f44f 7280 	mov.w	r2, #256	; 0x100
 800138a:	f04f 0300 	mov.w	r3, #0
 800138e:	f7ff ff39 	bl	8001204 <xTaskGenericCreate>
 8001392:	6078      	str	r0, [r7, #4]
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 8001394:	687b      	ldr	r3, [r7, #4]
 8001396:	2b01      	cmp	r3, #1
 8001398:	d10f      	bne.n	80013ba <vTaskStartScheduler+0x56>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 800139a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800139e:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 80013a2:	4b0b      	ldr	r3, [pc, #44]	; (80013d0 <vTaskStartScheduler+0x6c>)
 80013a4:	f04f 0201 	mov.w	r2, #1
 80013a8:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 80013aa:	4b0a      	ldr	r3, [pc, #40]	; (80013d4 <vTaskStartScheduler+0x70>)
 80013ac:	f04f 0200 	mov.w	r2, #0
 80013b0:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 80013b2:	f7ff fca3 	bl	8000cfc <init_us_timer>
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 80013b6:	f000 fba9 	bl	8001b0c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 80013ba:	f107 0708 	add.w	r7, r7, #8
 80013be:	46bd      	mov	sp, r7
 80013c0:	bd80      	pop	{r7, pc}
 80013c2:	bf00      	nop
 80013c4:	080026c0 	.word	0x080026c0
 80013c8:	20000778 	.word	0x20000778
 80013cc:	08001721 	.word	0x08001721
 80013d0:	2000078c 	.word	0x2000078c
 80013d4:	20000780 	.word	0x20000780

080013d8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 80013d8:	b480      	push	{r7}
 80013da:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 80013dc:	4b04      	ldr	r3, [pc, #16]	; (80013f0 <vTaskSuspendAll+0x18>)
 80013de:	681b      	ldr	r3, [r3, #0]
 80013e0:	f103 0201 	add.w	r2, r3, #1
 80013e4:	4b02      	ldr	r3, [pc, #8]	; (80013f0 <vTaskSuspendAll+0x18>)
 80013e6:	601a      	str	r2, [r3, #0]
}
 80013e8:	46bd      	mov	sp, r7
 80013ea:	bc80      	pop	{r7}
 80013ec:	4770      	bx	lr
 80013ee:	bf00      	nop
 80013f0:	20000790 	.word	0x20000790

080013f4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80013f4:	b590      	push	{r4, r7, lr}
 80013f6:	b083      	sub	sp, #12
 80013f8:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80013fa:	f04f 0300 	mov.w	r3, #0
 80013fe:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8001400:	f000 fbb8 	bl	8001b74 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8001404:	4b38      	ldr	r3, [pc, #224]	; (80014e8 <xTaskResumeAll+0xf4>)
 8001406:	681b      	ldr	r3, [r3, #0]
 8001408:	f103 32ff 	add.w	r2, r3, #4294967295
 800140c:	4b36      	ldr	r3, [pc, #216]	; (80014e8 <xTaskResumeAll+0xf4>)
 800140e:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8001410:	4b35      	ldr	r3, [pc, #212]	; (80014e8 <xTaskResumeAll+0xf4>)
 8001412:	681b      	ldr	r3, [r3, #0]
 8001414:	2b00      	cmp	r3, #0
 8001416:	d15e      	bne.n	80014d6 <xTaskResumeAll+0xe2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 8001418:	4b34      	ldr	r3, [pc, #208]	; (80014ec <xTaskResumeAll+0xf8>)
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	2b00      	cmp	r3, #0
 800141e:	d05a      	beq.n	80014d6 <xTaskResumeAll+0xe2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 8001420:	f04f 0300 	mov.w	r3, #0
 8001424:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8001426:	e02e      	b.n	8001486 <xTaskResumeAll+0x92>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 8001428:	4b31      	ldr	r3, [pc, #196]	; (80014f0 <xTaskResumeAll+0xfc>)
 800142a:	68db      	ldr	r3, [r3, #12]
 800142c:	68db      	ldr	r3, [r3, #12]
 800142e:	461c      	mov	r4, r3
					vListRemove( &( pxTCB->xEventListItem ) );
 8001430:	f104 0318 	add.w	r3, r4, #24
 8001434:	4618      	mov	r0, r3
 8001436:	f000 faef 	bl	8001a18 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 800143a:	f104 0304 	add.w	r3, r4, #4
 800143e:	4618      	mov	r0, r3
 8001440:	f000 faea 	bl	8001a18 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8001444:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001446:	4b2b      	ldr	r3, [pc, #172]	; (80014f4 <xTaskResumeAll+0x100>)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	429a      	cmp	r2, r3
 800144c:	d902      	bls.n	8001454 <xTaskResumeAll+0x60>
 800144e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001450:	4b28      	ldr	r3, [pc, #160]	; (80014f4 <xTaskResumeAll+0x100>)
 8001452:	601a      	str	r2, [r3, #0]
 8001454:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001456:	4613      	mov	r3, r2
 8001458:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800145c:	189b      	adds	r3, r3, r2
 800145e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001462:	461a      	mov	r2, r3
 8001464:	4b24      	ldr	r3, [pc, #144]	; (80014f8 <xTaskResumeAll+0x104>)
 8001466:	18d2      	adds	r2, r2, r3
 8001468:	f104 0304 	add.w	r3, r4, #4
 800146c:	4610      	mov	r0, r2
 800146e:	4619      	mov	r1, r3
 8001470:	f000 faaa 	bl	80019c8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001474:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001476:	4b21      	ldr	r3, [pc, #132]	; (80014fc <xTaskResumeAll+0x108>)
 8001478:	681b      	ldr	r3, [r3, #0]
 800147a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800147c:	429a      	cmp	r2, r3
 800147e:	d302      	bcc.n	8001486 <xTaskResumeAll+0x92>
					{
						xYieldRequired = pdTRUE;
 8001480:	f04f 0301 	mov.w	r3, #1
 8001484:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8001486:	4b1a      	ldr	r3, [pc, #104]	; (80014f0 <xTaskResumeAll+0xfc>)
 8001488:	681b      	ldr	r3, [r3, #0]
 800148a:	2b00      	cmp	r3, #0
 800148c:	d1cc      	bne.n	8001428 <xTaskResumeAll+0x34>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800148e:	4b1c      	ldr	r3, [pc, #112]	; (8001500 <xTaskResumeAll+0x10c>)
 8001490:	681b      	ldr	r3, [r3, #0]
 8001492:	2b00      	cmp	r3, #0
 8001494:	d00f      	beq.n	80014b6 <xTaskResumeAll+0xc2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8001496:	e007      	b.n	80014a8 <xTaskResumeAll+0xb4>
					{
						vTaskIncrementTick();
 8001498:	f000 f836 	bl	8001508 <vTaskIncrementTick>
						--uxMissedTicks;
 800149c:	4b18      	ldr	r3, [pc, #96]	; (8001500 <xTaskResumeAll+0x10c>)
 800149e:	681b      	ldr	r3, [r3, #0]
 80014a0:	f103 32ff 	add.w	r2, r3, #4294967295
 80014a4:	4b16      	ldr	r3, [pc, #88]	; (8001500 <xTaskResumeAll+0x10c>)
 80014a6:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 80014a8:	4b15      	ldr	r3, [pc, #84]	; (8001500 <xTaskResumeAll+0x10c>)
 80014aa:	681b      	ldr	r3, [r3, #0]
 80014ac:	2b00      	cmp	r3, #0
 80014ae:	d1f3      	bne.n	8001498 <xTaskResumeAll+0xa4>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 80014b0:	f04f 0301 	mov.w	r3, #1
 80014b4:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80014b6:	683b      	ldr	r3, [r7, #0]
 80014b8:	2b01      	cmp	r3, #1
 80014ba:	d003      	beq.n	80014c4 <xTaskResumeAll+0xd0>
 80014bc:	4b11      	ldr	r3, [pc, #68]	; (8001504 <xTaskResumeAll+0x110>)
 80014be:	681b      	ldr	r3, [r3, #0]
 80014c0:	2b01      	cmp	r3, #1
 80014c2:	d108      	bne.n	80014d6 <xTaskResumeAll+0xe2>
				{
					xAlreadyYielded = pdTRUE;
 80014c4:	f04f 0301 	mov.w	r3, #1
 80014c8:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 80014ca:	4b0e      	ldr	r3, [pc, #56]	; (8001504 <xTaskResumeAll+0x110>)
 80014cc:	f04f 0200 	mov.w	r2, #0
 80014d0:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 80014d2:	f000 fb43 	bl	8001b5c <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 80014d6:	f000 fb5f 	bl	8001b98 <vPortExitCritical>

	return xAlreadyYielded;
 80014da:	687b      	ldr	r3, [r7, #4]
}
 80014dc:	4618      	mov	r0, r3
 80014de:	f107 070c 	add.w	r7, r7, #12
 80014e2:	46bd      	mov	sp, r7
 80014e4:	bd90      	pop	{r4, r7, pc}
 80014e6:	bf00      	nop
 80014e8:	20000790 	.word	0x20000790
 80014ec:	2000077c 	.word	0x2000077c
 80014f0:	20000738 	.word	0x20000738
 80014f4:	20000788 	.word	0x20000788
 80014f8:	200006a4 	.word	0x200006a4
 80014fc:	200006a0 	.word	0x200006a0
 8001500:	20000794 	.word	0x20000794
 8001504:	20000798 	.word	0x20000798

08001508 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 8001508:	b580      	push	{r7, lr}
 800150a:	b084      	sub	sp, #16
 800150c:	af00      	add	r7, sp, #0
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800150e:	4b44      	ldr	r3, [pc, #272]	; (8001620 <vTaskIncrementTick+0x118>)
 8001510:	681b      	ldr	r3, [r3, #0]
 8001512:	2b00      	cmp	r3, #0
 8001514:	d17a      	bne.n	800160c <vTaskIncrementTick+0x104>
	{
		++xTickCount;
 8001516:	4b43      	ldr	r3, [pc, #268]	; (8001624 <vTaskIncrementTick+0x11c>)
 8001518:	681b      	ldr	r3, [r3, #0]
 800151a:	f103 0201 	add.w	r2, r3, #1
 800151e:	4b41      	ldr	r3, [pc, #260]	; (8001624 <vTaskIncrementTick+0x11c>)
 8001520:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
 8001522:	4b40      	ldr	r3, [pc, #256]	; (8001624 <vTaskIncrementTick+0x11c>)
 8001524:	681b      	ldr	r3, [r3, #0]
 8001526:	2b00      	cmp	r3, #0
 8001528:	d122      	bne.n	8001570 <vTaskIncrementTick+0x68>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 800152a:	4b3f      	ldr	r3, [pc, #252]	; (8001628 <vTaskIncrementTick+0x120>)
 800152c:	681b      	ldr	r3, [r3, #0]
 800152e:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8001530:	4b3e      	ldr	r3, [pc, #248]	; (800162c <vTaskIncrementTick+0x124>)
 8001532:	681a      	ldr	r2, [r3, #0]
 8001534:	4b3c      	ldr	r3, [pc, #240]	; (8001628 <vTaskIncrementTick+0x120>)
 8001536:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8001538:	4b3c      	ldr	r3, [pc, #240]	; (800162c <vTaskIncrementTick+0x124>)
 800153a:	68fa      	ldr	r2, [r7, #12]
 800153c:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 800153e:	4b3c      	ldr	r3, [pc, #240]	; (8001630 <vTaskIncrementTick+0x128>)
 8001540:	681b      	ldr	r3, [r3, #0]
 8001542:	f103 0201 	add.w	r2, r3, #1
 8001546:	4b3a      	ldr	r3, [pc, #232]	; (8001630 <vTaskIncrementTick+0x128>)
 8001548:	601a      	str	r2, [r3, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800154a:	4b37      	ldr	r3, [pc, #220]	; (8001628 <vTaskIncrementTick+0x120>)
 800154c:	681b      	ldr	r3, [r3, #0]
 800154e:	681b      	ldr	r3, [r3, #0]
 8001550:	2b00      	cmp	r3, #0
 8001552:	d104      	bne.n	800155e <vTaskIncrementTick+0x56>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8001554:	4b37      	ldr	r3, [pc, #220]	; (8001634 <vTaskIncrementTick+0x12c>)
 8001556:	f04f 32ff 	mov.w	r2, #4294967295
 800155a:	601a      	str	r2, [r3, #0]
 800155c:	e008      	b.n	8001570 <vTaskIncrementTick+0x68>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800155e:	4b32      	ldr	r3, [pc, #200]	; (8001628 <vTaskIncrementTick+0x120>)
 8001560:	681b      	ldr	r3, [r3, #0]
 8001562:	68db      	ldr	r3, [r3, #12]
 8001564:	68db      	ldr	r3, [r3, #12]
 8001566:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8001568:	68bb      	ldr	r3, [r7, #8]
 800156a:	685a      	ldr	r2, [r3, #4]
 800156c:	4b31      	ldr	r3, [pc, #196]	; (8001634 <vTaskIncrementTick+0x12c>)
 800156e:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8001570:	4b2c      	ldr	r3, [pc, #176]	; (8001624 <vTaskIncrementTick+0x11c>)
 8001572:	681a      	ldr	r2, [r3, #0]
 8001574:	4b2f      	ldr	r3, [pc, #188]	; (8001634 <vTaskIncrementTick+0x12c>)
 8001576:	681b      	ldr	r3, [r3, #0]
 8001578:	429a      	cmp	r2, r3
 800157a:	d34d      	bcc.n	8001618 <vTaskIncrementTick+0x110>
 800157c:	4b2a      	ldr	r3, [pc, #168]	; (8001628 <vTaskIncrementTick+0x120>)
 800157e:	681b      	ldr	r3, [r3, #0]
 8001580:	681b      	ldr	r3, [r3, #0]
 8001582:	2b00      	cmp	r3, #0
 8001584:	d104      	bne.n	8001590 <vTaskIncrementTick+0x88>
 8001586:	4b2b      	ldr	r3, [pc, #172]	; (8001634 <vTaskIncrementTick+0x12c>)
 8001588:	f04f 32ff 	mov.w	r2, #4294967295
 800158c:	601a      	str	r2, [r3, #0]
 800158e:	e043      	b.n	8001618 <vTaskIncrementTick+0x110>
 8001590:	4b25      	ldr	r3, [pc, #148]	; (8001628 <vTaskIncrementTick+0x120>)
 8001592:	681b      	ldr	r3, [r3, #0]
 8001594:	68db      	ldr	r3, [r3, #12]
 8001596:	68db      	ldr	r3, [r3, #12]
 8001598:	60bb      	str	r3, [r7, #8]
 800159a:	68bb      	ldr	r3, [r7, #8]
 800159c:	685b      	ldr	r3, [r3, #4]
 800159e:	607b      	str	r3, [r7, #4]
 80015a0:	4b20      	ldr	r3, [pc, #128]	; (8001624 <vTaskIncrementTick+0x11c>)
 80015a2:	681a      	ldr	r2, [r3, #0]
 80015a4:	687b      	ldr	r3, [r7, #4]
 80015a6:	429a      	cmp	r2, r3
 80015a8:	d203      	bcs.n	80015b2 <vTaskIncrementTick+0xaa>
 80015aa:	4b22      	ldr	r3, [pc, #136]	; (8001634 <vTaskIncrementTick+0x12c>)
 80015ac:	687a      	ldr	r2, [r7, #4]
 80015ae:	601a      	str	r2, [r3, #0]
 80015b0:	e032      	b.n	8001618 <vTaskIncrementTick+0x110>
 80015b2:	68bb      	ldr	r3, [r7, #8]
 80015b4:	f103 0304 	add.w	r3, r3, #4
 80015b8:	4618      	mov	r0, r3
 80015ba:	f000 fa2d 	bl	8001a18 <vListRemove>
 80015be:	68bb      	ldr	r3, [r7, #8]
 80015c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80015c2:	2b00      	cmp	r3, #0
 80015c4:	d005      	beq.n	80015d2 <vTaskIncrementTick+0xca>
 80015c6:	68bb      	ldr	r3, [r7, #8]
 80015c8:	f103 0318 	add.w	r3, r3, #24
 80015cc:	4618      	mov	r0, r3
 80015ce:	f000 fa23 	bl	8001a18 <vListRemove>
 80015d2:	68bb      	ldr	r3, [r7, #8]
 80015d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015d6:	4b18      	ldr	r3, [pc, #96]	; (8001638 <vTaskIncrementTick+0x130>)
 80015d8:	681b      	ldr	r3, [r3, #0]
 80015da:	429a      	cmp	r2, r3
 80015dc:	d903      	bls.n	80015e6 <vTaskIncrementTick+0xde>
 80015de:	68bb      	ldr	r3, [r7, #8]
 80015e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015e2:	4b15      	ldr	r3, [pc, #84]	; (8001638 <vTaskIncrementTick+0x130>)
 80015e4:	601a      	str	r2, [r3, #0]
 80015e6:	68bb      	ldr	r3, [r7, #8]
 80015e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015ea:	4613      	mov	r3, r2
 80015ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80015f0:	189b      	adds	r3, r3, r2
 80015f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80015f6:	461a      	mov	r2, r3
 80015f8:	4b10      	ldr	r3, [pc, #64]	; (800163c <vTaskIncrementTick+0x134>)
 80015fa:	18d2      	adds	r2, r2, r3
 80015fc:	68bb      	ldr	r3, [r7, #8]
 80015fe:	f103 0304 	add.w	r3, r3, #4
 8001602:	4610      	mov	r0, r2
 8001604:	4619      	mov	r1, r3
 8001606:	f000 f9df 	bl	80019c8 <vListInsertEnd>
 800160a:	e7b7      	b.n	800157c <vTaskIncrementTick+0x74>
	}
	else
	{
		++uxMissedTicks;
 800160c:	4b0c      	ldr	r3, [pc, #48]	; (8001640 <vTaskIncrementTick+0x138>)
 800160e:	681b      	ldr	r3, [r3, #0]
 8001610:	f103 0201 	add.w	r2, r3, #1
 8001614:	4b0a      	ldr	r3, [pc, #40]	; (8001640 <vTaskIncrementTick+0x138>)
 8001616:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8001618:	f107 0710 	add.w	r7, r7, #16
 800161c:	46bd      	mov	sp, r7
 800161e:	bd80      	pop	{r7, pc}
 8001620:	20000790 	.word	0x20000790
 8001624:	20000780 	.word	0x20000780
 8001628:	20000730 	.word	0x20000730
 800162c:	20000734 	.word	0x20000734
 8001630:	2000079c 	.word	0x2000079c
 8001634:	2000052c 	.word	0x2000052c
 8001638:	20000788 	.word	0x20000788
 800163c:	200006a4 	.word	0x200006a4
 8001640:	20000794 	.word	0x20000794

08001644 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8001644:	b580      	push	{r7, lr}
 8001646:	b082      	sub	sp, #8
 8001648:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 800164a:	4b2e      	ldr	r3, [pc, #184]	; (8001704 <vTaskSwitchContext+0xc0>)
 800164c:	681b      	ldr	r3, [r3, #0]
 800164e:	2b00      	cmp	r3, #0
 8001650:	d004      	beq.n	800165c <vTaskSwitchContext+0x18>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8001652:	4b2d      	ldr	r3, [pc, #180]	; (8001708 <vTaskSwitchContext+0xc4>)
 8001654:	f04f 0201 	mov.w	r2, #1
 8001658:	601a      	str	r2, [r3, #0]
 800165a:	e04e      	b.n	80016fa <vTaskSwitchContext+0xb6>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 800165c:	f7ff fb16 	bl	8000c8c <get_us_time>
 8001660:	4602      	mov	r2, r0
 8001662:	460b      	mov	r3, r1
 8001664:	4613      	mov	r3, r2
 8001666:	607b      	str	r3, [r7, #4]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 8001668:	4b28      	ldr	r3, [pc, #160]	; (800170c <vTaskSwitchContext+0xc8>)
 800166a:	681b      	ldr	r3, [r3, #0]
 800166c:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 800166e:	4a28      	ldr	r2, [pc, #160]	; (8001710 <vTaskSwitchContext+0xcc>)
 8001670:	6812      	ldr	r2, [r2, #0]
 8001672:	6878      	ldr	r0, [r7, #4]
 8001674:	1a82      	subs	r2, r0, r2
 8001676:	188a      	adds	r2, r1, r2
 8001678:	64da      	str	r2, [r3, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
 800167a:	4b25      	ldr	r3, [pc, #148]	; (8001710 <vTaskSwitchContext+0xcc>)
 800167c:	687a      	ldr	r2, [r7, #4]
 800167e:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8001680:	e005      	b.n	800168e <vTaskSwitchContext+0x4a>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 8001682:	4b24      	ldr	r3, [pc, #144]	; (8001714 <vTaskSwitchContext+0xd0>)
 8001684:	681b      	ldr	r3, [r3, #0]
 8001686:	f103 32ff 	add.w	r2, r3, #4294967295
 800168a:	4b22      	ldr	r3, [pc, #136]	; (8001714 <vTaskSwitchContext+0xd0>)
 800168c:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 800168e:	4b21      	ldr	r3, [pc, #132]	; (8001714 <vTaskSwitchContext+0xd0>)
 8001690:	681a      	ldr	r2, [r3, #0]
 8001692:	4613      	mov	r3, r2
 8001694:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001698:	189b      	adds	r3, r3, r2
 800169a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800169e:	461a      	mov	r2, r3
 80016a0:	4b1d      	ldr	r3, [pc, #116]	; (8001718 <vTaskSwitchContext+0xd4>)
 80016a2:	18d3      	adds	r3, r2, r3
 80016a4:	681b      	ldr	r3, [r3, #0]
 80016a6:	2b00      	cmp	r3, #0
 80016a8:	d0eb      	beq.n	8001682 <vTaskSwitchContext+0x3e>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 80016aa:	4b1a      	ldr	r3, [pc, #104]	; (8001714 <vTaskSwitchContext+0xd0>)
 80016ac:	681a      	ldr	r2, [r3, #0]
 80016ae:	4613      	mov	r3, r2
 80016b0:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80016b4:	189b      	adds	r3, r3, r2
 80016b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80016ba:	461a      	mov	r2, r3
 80016bc:	4b16      	ldr	r3, [pc, #88]	; (8001718 <vTaskSwitchContext+0xd4>)
 80016be:	18d3      	adds	r3, r2, r3
 80016c0:	603b      	str	r3, [r7, #0]
 80016c2:	683b      	ldr	r3, [r7, #0]
 80016c4:	685b      	ldr	r3, [r3, #4]
 80016c6:	685a      	ldr	r2, [r3, #4]
 80016c8:	683b      	ldr	r3, [r7, #0]
 80016ca:	605a      	str	r2, [r3, #4]
 80016cc:	683b      	ldr	r3, [r7, #0]
 80016ce:	685a      	ldr	r2, [r3, #4]
 80016d0:	683b      	ldr	r3, [r7, #0]
 80016d2:	f103 0308 	add.w	r3, r3, #8
 80016d6:	429a      	cmp	r2, r3
 80016d8:	d104      	bne.n	80016e4 <vTaskSwitchContext+0xa0>
 80016da:	683b      	ldr	r3, [r7, #0]
 80016dc:	685b      	ldr	r3, [r3, #4]
 80016de:	685a      	ldr	r2, [r3, #4]
 80016e0:	683b      	ldr	r3, [r7, #0]
 80016e2:	605a      	str	r2, [r3, #4]
 80016e4:	683b      	ldr	r3, [r7, #0]
 80016e6:	685b      	ldr	r3, [r3, #4]
 80016e8:	68db      	ldr	r3, [r3, #12]
 80016ea:	461a      	mov	r2, r3
 80016ec:	4b07      	ldr	r3, [pc, #28]	; (800170c <vTaskSwitchContext+0xc8>)
 80016ee:	601a      	str	r2, [r3, #0]
	
		traceTASK_SWITCHED_IN();
 80016f0:	4b0a      	ldr	r3, [pc, #40]	; (800171c <vTaskSwitchContext+0xd8>)
 80016f2:	4a06      	ldr	r2, [pc, #24]	; (800170c <vTaskSwitchContext+0xc8>)
 80016f4:	6812      	ldr	r2, [r2, #0]
 80016f6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 80016f8:	60da      	str	r2, [r3, #12]
		vWriteTraceToBuffer();
	}
}
 80016fa:	f107 0708 	add.w	r7, r7, #8
 80016fe:	46bd      	mov	sp, r7
 8001700:	bd80      	pop	{r7, pc}
 8001702:	bf00      	nop
 8001704:	20000790 	.word	0x20000790
 8001708:	20000798 	.word	0x20000798
 800170c:	200006a0 	.word	0x200006a0
 8001710:	200007a4 	.word	0x200007a4
 8001714:	20000788 	.word	0x20000788
 8001718:	200006a4 	.word	0x200006a4
 800171c:	40007400 	.word	0x40007400

08001720 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8001720:	b580      	push	{r7, lr}
 8001722:	b082      	sub	sp, #8
 8001724:	af00      	add	r7, sp, #0
 8001726:	6078      	str	r0, [r7, #4]
 8001728:	e000      	b.n	800172c <prvIdleTask+0xc>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 800172a:	bf00      	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 800172c:	f000 f894 	bl	8001858 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8001730:	4b03      	ldr	r3, [pc, #12]	; (8001740 <prvIdleTask+0x20>)
 8001732:	681b      	ldr	r3, [r3, #0]
 8001734:	2b01      	cmp	r3, #1
 8001736:	d9f8      	bls.n	800172a <prvIdleTask+0xa>
			{
				taskYIELD();
 8001738:	f000 fa10 	bl	8001b5c <vPortYieldFromISR>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 800173c:	e7f6      	b.n	800172c <prvIdleTask+0xc>
 800173e:	bf00      	nop
 8001740:	200006a4 	.word	0x200006a4

08001744 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8001744:	b580      	push	{r7, lr}
 8001746:	b084      	sub	sp, #16
 8001748:	af00      	add	r7, sp, #0
 800174a:	60f8      	str	r0, [r7, #12]
 800174c:	60b9      	str	r1, [r7, #8]
 800174e:	607a      	str	r2, [r7, #4]
 8001750:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8001752:	68fb      	ldr	r3, [r7, #12]
 8001754:	f103 0334 	add.w	r3, r3, #52	; 0x34
 8001758:	461a      	mov	r2, r3
 800175a:	68bb      	ldr	r3, [r7, #8]
 800175c:	4610      	mov	r0, r2
 800175e:	4619      	mov	r1, r3
 8001760:	f04f 0210 	mov.w	r2, #16
 8001764:	f7ff f878 	bl	8000858 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 8001768:	68fb      	ldr	r3, [r7, #12]
 800176a:	f04f 0200 	mov.w	r2, #0
 800176e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8001772:	687b      	ldr	r3, [r7, #4]
 8001774:	2b04      	cmp	r3, #4
 8001776:	d902      	bls.n	800177e <prvInitialiseTCBVariables+0x3a>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 8001778:	f04f 0304 	mov.w	r3, #4
 800177c:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 800177e:	68fb      	ldr	r3, [r7, #12]
 8001780:	687a      	ldr	r2, [r7, #4]
 8001782:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001784:	68fb      	ldr	r3, [r7, #12]
 8001786:	687a      	ldr	r2, [r7, #4]
 8001788:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800178a:	68fb      	ldr	r3, [r7, #12]
 800178c:	f103 0304 	add.w	r3, r3, #4
 8001790:	4618      	mov	r0, r3
 8001792:	f000 f90b 	bl	80019ac <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8001796:	68fb      	ldr	r3, [r7, #12]
 8001798:	f103 0318 	add.w	r3, r3, #24
 800179c:	4618      	mov	r0, r3
 800179e:	f000 f905 	bl	80019ac <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80017a2:	68fb      	ldr	r3, [r7, #12]
 80017a4:	68fa      	ldr	r2, [r7, #12]
 80017a6:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80017a8:	687b      	ldr	r3, [r7, #4]
 80017aa:	f1c3 0205 	rsb	r2, r3, #5
 80017ae:	68fb      	ldr	r3, [r7, #12]
 80017b0:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80017b2:	68fb      	ldr	r3, [r7, #12]
 80017b4:	68fa      	ldr	r2, [r7, #12]
 80017b6:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
	{
		pxTCB->pxTaskTag = NULL;
 80017b8:	68fb      	ldr	r3, [r7, #12]
 80017ba:	f04f 0200 	mov.w	r2, #0
 80017be:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
 80017c0:	68fb      	ldr	r3, [r7, #12]
 80017c2:	f04f 0200 	mov.w	r2, #0
 80017c6:	64da      	str	r2, [r3, #76]	; 0x4c
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 80017c8:	f107 0710 	add.w	r7, r7, #16
 80017cc:	46bd      	mov	sp, r7
 80017ce:	bd80      	pop	{r7, pc}

080017d0 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 80017d0:	b580      	push	{r7, lr}
 80017d2:	b082      	sub	sp, #8
 80017d4:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80017d6:	f04f 0300 	mov.w	r3, #0
 80017da:	607b      	str	r3, [r7, #4]
 80017dc:	e010      	b.n	8001800 <prvInitialiseTaskLists+0x30>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 80017de:	687a      	ldr	r2, [r7, #4]
 80017e0:	4613      	mov	r3, r2
 80017e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80017e6:	189b      	adds	r3, r3, r2
 80017e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80017ec:	461a      	mov	r2, r3
 80017ee:	4b12      	ldr	r3, [pc, #72]	; (8001838 <prvInitialiseTaskLists+0x68>)
 80017f0:	18d3      	adds	r3, r2, r3
 80017f2:	4618      	mov	r0, r3
 80017f4:	f000 f8b6 	bl	8001964 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 80017f8:	687b      	ldr	r3, [r7, #4]
 80017fa:	f103 0301 	add.w	r3, r3, #1
 80017fe:	607b      	str	r3, [r7, #4]
 8001800:	687b      	ldr	r3, [r7, #4]
 8001802:	2b04      	cmp	r3, #4
 8001804:	d9eb      	bls.n	80017de <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8001806:	480d      	ldr	r0, [pc, #52]	; (800183c <prvInitialiseTaskLists+0x6c>)
 8001808:	f000 f8ac 	bl	8001964 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 800180c:	480c      	ldr	r0, [pc, #48]	; (8001840 <prvInitialiseTaskLists+0x70>)
 800180e:	f000 f8a9 	bl	8001964 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8001812:	480c      	ldr	r0, [pc, #48]	; (8001844 <prvInitialiseTaskLists+0x74>)
 8001814:	f000 f8a6 	bl	8001964 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 8001818:	480b      	ldr	r0, [pc, #44]	; (8001848 <prvInitialiseTaskLists+0x78>)
 800181a:	f000 f8a3 	bl	8001964 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 800181e:	480b      	ldr	r0, [pc, #44]	; (800184c <prvInitialiseTaskLists+0x7c>)
 8001820:	f000 f8a0 	bl	8001964 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8001824:	4b0a      	ldr	r3, [pc, #40]	; (8001850 <prvInitialiseTaskLists+0x80>)
 8001826:	4a05      	ldr	r2, [pc, #20]	; (800183c <prvInitialiseTaskLists+0x6c>)
 8001828:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800182a:	4b0a      	ldr	r3, [pc, #40]	; (8001854 <prvInitialiseTaskLists+0x84>)
 800182c:	4a04      	ldr	r2, [pc, #16]	; (8001840 <prvInitialiseTaskLists+0x70>)
 800182e:	601a      	str	r2, [r3, #0]
}
 8001830:	f107 0708 	add.w	r7, r7, #8
 8001834:	46bd      	mov	sp, r7
 8001836:	bd80      	pop	{r7, pc}
 8001838:	200006a4 	.word	0x200006a4
 800183c:	20000708 	.word	0x20000708
 8001840:	2000071c 	.word	0x2000071c
 8001844:	20000738 	.word	0x20000738
 8001848:	2000074c 	.word	0x2000074c
 800184c:	20000764 	.word	0x20000764
 8001850:	20000730 	.word	0x20000730
 8001854:	20000734 	.word	0x20000734

08001858 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8001858:	b580      	push	{r7, lr}
 800185a:	b082      	sub	sp, #8
 800185c:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 800185e:	4b19      	ldr	r3, [pc, #100]	; (80018c4 <prvCheckTasksWaitingTermination+0x6c>)
 8001860:	681b      	ldr	r3, [r3, #0]
 8001862:	2b00      	cmp	r3, #0
 8001864:	d02a      	beq.n	80018bc <prvCheckTasksWaitingTermination+0x64>
		{
			vTaskSuspendAll();
 8001866:	f7ff fdb7 	bl	80013d8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800186a:	4b17      	ldr	r3, [pc, #92]	; (80018c8 <prvCheckTasksWaitingTermination+0x70>)
 800186c:	681b      	ldr	r3, [r3, #0]
 800186e:	2b00      	cmp	r3, #0
 8001870:	bf14      	ite	ne
 8001872:	2300      	movne	r3, #0
 8001874:	2301      	moveq	r3, #1
 8001876:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 8001878:	f7ff fdbc 	bl	80013f4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 800187c:	687b      	ldr	r3, [r7, #4]
 800187e:	2b00      	cmp	r3, #0
 8001880:	d11c      	bne.n	80018bc <prvCheckTasksWaitingTermination+0x64>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8001882:	f000 f977 	bl	8001b74 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8001886:	4b10      	ldr	r3, [pc, #64]	; (80018c8 <prvCheckTasksWaitingTermination+0x70>)
 8001888:	68db      	ldr	r3, [r3, #12]
 800188a:	68db      	ldr	r3, [r3, #12]
 800188c:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 800188e:	683b      	ldr	r3, [r7, #0]
 8001890:	f103 0304 	add.w	r3, r3, #4
 8001894:	4618      	mov	r0, r3
 8001896:	f000 f8bf 	bl	8001a18 <vListRemove>
					--uxCurrentNumberOfTasks;
 800189a:	4b0c      	ldr	r3, [pc, #48]	; (80018cc <prvCheckTasksWaitingTermination+0x74>)
 800189c:	681b      	ldr	r3, [r3, #0]
 800189e:	f103 32ff 	add.w	r2, r3, #4294967295
 80018a2:	4b0a      	ldr	r3, [pc, #40]	; (80018cc <prvCheckTasksWaitingTermination+0x74>)
 80018a4:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 80018a6:	4b07      	ldr	r3, [pc, #28]	; (80018c4 <prvCheckTasksWaitingTermination+0x6c>)
 80018a8:	681b      	ldr	r3, [r3, #0]
 80018aa:	f103 32ff 	add.w	r2, r3, #4294967295
 80018ae:	4b05      	ldr	r3, [pc, #20]	; (80018c4 <prvCheckTasksWaitingTermination+0x6c>)
 80018b0:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 80018b2:	f000 f971 	bl	8001b98 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 80018b6:	6838      	ldr	r0, [r7, #0]
 80018b8:	f000 f844 	bl	8001944 <prvDeleteTCB>
			}
		}
	}
	#endif
}
 80018bc:	f107 0708 	add.w	r7, r7, #8
 80018c0:	46bd      	mov	sp, r7
 80018c2:	bd80      	pop	{r7, pc}
 80018c4:	20000760 	.word	0x20000760
 80018c8:	2000074c 	.word	0x2000074c
 80018cc:	2000077c 	.word	0x2000077c

080018d0 <prvAllocateTCBAndStack>:
	}
}
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 80018d0:	b580      	push	{r7, lr}
 80018d2:	b084      	sub	sp, #16
 80018d4:	af00      	add	r7, sp, #0
 80018d6:	4603      	mov	r3, r0
 80018d8:	6039      	str	r1, [r7, #0]
 80018da:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80018dc:	f04f 0050 	mov.w	r0, #80	; 0x50
 80018e0:	f7fe fc92 	bl	8000208 <malloc>
 80018e4:	4603      	mov	r3, r0
 80018e6:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 80018e8:	68fb      	ldr	r3, [r7, #12]
 80018ea:	2b00      	cmp	r3, #0
 80018ec:	d023      	beq.n	8001936 <prvAllocateTCBAndStack+0x66>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 80018ee:	683b      	ldr	r3, [r7, #0]
 80018f0:	2b00      	cmp	r3, #0
 80018f2:	d107      	bne.n	8001904 <prvAllocateTCBAndStack+0x34>
 80018f4:	88fb      	ldrh	r3, [r7, #6]
 80018f6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80018fa:	4618      	mov	r0, r3
 80018fc:	f7fe fc84 	bl	8000208 <malloc>
 8001900:	4603      	mov	r3, r0
 8001902:	e000      	b.n	8001906 <prvAllocateTCBAndStack+0x36>
 8001904:	683b      	ldr	r3, [r7, #0]
 8001906:	68fa      	ldr	r2, [r7, #12]
 8001908:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800190a:	68fb      	ldr	r3, [r7, #12]
 800190c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800190e:	2b00      	cmp	r3, #0
 8001910:	d106      	bne.n	8001920 <prvAllocateTCBAndStack+0x50>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8001912:	68f8      	ldr	r0, [r7, #12]
 8001914:	f7fe fc80 	bl	8000218 <free>
			pxNewTCB = NULL;
 8001918:	f04f 0300 	mov.w	r3, #0
 800191c:	60fb      	str	r3, [r7, #12]
 800191e:	e00a      	b.n	8001936 <prvAllocateTCBAndStack+0x66>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 8001920:	68fb      	ldr	r3, [r7, #12]
 8001922:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001924:	88fb      	ldrh	r3, [r7, #6]
 8001926:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800192a:	4610      	mov	r0, r2
 800192c:	f04f 01a5 	mov.w	r1, #165	; 0xa5
 8001930:	461a      	mov	r2, r3
 8001932:	f7fe ff37 	bl	80007a4 <memset>
		}
	}

	return pxNewTCB;
 8001936:	68fb      	ldr	r3, [r7, #12]
}
 8001938:	4618      	mov	r0, r3
 800193a:	f107 0710 	add.w	r7, r7, #16
 800193e:	46bd      	mov	sp, r7
 8001940:	bd80      	pop	{r7, pc}
 8001942:	bf00      	nop

08001944 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8001944:	b580      	push	{r7, lr}
 8001946:	b082      	sub	sp, #8
 8001948:	af00      	add	r7, sp, #0
 800194a:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 800194c:	687b      	ldr	r3, [r7, #4]
 800194e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001950:	4618      	mov	r0, r3
 8001952:	f7fe fc61 	bl	8000218 <free>
		vPortFree( pxTCB );
 8001956:	6878      	ldr	r0, [r7, #4]
 8001958:	f7fe fc5e 	bl	8000218 <free>
	}
 800195c:	f107 0708 	add.w	r7, r7, #8
 8001960:	46bd      	mov	sp, r7
 8001962:	bd80      	pop	{r7, pc}

08001964 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 8001964:	b480      	push	{r7}
 8001966:	b083      	sub	sp, #12
 8001968:	af00      	add	r7, sp, #0
 800196a:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 800196c:	687b      	ldr	r3, [r7, #4]
 800196e:	f103 0308 	add.w	r3, r3, #8
 8001972:	461a      	mov	r2, r3
 8001974:	687b      	ldr	r3, [r7, #4]
 8001976:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8001978:	687b      	ldr	r3, [r7, #4]
 800197a:	f04f 32ff 	mov.w	r2, #4294967295
 800197e:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8001980:	687b      	ldr	r3, [r7, #4]
 8001982:	f103 0308 	add.w	r3, r3, #8
 8001986:	461a      	mov	r2, r3
 8001988:	687b      	ldr	r3, [r7, #4]
 800198a:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 800198c:	687b      	ldr	r3, [r7, #4]
 800198e:	f103 0308 	add.w	r3, r3, #8
 8001992:	461a      	mov	r2, r3
 8001994:	687b      	ldr	r3, [r7, #4]
 8001996:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8001998:	687b      	ldr	r3, [r7, #4]
 800199a:	f04f 0200 	mov.w	r2, #0
 800199e:	601a      	str	r2, [r3, #0]
}
 80019a0:	f107 070c 	add.w	r7, r7, #12
 80019a4:	46bd      	mov	sp, r7
 80019a6:	bc80      	pop	{r7}
 80019a8:	4770      	bx	lr
 80019aa:	bf00      	nop

080019ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 80019ac:	b480      	push	{r7}
 80019ae:	b083      	sub	sp, #12
 80019b0:	af00      	add	r7, sp, #0
 80019b2:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80019b4:	687b      	ldr	r3, [r7, #4]
 80019b6:	f04f 0200 	mov.w	r2, #0
 80019ba:	611a      	str	r2, [r3, #16]
}
 80019bc:	f107 070c 	add.w	r7, r7, #12
 80019c0:	46bd      	mov	sp, r7
 80019c2:	bc80      	pop	{r7}
 80019c4:	4770      	bx	lr
 80019c6:	bf00      	nop

080019c8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 80019c8:	b480      	push	{r7}
 80019ca:	b085      	sub	sp, #20
 80019cc:	af00      	add	r7, sp, #0
 80019ce:	6078      	str	r0, [r7, #4]
 80019d0:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 80019d2:	687b      	ldr	r3, [r7, #4]
 80019d4:	685b      	ldr	r3, [r3, #4]
 80019d6:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 80019d8:	68fb      	ldr	r3, [r7, #12]
 80019da:	685a      	ldr	r2, [r3, #4]
 80019dc:	683b      	ldr	r3, [r7, #0]
 80019de:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 80019e0:	687b      	ldr	r3, [r7, #4]
 80019e2:	685a      	ldr	r2, [r3, #4]
 80019e4:	683b      	ldr	r3, [r7, #0]
 80019e6:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 80019e8:	68fb      	ldr	r3, [r7, #12]
 80019ea:	685b      	ldr	r3, [r3, #4]
 80019ec:	683a      	ldr	r2, [r7, #0]
 80019ee:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 80019f0:	683a      	ldr	r2, [r7, #0]
 80019f2:	68fb      	ldr	r3, [r7, #12]
 80019f4:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 80019f6:	683a      	ldr	r2, [r7, #0]
 80019f8:	687b      	ldr	r3, [r7, #4]
 80019fa:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80019fc:	683b      	ldr	r3, [r7, #0]
 80019fe:	687a      	ldr	r2, [r7, #4]
 8001a00:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8001a02:	687b      	ldr	r3, [r7, #4]
 8001a04:	681b      	ldr	r3, [r3, #0]
 8001a06:	f103 0201 	add.w	r2, r3, #1
 8001a0a:	687b      	ldr	r3, [r7, #4]
 8001a0c:	601a      	str	r2, [r3, #0]
}
 8001a0e:	f107 0714 	add.w	r7, r7, #20
 8001a12:	46bd      	mov	sp, r7
 8001a14:	bc80      	pop	{r7}
 8001a16:	4770      	bx	lr

08001a18 <vListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 8001a18:	b480      	push	{r7}
 8001a1a:	b085      	sub	sp, #20
 8001a1c:	af00      	add	r7, sp, #0
 8001a1e:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001a20:	687b      	ldr	r3, [r7, #4]
 8001a22:	685b      	ldr	r3, [r3, #4]
 8001a24:	687a      	ldr	r2, [r7, #4]
 8001a26:	6892      	ldr	r2, [r2, #8]
 8001a28:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001a2a:	687b      	ldr	r3, [r7, #4]
 8001a2c:	689b      	ldr	r3, [r3, #8]
 8001a2e:	687a      	ldr	r2, [r7, #4]
 8001a30:	6852      	ldr	r2, [r2, #4]
 8001a32:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8001a34:	687b      	ldr	r3, [r7, #4]
 8001a36:	691b      	ldr	r3, [r3, #16]
 8001a38:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8001a3a:	68fb      	ldr	r3, [r7, #12]
 8001a3c:	685a      	ldr	r2, [r3, #4]
 8001a3e:	687b      	ldr	r3, [r7, #4]
 8001a40:	429a      	cmp	r2, r3
 8001a42:	d103      	bne.n	8001a4c <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8001a44:	687b      	ldr	r3, [r7, #4]
 8001a46:	689a      	ldr	r2, [r3, #8]
 8001a48:	68fb      	ldr	r3, [r7, #12]
 8001a4a:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8001a4c:	687b      	ldr	r3, [r7, #4]
 8001a4e:	f04f 0200 	mov.w	r2, #0
 8001a52:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8001a54:	68fb      	ldr	r3, [r7, #12]
 8001a56:	681b      	ldr	r3, [r3, #0]
 8001a58:	f103 32ff 	add.w	r2, r3, #4294967295
 8001a5c:	68fb      	ldr	r3, [r7, #12]
 8001a5e:	601a      	str	r2, [r3, #0]
}
 8001a60:	f107 0714 	add.w	r7, r7, #20
 8001a64:	46bd      	mov	sp, r7
 8001a66:	bc80      	pop	{r7}
 8001a68:	4770      	bx	lr
 8001a6a:	bf00      	nop

08001a6c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8001a6c:	b480      	push	{r7}
 8001a6e:	b085      	sub	sp, #20
 8001a70:	af00      	add	r7, sp, #0
 8001a72:	60f8      	str	r0, [r7, #12]
 8001a74:	60b9      	str	r1, [r7, #8]
 8001a76:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 8001a78:	68fb      	ldr	r3, [r7, #12]
 8001a7a:	f1a3 0304 	sub.w	r3, r3, #4
 8001a7e:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8001a80:	68fb      	ldr	r3, [r7, #12]
 8001a82:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8001a86:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8001a88:	68fb      	ldr	r3, [r7, #12]
 8001a8a:	f1a3 0304 	sub.w	r3, r3, #4
 8001a8e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8001a90:	68ba      	ldr	r2, [r7, #8]
 8001a92:	68fb      	ldr	r3, [r7, #12]
 8001a94:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8001a96:	68fb      	ldr	r3, [r7, #12]
 8001a98:	f1a3 0304 	sub.w	r3, r3, #4
 8001a9c:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8001a9e:	68fb      	ldr	r3, [r7, #12]
 8001aa0:	f04f 0200 	mov.w	r2, #0
 8001aa4:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8001aa6:	68fb      	ldr	r3, [r7, #12]
 8001aa8:	f1a3 0314 	sub.w	r3, r3, #20
 8001aac:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8001aae:	687a      	ldr	r2, [r7, #4]
 8001ab0:	68fb      	ldr	r3, [r7, #12]
 8001ab2:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 8001ab4:	68fb      	ldr	r3, [r7, #12]
 8001ab6:	f1a3 0304 	sub.w	r3, r3, #4
 8001aba:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8001abc:	68fb      	ldr	r3, [r7, #12]
 8001abe:	f06f 0202 	mvn.w	r2, #2
 8001ac2:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8001ac4:	68fb      	ldr	r3, [r7, #12]
 8001ac6:	f1a3 0320 	sub.w	r3, r3, #32
 8001aca:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8001acc:	68fb      	ldr	r3, [r7, #12]
}
 8001ace:	4618      	mov	r0, r3
 8001ad0:	f107 0714 	add.w	r7, r7, #20
 8001ad4:	46bd      	mov	sp, r7
 8001ad6:	bc80      	pop	{r7}
 8001ad8:	4770      	bx	lr
 8001ada:	bf00      	nop

08001adc <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8001adc:	4b05      	ldr	r3, [pc, #20]	; (8001af4 <pxCurrentTCBConst2>)
 8001ade:	6819      	ldr	r1, [r3, #0]
 8001ae0:	6808      	ldr	r0, [r1, #0]
 8001ae2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001ae6:	f380 8809 	msr	PSP, r0
 8001aea:	f04f 0000 	mov.w	r0, #0
 8001aee:	f380 8811 	msr	BASEPRI, r0
 8001af2:	4770      	bx	lr

08001af4 <pxCurrentTCBConst2>:
 8001af4:	200006a0 	.word	0x200006a0

08001af8 <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void vPortStartFirstTask( void )
{
	__asm volatile(
 8001af8:	4803      	ldr	r0, [pc, #12]	; (8001b08 <vPortStartFirstTask+0x10>)
 8001afa:	6800      	ldr	r0, [r0, #0]
 8001afc:	6800      	ldr	r0, [r0, #0]
 8001afe:	f380 8808 	msr	MSP, r0
 8001b02:	b662      	cpsie	i
 8001b04:	df00      	svc	0
 8001b06:	bf00      	nop
 8001b08:	e000ed08 	.word	0xe000ed08

08001b0c <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8001b0c:	b580      	push	{r7, lr}
 8001b0e:	af00      	add	r7, sp, #0
	/* Make PendSV and SysTick the lowest priority interrupts. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 8001b10:	4b0f      	ldr	r3, [pc, #60]	; (8001b50 <xPortStartScheduler+0x44>)
 8001b12:	4a0f      	ldr	r2, [pc, #60]	; (8001b50 <xPortStartScheduler+0x44>)
 8001b14:	6812      	ldr	r2, [r2, #0]
 8001b16:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 8001b1a:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 8001b1c:	4b0c      	ldr	r3, [pc, #48]	; (8001b50 <xPortStartScheduler+0x44>)
 8001b1e:	4a0c      	ldr	r2, [pc, #48]	; (8001b50 <xPortStartScheduler+0x44>)
 8001b20:	6812      	ldr	r2, [r2, #0]
 8001b22:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8001b26:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8001b28:	f000 f88e 	bl	8001c48 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8001b2c:	4b09      	ldr	r3, [pc, #36]	; (8001b54 <xPortStartScheduler+0x48>)
 8001b2e:	f04f 0200 	mov.w	r2, #0
 8001b32:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8001b34:	f000 f8a4 	bl	8001c80 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8001b38:	4b07      	ldr	r3, [pc, #28]	; (8001b58 <xPortStartScheduler+0x4c>)
 8001b3a:	4a07      	ldr	r2, [pc, #28]	; (8001b58 <xPortStartScheduler+0x4c>)
 8001b3c:	6812      	ldr	r2, [r2, #0]
 8001b3e:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 8001b42:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8001b44:	f7ff ffd8 	bl	8001af8 <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8001b48:	f04f 0300 	mov.w	r3, #0
}
 8001b4c:	4618      	mov	r0, r3
 8001b4e:	bd80      	pop	{r7, pc}
 8001b50:	e000ed20 	.word	0xe000ed20
 8001b54:	20000530 	.word	0x20000530
 8001b58:	e000ef34 	.word	0xe000ef34

08001b5c <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 8001b5c:	b480      	push	{r7}
 8001b5e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001b60:	4b03      	ldr	r3, [pc, #12]	; (8001b70 <vPortYieldFromISR+0x14>)
 8001b62:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001b66:	601a      	str	r2, [r3, #0]
}
 8001b68:	46bd      	mov	sp, r7
 8001b6a:	bc80      	pop	{r7}
 8001b6c:	4770      	bx	lr
 8001b6e:	bf00      	nop
 8001b70:	e000ed04 	.word	0xe000ed04

08001b74 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8001b74:	b480      	push	{r7}
 8001b76:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 8001b78:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001b7c:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8001b80:	4b04      	ldr	r3, [pc, #16]	; (8001b94 <vPortEnterCritical+0x20>)
 8001b82:	681b      	ldr	r3, [r3, #0]
 8001b84:	f103 0201 	add.w	r2, r3, #1
 8001b88:	4b02      	ldr	r3, [pc, #8]	; (8001b94 <vPortEnterCritical+0x20>)
 8001b8a:	601a      	str	r2, [r3, #0]
}
 8001b8c:	46bd      	mov	sp, r7
 8001b8e:	bc80      	pop	{r7}
 8001b90:	4770      	bx	lr
 8001b92:	bf00      	nop
 8001b94:	20000530 	.word	0x20000530

08001b98 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8001b98:	b480      	push	{r7}
 8001b9a:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8001b9c:	4b08      	ldr	r3, [pc, #32]	; (8001bc0 <vPortExitCritical+0x28>)
 8001b9e:	681b      	ldr	r3, [r3, #0]
 8001ba0:	f103 32ff 	add.w	r2, r3, #4294967295
 8001ba4:	4b06      	ldr	r3, [pc, #24]	; (8001bc0 <vPortExitCritical+0x28>)
 8001ba6:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 8001ba8:	4b05      	ldr	r3, [pc, #20]	; (8001bc0 <vPortExitCritical+0x28>)
 8001baa:	681b      	ldr	r3, [r3, #0]
 8001bac:	2b00      	cmp	r3, #0
 8001bae:	d103      	bne.n	8001bb8 <vPortExitCritical+0x20>
	{
		portENABLE_INTERRUPTS();
 8001bb0:	f04f 0000 	mov.w	r0, #0
 8001bb4:	f380 8811 	msr	BASEPRI, r0
	}
}
 8001bb8:	46bd      	mov	sp, r7
 8001bba:	bc80      	pop	{r7}
 8001bbc:	4770      	bx	lr
 8001bbe:	bf00      	nop
 8001bc0:	20000530 	.word	0x20000530

08001bc4 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001bc4:	f3ef 8009 	mrs	r0, PSP
 8001bc8:	4b11      	ldr	r3, [pc, #68]	; (8001c10 <pxCurrentTCBConst>)
 8001bca:	681a      	ldr	r2, [r3, #0]
 8001bcc:	f01e 0f10 	tst.w	lr, #16
 8001bd0:	bf08      	it	eq
 8001bd2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8001bd6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001bda:	6010      	str	r0, [r2, #0]
 8001bdc:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001be0:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001be4:	f380 8811 	msr	BASEPRI, r0
 8001be8:	f7ff fd2c 	bl	8001644 <vTaskSwitchContext>
 8001bec:	f04f 0000 	mov.w	r0, #0
 8001bf0:	f380 8811 	msr	BASEPRI, r0
 8001bf4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001bf8:	6819      	ldr	r1, [r3, #0]
 8001bfa:	6808      	ldr	r0, [r1, #0]
 8001bfc:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c00:	f01e 0f10 	tst.w	lr, #16
 8001c04:	bf08      	it	eq
 8001c06:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8001c0a:	f380 8809 	msr	PSP, r0
 8001c0e:	4770      	bx	lr

08001c10 <pxCurrentTCBConst>:
 8001c10:	200006a0 	.word	0x200006a0

08001c14 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001c14:	b580      	push	{r7, lr}
 8001c16:	b082      	sub	sp, #8
 8001c18:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8001c1a:	4b0a      	ldr	r3, [pc, #40]	; (8001c44 <SysTick_Handler+0x30>)
 8001c1c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001c20:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8001c22:	f04f 0300 	mov.w	r3, #0
 8001c26:	607b      	str	r3, [r7, #4]
 8001c28:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8001c2c:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8001c30:	f7ff fc6a 	bl	8001508 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8001c34:	f04f 0000 	mov.w	r0, #0
 8001c38:	f380 8811 	msr	BASEPRI, r0
}
 8001c3c:	f107 0708 	add.w	r7, r7, #8
 8001c40:	46bd      	mov	sp, r7
 8001c42:	bd80      	pop	{r7, pc}
 8001c44:	e000ed04 	.word	0xe000ed04

08001c48 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8001c48:	b480      	push	{r7}
 8001c4a:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001c4c:	4b08      	ldr	r3, [pc, #32]	; (8001c70 <prvSetupTimerInterrupt+0x28>)
 8001c4e:	4a09      	ldr	r2, [pc, #36]	; (8001c74 <prvSetupTimerInterrupt+0x2c>)
 8001c50:	6811      	ldr	r1, [r2, #0]
 8001c52:	4a09      	ldr	r2, [pc, #36]	; (8001c78 <prvSetupTimerInterrupt+0x30>)
 8001c54:	fba2 0201 	umull	r0, r2, r2, r1
 8001c58:	ea4f 1292 	mov.w	r2, r2, lsr #6
 8001c5c:	f102 32ff 	add.w	r2, r2, #4294967295
 8001c60:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8001c62:	4b06      	ldr	r3, [pc, #24]	; (8001c7c <prvSetupTimerInterrupt+0x34>)
 8001c64:	f04f 0207 	mov.w	r2, #7
 8001c68:	601a      	str	r2, [r3, #0]
}
 8001c6a:	46bd      	mov	sp, r7
 8001c6c:	bc80      	pop	{r7}
 8001c6e:	4770      	bx	lr
 8001c70:	e000e014 	.word	0xe000e014
 8001c74:	20000524 	.word	0x20000524
 8001c78:	10624dd3 	.word	0x10624dd3
 8001c7c:	e000e010 	.word	0xe000e010

08001c80 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8001c80:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8001c90 <vPortEnableVFP+0x10>
 8001c84:	6801      	ldr	r1, [r0, #0]
 8001c86:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8001c8a:	6001      	str	r1, [r0, #0]
 8001c8c:	4770      	bx	lr
 8001c8e:	0000      	.short	0x0000
 8001c90:	e000ed88 	.word	0xe000ed88

08001c94 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8001c94:	b480      	push	{r7}
 8001c96:	b085      	sub	sp, #20
 8001c98:	af00      	add	r7, sp, #0
 8001c9a:	6078      	str	r0, [r7, #4]
 8001c9c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg1 = 0;
 8001c9e:	f04f 0300 	mov.w	r3, #0
 8001ca2:	60fb      	str	r3, [r7, #12]
  uint8_t tmpreg2 = 0;
 8001ca4:	f04f 0300 	mov.w	r3, #0
 8001ca8:	72fb      	strb	r3, [r7, #11]
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8001caa:	687b      	ldr	r3, [r7, #4]
 8001cac:	685b      	ldr	r3, [r3, #4]
 8001cae:	60fb      	str	r3, [r7, #12]
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 8001cb0:	68fb      	ldr	r3, [r7, #12]
 8001cb2:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8001cb6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001cba:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8001cbc:	683b      	ldr	r3, [r7, #0]
 8001cbe:	791b      	ldrb	r3, [r3, #4]
 8001cc0:	ea4f 2203 	mov.w	r2, r3, lsl #8
                                   ADC_InitStruct->ADC_Resolution);
 8001cc4:	683b      	ldr	r3, [r7, #0]
 8001cc6:	681b      	ldr	r3, [r3, #0]
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8001cc8:	ea42 0303 	orr.w	r3, r2, r3
 8001ccc:	68fa      	ldr	r2, [r7, #12]
 8001cce:	ea42 0303 	orr.w	r3, r2, r3
 8001cd2:	60fb      	str	r3, [r7, #12]
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8001cd4:	687b      	ldr	r3, [r7, #4]
 8001cd6:	68fa      	ldr	r2, [r7, #12]
 8001cd8:	605a      	str	r2, [r3, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8001cda:	687b      	ldr	r3, [r7, #4]
 8001cdc:	689b      	ldr	r3, [r3, #8]
 8001cde:	60fb      	str	r3, [r7, #12]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8001ce0:	68fa      	ldr	r2, [r7, #12]
 8001ce2:	4b1c      	ldr	r3, [pc, #112]	; (8001d54 <ADC_Init+0xc0>)
 8001ce4:	ea02 0303 	and.w	r3, r2, r3
 8001ce8:	60fb      	str	r3, [r7, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8001cea:	683b      	ldr	r3, [r7, #0]
 8001cec:	691a      	ldr	r2, [r3, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8001cee:	683b      	ldr	r3, [r7, #0]
 8001cf0:	68db      	ldr	r3, [r3, #12]
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8001cf2:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
 8001cf4:	683b      	ldr	r3, [r7, #0]
 8001cf6:	689b      	ldr	r3, [r3, #8]
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 8001cf8:	431a      	orrs	r2, r3
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8001cfa:	683b      	ldr	r3, [r7, #0]
 8001cfc:	795b      	ldrb	r3, [r3, #5]
 8001cfe:	ea4f 0343 	mov.w	r3, r3, lsl #1
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8001d02:	ea42 0303 	orr.w	r3, r2, r3
 8001d06:	68fa      	ldr	r2, [r7, #12]
 8001d08:	ea42 0303 	orr.w	r3, r2, r3
 8001d0c:	60fb      	str	r3, [r7, #12]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8001d0e:	687b      	ldr	r3, [r7, #4]
 8001d10:	68fa      	ldr	r2, [r7, #12]
 8001d12:	609a      	str	r2, [r3, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8001d14:	687b      	ldr	r3, [r7, #4]
 8001d16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d18:	60fb      	str	r3, [r7, #12]
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 8001d1a:	68fb      	ldr	r3, [r7, #12]
 8001d1c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8001d20:	60fb      	str	r3, [r7, #12]
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8001d22:	683b      	ldr	r3, [r7, #0]
 8001d24:	7d1b      	ldrb	r3, [r3, #20]
 8001d26:	f103 33ff 	add.w	r3, r3, #4294967295
 8001d2a:	b2da      	uxtb	r2, r3
 8001d2c:	7afb      	ldrb	r3, [r7, #11]
 8001d2e:	ea42 0303 	orr.w	r3, r2, r3
 8001d32:	72fb      	strb	r3, [r7, #11]
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8001d34:	7afb      	ldrb	r3, [r7, #11]
 8001d36:	ea4f 5303 	mov.w	r3, r3, lsl #20
 8001d3a:	68fa      	ldr	r2, [r7, #12]
 8001d3c:	ea42 0303 	orr.w	r3, r2, r3
 8001d40:	60fb      	str	r3, [r7, #12]
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8001d42:	687b      	ldr	r3, [r7, #4]
 8001d44:	68fa      	ldr	r2, [r7, #12]
 8001d46:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8001d48:	f107 0714 	add.w	r7, r7, #20
 8001d4c:	46bd      	mov	sp, r7
 8001d4e:	bc80      	pop	{r7}
 8001d50:	4770      	bx	lr
 8001d52:	bf00      	nop
 8001d54:	c0fff7fd 	.word	0xc0fff7fd

08001d58 <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8001d58:	b480      	push	{r7}
 8001d5a:	b085      	sub	sp, #20
 8001d5c:	af00      	add	r7, sp, #0
 8001d5e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg1 = 0;
 8001d60:	f04f 0300 	mov.w	r3, #0
 8001d64:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 8001d66:	4b10      	ldr	r3, [pc, #64]	; (8001da8 <ADC_CommonInit+0x50>)
 8001d68:	685b      	ldr	r3, [r3, #4]
 8001d6a:	60fb      	str	r3, [r7, #12]
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 8001d6c:	68fa      	ldr	r2, [r7, #12]
 8001d6e:	4b0f      	ldr	r3, [pc, #60]	; (8001dac <ADC_CommonInit+0x54>)
 8001d70:	ea02 0303 	and.w	r3, r2, r3
 8001d74:	60fb      	str	r3, [r7, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8001d76:	687b      	ldr	r3, [r7, #4]
 8001d78:	681a      	ldr	r2, [r3, #0]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	685b      	ldr	r3, [r3, #4]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8001d7e:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8001d80:	687b      	ldr	r3, [r7, #4]
 8001d82:	689b      	ldr	r3, [r3, #8]
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8001d84:	431a      	orrs	r2, r3
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
 8001d86:	687b      	ldr	r3, [r7, #4]
 8001d88:	68db      	ldr	r3, [r3, #12]
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8001d8a:	ea42 0303 	orr.w	r3, r2, r3
 8001d8e:	68fa      	ldr	r2, [r7, #12]
 8001d90:	ea42 0303 	orr.w	r3, r2, r3
 8001d94:	60fb      	str	r3, [r7, #12]
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8001d96:	4b04      	ldr	r3, [pc, #16]	; (8001da8 <ADC_CommonInit+0x50>)
 8001d98:	68fa      	ldr	r2, [r7, #12]
 8001d9a:	605a      	str	r2, [r3, #4]
}
 8001d9c:	f107 0714 	add.w	r7, r7, #20
 8001da0:	46bd      	mov	sp, r7
 8001da2:	bc80      	pop	{r7}
 8001da4:	4770      	bx	lr
 8001da6:	bf00      	nop
 8001da8:	40012300 	.word	0x40012300
 8001dac:	fffc30e0 	.word	0xfffc30e0

08001db0 <ADC_Cmd>:
  * @param  NewState: new state of the ADCx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
 8001db0:	b480      	push	{r7}
 8001db2:	b083      	sub	sp, #12
 8001db4:	af00      	add	r7, sp, #0
 8001db6:	6078      	str	r0, [r7, #4]
 8001db8:	460b      	mov	r3, r1
 8001dba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001dbc:	78fb      	ldrb	r3, [r7, #3]
 8001dbe:	2b00      	cmp	r3, #0
 8001dc0:	d006      	beq.n	8001dd0 <ADC_Cmd+0x20>
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8001dc2:	687b      	ldr	r3, [r7, #4]
 8001dc4:	689b      	ldr	r3, [r3, #8]
 8001dc6:	f043 0201 	orr.w	r2, r3, #1
 8001dca:	687b      	ldr	r3, [r7, #4]
 8001dcc:	609a      	str	r2, [r3, #8]
 8001dce:	e005      	b.n	8001ddc <ADC_Cmd+0x2c>
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8001dd0:	687b      	ldr	r3, [r7, #4]
 8001dd2:	689b      	ldr	r3, [r3, #8]
 8001dd4:	f023 0201 	bic.w	r2, r3, #1
 8001dd8:	687b      	ldr	r3, [r7, #4]
 8001dda:	609a      	str	r2, [r3, #8]
  }
}
 8001ddc:	f107 070c 	add.w	r7, r7, #12
 8001de0:	46bd      	mov	sp, r7
 8001de2:	bc80      	pop	{r7}
 8001de4:	4770      	bx	lr
 8001de6:	bf00      	nop

08001de8 <ADC_TempSensorVrefintCmd>:
  * @param  NewState: new state of the temperature sensor and Vrefint channels.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
 8001de8:	b480      	push	{r7}
 8001dea:	b083      	sub	sp, #12
 8001dec:	af00      	add	r7, sp, #0
 8001dee:	4603      	mov	r3, r0
 8001df0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8001df2:	79fb      	ldrb	r3, [r7, #7]
 8001df4:	2b00      	cmp	r3, #0
 8001df6:	d006      	beq.n	8001e06 <ADC_TempSensorVrefintCmd+0x1e>
  {
    /* Enable the temperature sensor and Vrefint channel*/
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 8001df8:	4b08      	ldr	r3, [pc, #32]	; (8001e1c <ADC_TempSensorVrefintCmd+0x34>)
 8001dfa:	4a08      	ldr	r2, [pc, #32]	; (8001e1c <ADC_TempSensorVrefintCmd+0x34>)
 8001dfc:	6852      	ldr	r2, [r2, #4]
 8001dfe:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8001e02:	605a      	str	r2, [r3, #4]
 8001e04:	e005      	b.n	8001e12 <ADC_TempSensorVrefintCmd+0x2a>
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 8001e06:	4b05      	ldr	r3, [pc, #20]	; (8001e1c <ADC_TempSensorVrefintCmd+0x34>)
 8001e08:	4a04      	ldr	r2, [pc, #16]	; (8001e1c <ADC_TempSensorVrefintCmd+0x34>)
 8001e0a:	6852      	ldr	r2, [r2, #4]
 8001e0c:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001e10:	605a      	str	r2, [r3, #4]
  }
}
 8001e12:	f107 070c 	add.w	r7, r7, #12
 8001e16:	46bd      	mov	sp, r7
 8001e18:	bc80      	pop	{r7}
 8001e1a:	4770      	bx	lr
 8001e1c:	40012300 	.word	0x40012300

08001e20 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8001e20:	b480      	push	{r7}
 8001e22:	b085      	sub	sp, #20
 8001e24:	af00      	add	r7, sp, #0
 8001e26:	6078      	str	r0, [r7, #4]
 8001e28:	70f9      	strb	r1, [r7, #3]
 8001e2a:	70ba      	strb	r2, [r7, #2]
 8001e2c:	707b      	strb	r3, [r7, #1]
  uint32_t tmpreg1 = 0, tmpreg2 = 0;
 8001e2e:	f04f 0300 	mov.w	r3, #0
 8001e32:	60fb      	str	r3, [r7, #12]
 8001e34:	f04f 0300 	mov.w	r3, #0
 8001e38:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8001e3a:	78fb      	ldrb	r3, [r7, #3]
 8001e3c:	2b09      	cmp	r3, #9
 8001e3e:	d929      	bls.n	8001e94 <ADC_RegularChannelConfig+0x74>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 8001e40:	687b      	ldr	r3, [r7, #4]
 8001e42:	68db      	ldr	r3, [r3, #12]
 8001e44:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8001e46:	78fa      	ldrb	r2, [r7, #3]
 8001e48:	4613      	mov	r3, r2
 8001e4a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001e4e:	189b      	adds	r3, r3, r2
 8001e50:	f1a3 031e 	sub.w	r3, r3, #30
 8001e54:	f04f 0207 	mov.w	r2, #7
 8001e58:	fa02 f303 	lsl.w	r3, r2, r3
 8001e5c:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8001e5e:	68bb      	ldr	r3, [r7, #8]
 8001e60:	ea6f 0303 	mvn.w	r3, r3
 8001e64:	68fa      	ldr	r2, [r7, #12]
 8001e66:	ea02 0303 	and.w	r3, r2, r3
 8001e6a:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8001e6c:	7879      	ldrb	r1, [r7, #1]
 8001e6e:	78fa      	ldrb	r2, [r7, #3]
 8001e70:	4613      	mov	r3, r2
 8001e72:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001e76:	189b      	adds	r3, r3, r2
 8001e78:	f1a3 031e 	sub.w	r3, r3, #30
 8001e7c:	fa01 f303 	lsl.w	r3, r1, r3
 8001e80:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8001e82:	68fa      	ldr	r2, [r7, #12]
 8001e84:	68bb      	ldr	r3, [r7, #8]
 8001e86:	ea42 0303 	orr.w	r3, r2, r3
 8001e8a:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8001e8c:	687b      	ldr	r3, [r7, #4]
 8001e8e:	68fa      	ldr	r2, [r7, #12]
 8001e90:	60da      	str	r2, [r3, #12]
 8001e92:	e024      	b.n	8001ede <ADC_RegularChannelConfig+0xbe>
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8001e94:	687b      	ldr	r3, [r7, #4]
 8001e96:	691b      	ldr	r3, [r3, #16]
 8001e98:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8001e9a:	78fa      	ldrb	r2, [r7, #3]
 8001e9c:	4613      	mov	r3, r2
 8001e9e:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001ea2:	189b      	adds	r3, r3, r2
 8001ea4:	f04f 0207 	mov.w	r2, #7
 8001ea8:	fa02 f303 	lsl.w	r3, r2, r3
 8001eac:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8001eae:	68bb      	ldr	r3, [r7, #8]
 8001eb0:	ea6f 0303 	mvn.w	r3, r3
 8001eb4:	68fa      	ldr	r2, [r7, #12]
 8001eb6:	ea02 0303 	and.w	r3, r2, r3
 8001eba:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8001ebc:	7879      	ldrb	r1, [r7, #1]
 8001ebe:	78fa      	ldrb	r2, [r7, #3]
 8001ec0:	4613      	mov	r3, r2
 8001ec2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8001ec6:	189b      	adds	r3, r3, r2
 8001ec8:	fa01 f303 	lsl.w	r3, r1, r3
 8001ecc:	60bb      	str	r3, [r7, #8]
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8001ece:	68fa      	ldr	r2, [r7, #12]
 8001ed0:	68bb      	ldr	r3, [r7, #8]
 8001ed2:	ea42 0303 	orr.w	r3, r2, r3
 8001ed6:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8001ed8:	687b      	ldr	r3, [r7, #4]
 8001eda:	68fa      	ldr	r2, [r7, #12]
 8001edc:	611a      	str	r2, [r3, #16]
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8001ede:	78bb      	ldrb	r3, [r7, #2]
 8001ee0:	2b06      	cmp	r3, #6
 8001ee2:	d829      	bhi.n	8001f38 <ADC_RegularChannelConfig+0x118>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8001ee4:	687b      	ldr	r3, [r7, #4]
 8001ee6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001ee8:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8001eea:	78bb      	ldrb	r3, [r7, #2]
 8001eec:	f103 32ff 	add.w	r2, r3, #4294967295
 8001ef0:	4613      	mov	r3, r2
 8001ef2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001ef6:	189b      	adds	r3, r3, r2
 8001ef8:	f04f 021f 	mov.w	r2, #31
 8001efc:	fa02 f303 	lsl.w	r3, r2, r3
 8001f00:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8001f02:	68bb      	ldr	r3, [r7, #8]
 8001f04:	ea6f 0303 	mvn.w	r3, r3
 8001f08:	68fa      	ldr	r2, [r7, #12]
 8001f0a:	ea02 0303 	and.w	r3, r2, r3
 8001f0e:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8001f10:	78f9      	ldrb	r1, [r7, #3]
 8001f12:	78bb      	ldrb	r3, [r7, #2]
 8001f14:	f103 32ff 	add.w	r2, r3, #4294967295
 8001f18:	4613      	mov	r3, r2
 8001f1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f1e:	189b      	adds	r3, r3, r2
 8001f20:	fa01 f303 	lsl.w	r3, r1, r3
 8001f24:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8001f26:	68fa      	ldr	r2, [r7, #12]
 8001f28:	68bb      	ldr	r3, [r7, #8]
 8001f2a:	ea42 0303 	orr.w	r3, r2, r3
 8001f2e:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8001f30:	687b      	ldr	r3, [r7, #4]
 8001f32:	68fa      	ldr	r2, [r7, #12]
 8001f34:	635a      	str	r2, [r3, #52]	; 0x34
 8001f36:	e055      	b.n	8001fe4 <ADC_RegularChannelConfig+0x1c4>
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 8001f38:	78bb      	ldrb	r3, [r7, #2]
 8001f3a:	2b0c      	cmp	r3, #12
 8001f3c:	d829      	bhi.n	8001f92 <ADC_RegularChannelConfig+0x172>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8001f3e:	687b      	ldr	r3, [r7, #4]
 8001f40:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f42:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8001f44:	78ba      	ldrb	r2, [r7, #2]
 8001f46:	4613      	mov	r3, r2
 8001f48:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f4c:	189b      	adds	r3, r3, r2
 8001f4e:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 8001f52:	f04f 021f 	mov.w	r2, #31
 8001f56:	fa02 f303 	lsl.w	r3, r2, r3
 8001f5a:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8001f5c:	68bb      	ldr	r3, [r7, #8]
 8001f5e:	ea6f 0303 	mvn.w	r3, r3
 8001f62:	68fa      	ldr	r2, [r7, #12]
 8001f64:	ea02 0303 	and.w	r3, r2, r3
 8001f68:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8001f6a:	78f9      	ldrb	r1, [r7, #3]
 8001f6c:	78ba      	ldrb	r2, [r7, #2]
 8001f6e:	4613      	mov	r3, r2
 8001f70:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001f74:	189b      	adds	r3, r3, r2
 8001f76:	f1a3 0323 	sub.w	r3, r3, #35	; 0x23
 8001f7a:	fa01 f303 	lsl.w	r3, r1, r3
 8001f7e:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8001f80:	68fa      	ldr	r2, [r7, #12]
 8001f82:	68bb      	ldr	r3, [r7, #8]
 8001f84:	ea42 0303 	orr.w	r3, r2, r3
 8001f88:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8001f8a:	687b      	ldr	r3, [r7, #4]
 8001f8c:	68fa      	ldr	r2, [r7, #12]
 8001f8e:	631a      	str	r2, [r3, #48]	; 0x30
 8001f90:	e028      	b.n	8001fe4 <ADC_RegularChannelConfig+0x1c4>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8001f92:	687b      	ldr	r3, [r7, #4]
 8001f94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f96:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8001f98:	78ba      	ldrb	r2, [r7, #2]
 8001f9a:	4613      	mov	r3, r2
 8001f9c:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fa0:	189b      	adds	r3, r3, r2
 8001fa2:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 8001fa6:	f04f 021f 	mov.w	r2, #31
 8001faa:	fa02 f303 	lsl.w	r3, r2, r3
 8001fae:	60bb      	str	r3, [r7, #8]
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8001fb0:	68bb      	ldr	r3, [r7, #8]
 8001fb2:	ea6f 0303 	mvn.w	r3, r3
 8001fb6:	68fa      	ldr	r2, [r7, #12]
 8001fb8:	ea02 0303 	and.w	r3, r2, r3
 8001fbc:	60fb      	str	r3, [r7, #12]
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8001fbe:	78f9      	ldrb	r1, [r7, #3]
 8001fc0:	78ba      	ldrb	r2, [r7, #2]
 8001fc2:	4613      	mov	r3, r2
 8001fc4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001fc8:	189b      	adds	r3, r3, r2
 8001fca:	f1a3 0341 	sub.w	r3, r3, #65	; 0x41
 8001fce:	fa01 f303 	lsl.w	r3, r1, r3
 8001fd2:	60bb      	str	r3, [r7, #8]
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8001fd4:	68fa      	ldr	r2, [r7, #12]
 8001fd6:	68bb      	ldr	r3, [r7, #8]
 8001fd8:	ea42 0303 	orr.w	r3, r2, r3
 8001fdc:	60fb      	str	r3, [r7, #12]
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8001fde:	687b      	ldr	r3, [r7, #4]
 8001fe0:	68fa      	ldr	r2, [r7, #12]
 8001fe2:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
 8001fe4:	f107 0714 	add.w	r7, r7, #20
 8001fe8:	46bd      	mov	sp, r7
 8001fea:	bc80      	pop	{r7}
 8001fec:	4770      	bx	lr
 8001fee:	bf00      	nop

08001ff0 <ADC_SoftwareStartConv>:
  * @brief  Enables the selected ADC software start conversion of the regular channels.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval None
  */
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
{
 8001ff0:	b480      	push	{r7}
 8001ff2:	b083      	sub	sp, #12
 8001ff4:	af00      	add	r7, sp, #0
 8001ff6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8001ff8:	687b      	ldr	r3, [r7, #4]
 8001ffa:	689b      	ldr	r3, [r3, #8]
 8001ffc:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8002000:	687b      	ldr	r3, [r7, #4]
 8002002:	609a      	str	r2, [r3, #8]
}
 8002004:	f107 070c 	add.w	r7, r7, #12
 8002008:	46bd      	mov	sp, r7
 800200a:	bc80      	pop	{r7}
 800200c:	4770      	bx	lr
 800200e:	bf00      	nop

08002010 <ADC_GetConversionValue>:
  * @brief  Returns the last ADCx conversion result data for regular channel.
  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
  * @retval The Data conversion value.
  */
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
 8002010:	b480      	push	{r7}
 8002012:	b083      	sub	sp, #12
 8002014:	af00      	add	r7, sp, #0
 8002016:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8002018:	687b      	ldr	r3, [r7, #4]
 800201a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800201c:	b29b      	uxth	r3, r3
}
 800201e:	4618      	mov	r0, r3
 8002020:	f107 070c 	add.w	r7, r7, #12
 8002024:	46bd      	mov	sp, r7
 8002026:	bc80      	pop	{r7}
 8002028:	4770      	bx	lr
 800202a:	bf00      	nop

0800202c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 800202c:	b480      	push	{r7}
 800202e:	b087      	sub	sp, #28
 8002030:	af00      	add	r7, sp, #0
 8002032:	6078      	str	r0, [r7, #4]
 8002034:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8002036:	f04f 0300 	mov.w	r3, #0
 800203a:	617b      	str	r3, [r7, #20]
 800203c:	f04f 0300 	mov.w	r3, #0
 8002040:	613b      	str	r3, [r7, #16]
 8002042:	f04f 0300 	mov.w	r3, #0
 8002046:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002048:	f04f 0300 	mov.w	r3, #0
 800204c:	617b      	str	r3, [r7, #20]
 800204e:	e087      	b.n	8002160 <GPIO_Init+0x134>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8002050:	697b      	ldr	r3, [r7, #20]
 8002052:	f04f 0201 	mov.w	r2, #1
 8002056:	fa02 f303 	lsl.w	r3, r2, r3
 800205a:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800205c:	683b      	ldr	r3, [r7, #0]
 800205e:	681a      	ldr	r2, [r3, #0]
 8002060:	693b      	ldr	r3, [r7, #16]
 8002062:	ea02 0303 	and.w	r3, r2, r3
 8002066:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8002068:	68fa      	ldr	r2, [r7, #12]
 800206a:	693b      	ldr	r3, [r7, #16]
 800206c:	429a      	cmp	r2, r3
 800206e:	d173      	bne.n	8002158 <GPIO_Init+0x12c>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002070:	687b      	ldr	r3, [r7, #4]
 8002072:	681a      	ldr	r2, [r3, #0]
 8002074:	697b      	ldr	r3, [r7, #20]
 8002076:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800207a:	f04f 0103 	mov.w	r1, #3
 800207e:	fa01 f303 	lsl.w	r3, r1, r3
 8002082:	ea6f 0303 	mvn.w	r3, r3
 8002086:	401a      	ands	r2, r3
 8002088:	687b      	ldr	r3, [r7, #4]
 800208a:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800208c:	687b      	ldr	r3, [r7, #4]
 800208e:	681a      	ldr	r2, [r3, #0]
 8002090:	683b      	ldr	r3, [r7, #0]
 8002092:	791b      	ldrb	r3, [r3, #4]
 8002094:	4619      	mov	r1, r3
 8002096:	697b      	ldr	r3, [r7, #20]
 8002098:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800209c:	fa01 f303 	lsl.w	r3, r1, r3
 80020a0:	431a      	orrs	r2, r3
 80020a2:	687b      	ldr	r3, [r7, #4]
 80020a4:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80020a6:	683b      	ldr	r3, [r7, #0]
 80020a8:	791b      	ldrb	r3, [r3, #4]
 80020aa:	2b01      	cmp	r3, #1
 80020ac:	d003      	beq.n	80020b6 <GPIO_Init+0x8a>
 80020ae:	683b      	ldr	r3, [r7, #0]
 80020b0:	791b      	ldrb	r3, [r3, #4]
 80020b2:	2b02      	cmp	r3, #2
 80020b4:	d134      	bne.n	8002120 <GPIO_Init+0xf4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80020b6:	687b      	ldr	r3, [r7, #4]
 80020b8:	689a      	ldr	r2, [r3, #8]
 80020ba:	697b      	ldr	r3, [r7, #20]
 80020bc:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80020c0:	f04f 0103 	mov.w	r1, #3
 80020c4:	fa01 f303 	lsl.w	r3, r1, r3
 80020c8:	ea6f 0303 	mvn.w	r3, r3
 80020cc:	401a      	ands	r2, r3
 80020ce:	687b      	ldr	r3, [r7, #4]
 80020d0:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	689a      	ldr	r2, [r3, #8]
 80020d6:	683b      	ldr	r3, [r7, #0]
 80020d8:	795b      	ldrb	r3, [r3, #5]
 80020da:	4619      	mov	r1, r3
 80020dc:	697b      	ldr	r3, [r7, #20]
 80020de:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80020e2:	fa01 f303 	lsl.w	r3, r1, r3
 80020e6:	431a      	orrs	r2, r3
 80020e8:	687b      	ldr	r3, [r7, #4]
 80020ea:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 80020ec:	687b      	ldr	r3, [r7, #4]
 80020ee:	685a      	ldr	r2, [r3, #4]
 80020f0:	697b      	ldr	r3, [r7, #20]
 80020f2:	b29b      	uxth	r3, r3
 80020f4:	f04f 0101 	mov.w	r1, #1
 80020f8:	fa01 f303 	lsl.w	r3, r1, r3
 80020fc:	ea6f 0303 	mvn.w	r3, r3
 8002100:	401a      	ands	r2, r3
 8002102:	687b      	ldr	r3, [r7, #4]
 8002104:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8002106:	687b      	ldr	r3, [r7, #4]
 8002108:	685a      	ldr	r2, [r3, #4]
 800210a:	683b      	ldr	r3, [r7, #0]
 800210c:	799b      	ldrb	r3, [r3, #6]
 800210e:	4619      	mov	r1, r3
 8002110:	697b      	ldr	r3, [r7, #20]
 8002112:	b29b      	uxth	r3, r3
 8002114:	fa01 f303 	lsl.w	r3, r1, r3
 8002118:	b29b      	uxth	r3, r3
 800211a:	431a      	orrs	r2, r3
 800211c:	687b      	ldr	r3, [r7, #4]
 800211e:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8002120:	687b      	ldr	r3, [r7, #4]
 8002122:	68da      	ldr	r2, [r3, #12]
 8002124:	697b      	ldr	r3, [r7, #20]
 8002126:	b29b      	uxth	r3, r3
 8002128:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800212c:	f04f 0103 	mov.w	r1, #3
 8002130:	fa01 f303 	lsl.w	r3, r1, r3
 8002134:	ea6f 0303 	mvn.w	r3, r3
 8002138:	401a      	ands	r2, r3
 800213a:	687b      	ldr	r3, [r7, #4]
 800213c:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800213e:	687b      	ldr	r3, [r7, #4]
 8002140:	68da      	ldr	r2, [r3, #12]
 8002142:	683b      	ldr	r3, [r7, #0]
 8002144:	79db      	ldrb	r3, [r3, #7]
 8002146:	4619      	mov	r1, r3
 8002148:	697b      	ldr	r3, [r7, #20]
 800214a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800214e:	fa01 f303 	lsl.w	r3, r1, r3
 8002152:	431a      	orrs	r2, r3
 8002154:	687b      	ldr	r3, [r7, #4]
 8002156:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002158:	697b      	ldr	r3, [r7, #20]
 800215a:	f103 0301 	add.w	r3, r3, #1
 800215e:	617b      	str	r3, [r7, #20]
 8002160:	697b      	ldr	r3, [r7, #20]
 8002162:	2b0f      	cmp	r3, #15
 8002164:	f67f af74 	bls.w	8002050 <GPIO_Init+0x24>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8002168:	f107 071c 	add.w	r7, r7, #28
 800216c:	46bd      	mov	sp, r7
 800216e:	bc80      	pop	{r7}
 8002170:	4770      	bx	lr
 8002172:	bf00      	nop

08002174 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8002174:	b480      	push	{r7}
 8002176:	b085      	sub	sp, #20
 8002178:	af00      	add	r7, sp, #0
 800217a:	6078      	str	r0, [r7, #4]
 800217c:	4613      	mov	r3, r2
 800217e:	460a      	mov	r2, r1
 8002180:	807a      	strh	r2, [r7, #2]
 8002182:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8002184:	f04f 0300 	mov.w	r3, #0
 8002188:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 800218a:	f04f 0300 	mov.w	r3, #0
 800218e:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002190:	787a      	ldrb	r2, [r7, #1]
 8002192:	887b      	ldrh	r3, [r7, #2]
 8002194:	f003 0307 	and.w	r3, r3, #7
 8002198:	ea4f 0383 	mov.w	r3, r3, lsl #2
 800219c:	fa02 f303 	lsl.w	r3, r2, r3
 80021a0:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 80021a2:	887b      	ldrh	r3, [r7, #2]
 80021a4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80021a8:	b29b      	uxth	r3, r3
 80021aa:	461a      	mov	r2, r3
 80021ac:	887b      	ldrh	r3, [r7, #2]
 80021ae:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80021b2:	b29b      	uxth	r3, r3
 80021b4:	4619      	mov	r1, r3
 80021b6:	687b      	ldr	r3, [r7, #4]
 80021b8:	f101 0108 	add.w	r1, r1, #8
 80021bc:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 80021c0:	887b      	ldrh	r3, [r7, #2]
 80021c2:	f003 0307 	and.w	r3, r3, #7
 80021c6:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80021ca:	f04f 000f 	mov.w	r0, #15
 80021ce:	fa00 f303 	lsl.w	r3, r0, r3
 80021d2:	ea6f 0303 	mvn.w	r3, r3
 80021d6:	4019      	ands	r1, r3
 80021d8:	687b      	ldr	r3, [r7, #4]
 80021da:	f102 0208 	add.w	r2, r2, #8
 80021de:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80021e2:	887b      	ldrh	r3, [r7, #2]
 80021e4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 80021e8:	b29b      	uxth	r3, r3
 80021ea:	461a      	mov	r2, r3
 80021ec:	687b      	ldr	r3, [r7, #4]
 80021ee:	f102 0208 	add.w	r2, r2, #8
 80021f2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80021f6:	68fb      	ldr	r3, [r7, #12]
 80021f8:	ea42 0303 	orr.w	r3, r2, r3
 80021fc:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80021fe:	887b      	ldrh	r3, [r7, #2]
 8002200:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 8002204:	b29b      	uxth	r3, r3
 8002206:	461a      	mov	r2, r3
 8002208:	687b      	ldr	r3, [r7, #4]
 800220a:	f102 0208 	add.w	r2, r2, #8
 800220e:	68b9      	ldr	r1, [r7, #8]
 8002210:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8002214:	f107 0714 	add.w	r7, r7, #20
 8002218:	46bd      	mov	sp, r7
 800221a:	bc80      	pop	{r7}
 800221c:	4770      	bx	lr
 800221e:	bf00      	nop

08002220 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8002220:	b480      	push	{r7}
 8002222:	b089      	sub	sp, #36	; 0x24
 8002224:	af00      	add	r7, sp, #0
 8002226:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8002228:	f04f 0300 	mov.w	r3, #0
 800222c:	61bb      	str	r3, [r7, #24]
 800222e:	f04f 0300 	mov.w	r3, #0
 8002232:	617b      	str	r3, [r7, #20]
 8002234:	f04f 0300 	mov.w	r3, #0
 8002238:	61fb      	str	r3, [r7, #28]
 800223a:	f04f 0302 	mov.w	r3, #2
 800223e:	613b      	str	r3, [r7, #16]
 8002240:	f04f 0300 	mov.w	r3, #0
 8002244:	60fb      	str	r3, [r7, #12]
 8002246:	f04f 0302 	mov.w	r3, #2
 800224a:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800224c:	4b4f      	ldr	r3, [pc, #316]	; (800238c <RCC_GetClocksFreq+0x16c>)
 800224e:	689b      	ldr	r3, [r3, #8]
 8002250:	f003 030c 	and.w	r3, r3, #12
 8002254:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8002256:	69bb      	ldr	r3, [r7, #24]
 8002258:	2b04      	cmp	r3, #4
 800225a:	d007      	beq.n	800226c <RCC_GetClocksFreq+0x4c>
 800225c:	2b08      	cmp	r3, #8
 800225e:	d009      	beq.n	8002274 <RCC_GetClocksFreq+0x54>
 8002260:	2b00      	cmp	r3, #0
 8002262:	d147      	bne.n	80022f4 <RCC_GetClocksFreq+0xd4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002264:	687b      	ldr	r3, [r7, #4]
 8002266:	4a4a      	ldr	r2, [pc, #296]	; (8002390 <RCC_GetClocksFreq+0x170>)
 8002268:	601a      	str	r2, [r3, #0]
      break;
 800226a:	e047      	b.n	80022fc <RCC_GetClocksFreq+0xdc>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 800226c:	687b      	ldr	r3, [r7, #4]
 800226e:	4a49      	ldr	r2, [pc, #292]	; (8002394 <RCC_GetClocksFreq+0x174>)
 8002270:	601a      	str	r2, [r3, #0]
      break;
 8002272:	e043      	b.n	80022fc <RCC_GetClocksFreq+0xdc>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8002274:	4b45      	ldr	r3, [pc, #276]	; (800238c <RCC_GetClocksFreq+0x16c>)
 8002276:	685b      	ldr	r3, [r3, #4]
 8002278:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800227c:	ea4f 5393 	mov.w	r3, r3, lsr #22
 8002280:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002282:	4b42      	ldr	r3, [pc, #264]	; (800238c <RCC_GetClocksFreq+0x16c>)
 8002284:	685b      	ldr	r3, [r3, #4]
 8002286:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800228a:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 800228c:	68fb      	ldr	r3, [r7, #12]
 800228e:	2b00      	cmp	r3, #0
 8002290:	d00f      	beq.n	80022b2 <RCC_GetClocksFreq+0x92>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8002292:	4a40      	ldr	r2, [pc, #256]	; (8002394 <RCC_GetClocksFreq+0x174>)
 8002294:	68bb      	ldr	r3, [r7, #8]
 8002296:	fbb2 f2f3 	udiv	r2, r2, r3
 800229a:	4b3c      	ldr	r3, [pc, #240]	; (800238c <RCC_GetClocksFreq+0x16c>)
 800229c:	6859      	ldr	r1, [r3, #4]
 800229e:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80022a2:	ea01 0303 	and.w	r3, r1, r3
 80022a6:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80022aa:	fb03 f302 	mul.w	r3, r3, r2
 80022ae:	61fb      	str	r3, [r7, #28]
 80022b0:	e00e      	b.n	80022d0 <RCC_GetClocksFreq+0xb0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80022b2:	4a37      	ldr	r2, [pc, #220]	; (8002390 <RCC_GetClocksFreq+0x170>)
 80022b4:	68bb      	ldr	r3, [r7, #8]
 80022b6:	fbb2 f2f3 	udiv	r2, r2, r3
 80022ba:	4b34      	ldr	r3, [pc, #208]	; (800238c <RCC_GetClocksFreq+0x16c>)
 80022bc:	6859      	ldr	r1, [r3, #4]
 80022be:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80022c2:	ea01 0303 	and.w	r3, r1, r3
 80022c6:	ea4f 1393 	mov.w	r3, r3, lsr #6
 80022ca:	fb03 f302 	mul.w	r3, r3, r2
 80022ce:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80022d0:	4b2e      	ldr	r3, [pc, #184]	; (800238c <RCC_GetClocksFreq+0x16c>)
 80022d2:	685b      	ldr	r3, [r3, #4]
 80022d4:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80022d8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80022dc:	f103 0301 	add.w	r3, r3, #1
 80022e0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80022e4:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 80022e6:	69fa      	ldr	r2, [r7, #28]
 80022e8:	693b      	ldr	r3, [r7, #16]
 80022ea:	fbb2 f2f3 	udiv	r2, r2, r3
 80022ee:	687b      	ldr	r3, [r7, #4]
 80022f0:	601a      	str	r2, [r3, #0]
      break;
 80022f2:	e003      	b.n	80022fc <RCC_GetClocksFreq+0xdc>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80022f4:	687b      	ldr	r3, [r7, #4]
 80022f6:	4a26      	ldr	r2, [pc, #152]	; (8002390 <RCC_GetClocksFreq+0x170>)
 80022f8:	601a      	str	r2, [r3, #0]
      break;
 80022fa:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80022fc:	4b23      	ldr	r3, [pc, #140]	; (800238c <RCC_GetClocksFreq+0x16c>)
 80022fe:	689b      	ldr	r3, [r3, #8]
 8002300:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002304:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8002306:	69bb      	ldr	r3, [r7, #24]
 8002308:	ea4f 1313 	mov.w	r3, r3, lsr #4
 800230c:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800230e:	4a22      	ldr	r2, [pc, #136]	; (8002398 <RCC_GetClocksFreq+0x178>)
 8002310:	69bb      	ldr	r3, [r7, #24]
 8002312:	18d3      	adds	r3, r2, r3
 8002314:	781b      	ldrb	r3, [r3, #0]
 8002316:	b2db      	uxtb	r3, r3
 8002318:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 800231a:	687b      	ldr	r3, [r7, #4]
 800231c:	681a      	ldr	r2, [r3, #0]
 800231e:	697b      	ldr	r3, [r7, #20]
 8002320:	fa22 f203 	lsr.w	r2, r2, r3
 8002324:	687b      	ldr	r3, [r7, #4]
 8002326:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8002328:	4b18      	ldr	r3, [pc, #96]	; (800238c <RCC_GetClocksFreq+0x16c>)
 800232a:	689b      	ldr	r3, [r3, #8]
 800232c:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8002330:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 8002332:	69bb      	ldr	r3, [r7, #24]
 8002334:	ea4f 2393 	mov.w	r3, r3, lsr #10
 8002338:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800233a:	4a17      	ldr	r2, [pc, #92]	; (8002398 <RCC_GetClocksFreq+0x178>)
 800233c:	69bb      	ldr	r3, [r7, #24]
 800233e:	18d3      	adds	r3, r2, r3
 8002340:	781b      	ldrb	r3, [r3, #0]
 8002342:	b2db      	uxtb	r3, r3
 8002344:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002346:	687b      	ldr	r3, [r7, #4]
 8002348:	685a      	ldr	r2, [r3, #4]
 800234a:	697b      	ldr	r3, [r7, #20]
 800234c:	fa22 f203 	lsr.w	r2, r2, r3
 8002350:	687b      	ldr	r3, [r7, #4]
 8002352:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8002354:	4b0d      	ldr	r3, [pc, #52]	; (800238c <RCC_GetClocksFreq+0x16c>)
 8002356:	689b      	ldr	r3, [r3, #8]
 8002358:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 800235c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 800235e:	69bb      	ldr	r3, [r7, #24]
 8002360:	ea4f 3353 	mov.w	r3, r3, lsr #13
 8002364:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002366:	4a0c      	ldr	r2, [pc, #48]	; (8002398 <RCC_GetClocksFreq+0x178>)
 8002368:	69bb      	ldr	r3, [r7, #24]
 800236a:	18d3      	adds	r3, r2, r3
 800236c:	781b      	ldrb	r3, [r3, #0]
 800236e:	b2db      	uxtb	r3, r3
 8002370:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002372:	687b      	ldr	r3, [r7, #4]
 8002374:	685a      	ldr	r2, [r3, #4]
 8002376:	697b      	ldr	r3, [r7, #20]
 8002378:	fa22 f203 	lsr.w	r2, r2, r3
 800237c:	687b      	ldr	r3, [r7, #4]
 800237e:	60da      	str	r2, [r3, #12]
}
 8002380:	f107 0724 	add.w	r7, r7, #36	; 0x24
 8002384:	46bd      	mov	sp, r7
 8002386:	bc80      	pop	{r7}
 8002388:	4770      	bx	lr
 800238a:	bf00      	nop
 800238c:	40023800 	.word	0x40023800
 8002390:	00f42400 	.word	0x00f42400
 8002394:	007a1200 	.word	0x007a1200
 8002398:	20000534 	.word	0x20000534

0800239c <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 800239c:	b480      	push	{r7}
 800239e:	b083      	sub	sp, #12
 80023a0:	af00      	add	r7, sp, #0
 80023a2:	6078      	str	r0, [r7, #4]
 80023a4:	460b      	mov	r3, r1
 80023a6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80023a8:	78fb      	ldrb	r3, [r7, #3]
 80023aa:	2b00      	cmp	r3, #0
 80023ac:	d007      	beq.n	80023be <RCC_AHB1PeriphClockCmd+0x22>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80023ae:	4b0b      	ldr	r3, [pc, #44]	; (80023dc <RCC_AHB1PeriphClockCmd+0x40>)
 80023b0:	4a0a      	ldr	r2, [pc, #40]	; (80023dc <RCC_AHB1PeriphClockCmd+0x40>)
 80023b2:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80023b4:	687a      	ldr	r2, [r7, #4]
 80023b6:	ea41 0202 	orr.w	r2, r1, r2
 80023ba:	631a      	str	r2, [r3, #48]	; 0x30
 80023bc:	e008      	b.n	80023d0 <RCC_AHB1PeriphClockCmd+0x34>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80023be:	4b07      	ldr	r3, [pc, #28]	; (80023dc <RCC_AHB1PeriphClockCmd+0x40>)
 80023c0:	4a06      	ldr	r2, [pc, #24]	; (80023dc <RCC_AHB1PeriphClockCmd+0x40>)
 80023c2:	6b11      	ldr	r1, [r2, #48]	; 0x30
 80023c4:	687a      	ldr	r2, [r7, #4]
 80023c6:	ea6f 0202 	mvn.w	r2, r2
 80023ca:	ea01 0202 	and.w	r2, r1, r2
 80023ce:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 80023d0:	f107 070c 	add.w	r7, r7, #12
 80023d4:	46bd      	mov	sp, r7
 80023d6:	bc80      	pop	{r7}
 80023d8:	4770      	bx	lr
 80023da:	bf00      	nop
 80023dc:	40023800 	.word	0x40023800

080023e0 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80023e0:	b480      	push	{r7}
 80023e2:	b083      	sub	sp, #12
 80023e4:	af00      	add	r7, sp, #0
 80023e6:	6078      	str	r0, [r7, #4]
 80023e8:	460b      	mov	r3, r1
 80023ea:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80023ec:	78fb      	ldrb	r3, [r7, #3]
 80023ee:	2b00      	cmp	r3, #0
 80023f0:	d007      	beq.n	8002402 <RCC_APB1PeriphClockCmd+0x22>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80023f2:	4b0b      	ldr	r3, [pc, #44]	; (8002420 <RCC_APB1PeriphClockCmd+0x40>)
 80023f4:	4a0a      	ldr	r2, [pc, #40]	; (8002420 <RCC_APB1PeriphClockCmd+0x40>)
 80023f6:	6c11      	ldr	r1, [r2, #64]	; 0x40
 80023f8:	687a      	ldr	r2, [r7, #4]
 80023fa:	ea41 0202 	orr.w	r2, r1, r2
 80023fe:	641a      	str	r2, [r3, #64]	; 0x40
 8002400:	e008      	b.n	8002414 <RCC_APB1PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8002402:	4b07      	ldr	r3, [pc, #28]	; (8002420 <RCC_APB1PeriphClockCmd+0x40>)
 8002404:	4a06      	ldr	r2, [pc, #24]	; (8002420 <RCC_APB1PeriphClockCmd+0x40>)
 8002406:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002408:	687a      	ldr	r2, [r7, #4]
 800240a:	ea6f 0202 	mvn.w	r2, r2
 800240e:	ea01 0202 	and.w	r2, r1, r2
 8002412:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 8002414:	f107 070c 	add.w	r7, r7, #12
 8002418:	46bd      	mov	sp, r7
 800241a:	bc80      	pop	{r7}
 800241c:	4770      	bx	lr
 800241e:	bf00      	nop
 8002420:	40023800 	.word	0x40023800

08002424 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8002424:	b480      	push	{r7}
 8002426:	b083      	sub	sp, #12
 8002428:	af00      	add	r7, sp, #0
 800242a:	6078      	str	r0, [r7, #4]
 800242c:	460b      	mov	r3, r1
 800242e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002430:	78fb      	ldrb	r3, [r7, #3]
 8002432:	2b00      	cmp	r3, #0
 8002434:	d007      	beq.n	8002446 <RCC_APB2PeriphClockCmd+0x22>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8002436:	4b0b      	ldr	r3, [pc, #44]	; (8002464 <RCC_APB2PeriphClockCmd+0x40>)
 8002438:	4a0a      	ldr	r2, [pc, #40]	; (8002464 <RCC_APB2PeriphClockCmd+0x40>)
 800243a:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800243c:	687a      	ldr	r2, [r7, #4]
 800243e:	ea41 0202 	orr.w	r2, r1, r2
 8002442:	645a      	str	r2, [r3, #68]	; 0x44
 8002444:	e008      	b.n	8002458 <RCC_APB2PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8002446:	4b07      	ldr	r3, [pc, #28]	; (8002464 <RCC_APB2PeriphClockCmd+0x40>)
 8002448:	4a06      	ldr	r2, [pc, #24]	; (8002464 <RCC_APB2PeriphClockCmd+0x40>)
 800244a:	6c51      	ldr	r1, [r2, #68]	; 0x44
 800244c:	687a      	ldr	r2, [r7, #4]
 800244e:	ea6f 0202 	mvn.w	r2, r2
 8002452:	ea01 0202 	and.w	r2, r1, r2
 8002456:	645a      	str	r2, [r3, #68]	; 0x44
  }
}
 8002458:	f107 070c 	add.w	r7, r7, #12
 800245c:	46bd      	mov	sp, r7
 800245e:	bc80      	pop	{r7}
 8002460:	4770      	bx	lr
 8002462:	bf00      	nop
 8002464:	40023800 	.word	0x40023800

08002468 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8002468:	b580      	push	{r7, lr}
 800246a:	b08a      	sub	sp, #40	; 0x28
 800246c:	af00      	add	r7, sp, #0
 800246e:	6078      	str	r0, [r7, #4]
 8002470:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8002472:	f04f 0300 	mov.w	r3, #0
 8002476:	627b      	str	r3, [r7, #36]	; 0x24
 8002478:	f04f 0300 	mov.w	r3, #0
 800247c:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 800247e:	f04f 0300 	mov.w	r3, #0
 8002482:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 8002484:	f04f 0300 	mov.w	r3, #0
 8002488:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 800248a:	687b      	ldr	r3, [r7, #4]
 800248c:	8a1b      	ldrh	r3, [r3, #16]
 800248e:	b29b      	uxth	r3, r3
 8002490:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8002492:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002494:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8002498:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 800249a:	683b      	ldr	r3, [r7, #0]
 800249c:	88db      	ldrh	r3, [r3, #6]
 800249e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80024a0:	ea42 0303 	orr.w	r3, r2, r3
 80024a4:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80024a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80024a8:	b29a      	uxth	r2, r3
 80024aa:	687b      	ldr	r3, [r7, #4]
 80024ac:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80024ae:	687b      	ldr	r3, [r7, #4]
 80024b0:	899b      	ldrh	r3, [r3, #12]
 80024b2:	b29b      	uxth	r3, r3
 80024b4:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 80024b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80024b8:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 80024bc:	f023 030c 	bic.w	r3, r3, #12
 80024c0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80024c2:	683b      	ldr	r3, [r7, #0]
 80024c4:	889a      	ldrh	r2, [r3, #4]
 80024c6:	683b      	ldr	r3, [r7, #0]
 80024c8:	891b      	ldrh	r3, [r3, #8]
 80024ca:	ea42 0303 	orr.w	r3, r2, r3
 80024ce:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 80024d0:	683b      	ldr	r3, [r7, #0]
 80024d2:	895b      	ldrh	r3, [r3, #10]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80024d4:	ea42 0303 	orr.w	r3, r2, r3
 80024d8:	b29b      	uxth	r3, r3
 80024da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80024dc:	ea42 0303 	orr.w	r3, r2, r3
 80024e0:	627b      	str	r3, [r7, #36]	; 0x24
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80024e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80024e4:	b29a      	uxth	r2, r3
 80024e6:	687b      	ldr	r3, [r7, #4]
 80024e8:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80024ea:	687b      	ldr	r3, [r7, #4]
 80024ec:	8a9b      	ldrh	r3, [r3, #20]
 80024ee:	b29b      	uxth	r3, r3
 80024f0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80024f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80024f4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80024f8:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80024fa:	683b      	ldr	r3, [r7, #0]
 80024fc:	899b      	ldrh	r3, [r3, #12]
 80024fe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002500:	ea42 0303 	orr.w	r3, r2, r3
 8002504:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8002506:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002508:	b29a      	uxth	r2, r3
 800250a:	687b      	ldr	r3, [r7, #4]
 800250c:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 800250e:	f107 0308 	add.w	r3, r7, #8
 8002512:	4618      	mov	r0, r3
 8002514:	f7ff fe84 	bl	8002220 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8002518:	687a      	ldr	r2, [r7, #4]
 800251a:	4b3a      	ldr	r3, [pc, #232]	; (8002604 <USART_Init+0x19c>)
 800251c:	429a      	cmp	r2, r3
 800251e:	d003      	beq.n	8002528 <USART_Init+0xc0>
 8002520:	687a      	ldr	r2, [r7, #4]
 8002522:	4b39      	ldr	r3, [pc, #228]	; (8002608 <USART_Init+0x1a0>)
 8002524:	429a      	cmp	r2, r3
 8002526:	d102      	bne.n	800252e <USART_Init+0xc6>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8002528:	697b      	ldr	r3, [r7, #20]
 800252a:	623b      	str	r3, [r7, #32]
 800252c:	e001      	b.n	8002532 <USART_Init+0xca>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 800252e:	693b      	ldr	r3, [r7, #16]
 8002530:	623b      	str	r3, [r7, #32]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8002532:	687b      	ldr	r3, [r7, #4]
 8002534:	899b      	ldrh	r3, [r3, #12]
 8002536:	b29b      	uxth	r3, r3
 8002538:	b29b      	uxth	r3, r3
 800253a:	b21b      	sxth	r3, r3
 800253c:	2b00      	cmp	r3, #0
 800253e:	da0f      	bge.n	8002560 <USART_Init+0xf8>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8002540:	6a3a      	ldr	r2, [r7, #32]
 8002542:	4613      	mov	r3, r2
 8002544:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002548:	189b      	adds	r3, r3, r2
 800254a:	ea4f 0283 	mov.w	r2, r3, lsl #2
 800254e:	189a      	adds	r2, r3, r2
 8002550:	683b      	ldr	r3, [r7, #0]
 8002552:	681b      	ldr	r3, [r3, #0]
 8002554:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8002558:	fbb2 f3f3 	udiv	r3, r2, r3
 800255c:	61fb      	str	r3, [r7, #28]
 800255e:	e00e      	b.n	800257e <USART_Init+0x116>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8002560:	6a3a      	ldr	r2, [r7, #32]
 8002562:	4613      	mov	r3, r2
 8002564:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002568:	189b      	adds	r3, r3, r2
 800256a:	ea4f 0283 	mov.w	r2, r3, lsl #2
 800256e:	189a      	adds	r2, r3, r2
 8002570:	683b      	ldr	r3, [r7, #0]
 8002572:	681b      	ldr	r3, [r3, #0]
 8002574:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8002578:	fbb2 f3f3 	udiv	r3, r2, r3
 800257c:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 800257e:	69fa      	ldr	r2, [r7, #28]
 8002580:	4b22      	ldr	r3, [pc, #136]	; (800260c <USART_Init+0x1a4>)
 8002582:	fba3 1302 	umull	r1, r3, r3, r2
 8002586:	ea4f 1353 	mov.w	r3, r3, lsr #5
 800258a:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800258e:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8002590:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002592:	ea4f 1313 	mov.w	r3, r3, lsr #4
 8002596:	f04f 0264 	mov.w	r2, #100	; 0x64
 800259a:	fb02 f303 	mul.w	r3, r2, r3
 800259e:	69fa      	ldr	r2, [r7, #28]
 80025a0:	1ad3      	subs	r3, r2, r3
 80025a2:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80025a4:	687b      	ldr	r3, [r7, #4]
 80025a6:	899b      	ldrh	r3, [r3, #12]
 80025a8:	b29b      	uxth	r3, r3
 80025aa:	b29b      	uxth	r3, r3
 80025ac:	b21b      	sxth	r3, r3
 80025ae:	2b00      	cmp	r3, #0
 80025b0:	da10      	bge.n	80025d4 <USART_Init+0x16c>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 80025b2:	69bb      	ldr	r3, [r7, #24]
 80025b4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80025b8:	f103 0232 	add.w	r2, r3, #50	; 0x32
 80025bc:	4b13      	ldr	r3, [pc, #76]	; (800260c <USART_Init+0x1a4>)
 80025be:	fba3 1302 	umull	r1, r3, r3, r2
 80025c2:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80025c6:	f003 0307 	and.w	r3, r3, #7
 80025ca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80025cc:	ea42 0303 	orr.w	r3, r2, r3
 80025d0:	627b      	str	r3, [r7, #36]	; 0x24
 80025d2:	e00f      	b.n	80025f4 <USART_Init+0x18c>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80025d4:	69bb      	ldr	r3, [r7, #24]
 80025d6:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80025da:	f103 0232 	add.w	r2, r3, #50	; 0x32
 80025de:	4b0b      	ldr	r3, [pc, #44]	; (800260c <USART_Init+0x1a4>)
 80025e0:	fba3 1302 	umull	r1, r3, r3, r2
 80025e4:	ea4f 1353 	mov.w	r3, r3, lsr #5
 80025e8:	f003 030f 	and.w	r3, r3, #15
 80025ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80025ee:	ea42 0303 	orr.w	r3, r2, r3
 80025f2:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80025f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80025f6:	b29a      	uxth	r2, r3
 80025f8:	687b      	ldr	r3, [r7, #4]
 80025fa:	811a      	strh	r2, [r3, #8]
}
 80025fc:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8002600:	46bd      	mov	sp, r7
 8002602:	bd80      	pop	{r7, pc}
 8002604:	40011000 	.word	0x40011000
 8002608:	40011400 	.word	0x40011400
 800260c:	51eb851f 	.word	0x51eb851f

08002610 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8002610:	b480      	push	{r7}
 8002612:	b083      	sub	sp, #12
 8002614:	af00      	add	r7, sp, #0
 8002616:	6078      	str	r0, [r7, #4]
 8002618:	460b      	mov	r3, r1
 800261a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800261c:	78fb      	ldrb	r3, [r7, #3]
 800261e:	2b00      	cmp	r3, #0
 8002620:	d008      	beq.n	8002634 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8002622:	687b      	ldr	r3, [r7, #4]
 8002624:	899b      	ldrh	r3, [r3, #12]
 8002626:	b29b      	uxth	r3, r3
 8002628:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800262c:	b29a      	uxth	r2, r3
 800262e:	687b      	ldr	r3, [r7, #4]
 8002630:	819a      	strh	r2, [r3, #12]
 8002632:	e007      	b.n	8002644 <USART_Cmd+0x34>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8002634:	687b      	ldr	r3, [r7, #4]
 8002636:	899b      	ldrh	r3, [r3, #12]
 8002638:	b29b      	uxth	r3, r3
 800263a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800263e:	b29a      	uxth	r2, r3
 8002640:	687b      	ldr	r3, [r7, #4]
 8002642:	819a      	strh	r2, [r3, #12]
  }
}
 8002644:	f107 070c 	add.w	r7, r7, #12
 8002648:	46bd      	mov	sp, r7
 800264a:	bc80      	pop	{r7}
 800264c:	4770      	bx	lr
 800264e:	bf00      	nop

08002650 <USART_SendData>:
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8002650:	b480      	push	{r7}
 8002652:	b083      	sub	sp, #12
 8002654:	af00      	add	r7, sp, #0
 8002656:	6078      	str	r0, [r7, #4]
 8002658:	460b      	mov	r3, r1
 800265a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 800265c:	887b      	ldrh	r3, [r7, #2]
 800265e:	ea4f 53c3 	mov.w	r3, r3, lsl #23
 8002662:	ea4f 53d3 	mov.w	r3, r3, lsr #23
 8002666:	b29a      	uxth	r2, r3
 8002668:	687b      	ldr	r3, [r7, #4]
 800266a:	809a      	strh	r2, [r3, #4]
}
 800266c:	f107 070c 	add.w	r7, r7, #12
 8002670:	46bd      	mov	sp, r7
 8002672:	bc80      	pop	{r7}
 8002674:	4770      	bx	lr
 8002676:	bf00      	nop

08002678 <USART_GetFlagStatus>:
  *            @arg USART_FLAG_FE:   Framing Error flag
  *            @arg USART_FLAG_PE:   Parity Error flag
  * @retval The new state of USART_FLAG (SET or RESET).
  */
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8002678:	b480      	push	{r7}
 800267a:	b085      	sub	sp, #20
 800267c:	af00      	add	r7, sp, #0
 800267e:	6078      	str	r0, [r7, #4]
 8002680:	460b      	mov	r3, r1
 8002682:	807b      	strh	r3, [r7, #2]
  FlagStatus bitstatus = RESET;
 8002684:	f04f 0300 	mov.w	r3, #0
 8002688:	73fb      	strb	r3, [r7, #15]
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 800268a:	687b      	ldr	r3, [r7, #4]
 800268c:	881b      	ldrh	r3, [r3, #0]
 800268e:	b29a      	uxth	r2, r3
 8002690:	887b      	ldrh	r3, [r7, #2]
 8002692:	ea02 0303 	and.w	r3, r2, r3
 8002696:	b29b      	uxth	r3, r3
 8002698:	2b00      	cmp	r3, #0
 800269a:	d003      	beq.n	80026a4 <USART_GetFlagStatus+0x2c>
  {
    bitstatus = SET;
 800269c:	f04f 0301 	mov.w	r3, #1
 80026a0:	73fb      	strb	r3, [r7, #15]
 80026a2:	e002      	b.n	80026aa <USART_GetFlagStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
 80026a4:	f04f 0300 	mov.w	r3, #0
 80026a8:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80026aa:	7bfb      	ldrb	r3, [r7, #15]
}
 80026ac:	4618      	mov	r0, r3
 80026ae:	f107 0714 	add.w	r7, r7, #20
 80026b2:	46bd      	mov	sp, r7
 80026b4:	bc80      	pop	{r7}
 80026b6:	4770      	bx	lr
 80026b8:	54636441 	.word	0x54636441
 80026bc:	006b7361 	.word	0x006b7361
 80026c0:	454c4449 	.word	0x454c4449
 80026c4:	00000000 	.word	0x00000000
 80026c8:	00000a0d 	.word	0x00000a0d
 80026cc:	20207525 	.word	0x20207525
 80026d0:	20206325 	.word	0x20206325
 80026d4:	36312d25 	.word	0x36312d25
 80026d8:	20202073 	.word	0x20202073
 80026dc:	20202020 	.word	0x20202020
 80026e0:	30202020 	.word	0x30202020
 80026e4:	30202020 	.word	0x30202020
 80026e8:	20202525 	.word	0x20202525
 80026ec:	0d753525 	.word	0x0d753525
 80026f0:	0000000a 	.word	0x0000000a
 80026f4:	20207525 	.word	0x20207525
 80026f8:	20206325 	.word	0x20206325
 80026fc:	36312d25 	.word	0x36312d25
 8002700:	31252073 	.word	0x31252073
 8002704:	25207530 	.word	0x25207530
 8002708:	25257533 	.word	0x25257533
 800270c:	35252020 	.word	0x35252020
 8002710:	000a0d75 	.word	0x000a0d75
 8002714:	20207525 	.word	0x20207525
 8002718:	20206325 	.word	0x20206325
 800271c:	36312d25 	.word	0x36312d25
 8002720:	31252073 	.word	0x31252073
 8002724:	20207530 	.word	0x20207530
 8002728:	2525313c 	.word	0x2525313c
 800272c:	35252020 	.word	0x35252020
 8002730:	000a0d75 	.word	0x000a0d75
 8002734:	00000043 	.word	0x00000043

08002738 <_init>:
 8002738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800273a:	bf00      	nop
 800273c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800273e:	bc08      	pop	{r3}
 8002740:	469e      	mov	lr, r3
 8002742:	4770      	bx	lr

08002744 <_fini>:
 8002744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002746:	bf00      	nop
 8002748:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800274a:	bc08      	pop	{r3}
 800274c:	469e      	mov	lr, r3
 800274e:	4770      	bx	lr
